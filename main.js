/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const { type: type2, value } = formatted[i];
        const pos = typeToPos[type2];
        if (type2 === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s2) {
        return this.isValidZone(s2);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f) {
      const ms = [];
      for (let i = 1; i <= 12; i++) {
        const dt = DateTime.utc(2016, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays(f) {
      const ms = [];
      for (let i = 1; i <= 7; i++) {
        const dt = DateTime.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      const mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart2(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        let z = void 0;
        if (dt.zone.isUniversal) {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false, defaultOK = true) {
        return listStuff(this, length, defaultOK, months, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false, defaultOK = true) {
        return listStuff(this, length, defaultOK, weekdays, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems(defaultOK = true) {
        return listStuff(
          this,
          void 0,
          defaultOK,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length, defaultOK = true) {
        return listStuff(this, length, defaultOK, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s2) {
        if (s2) {
          const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone(signedOffset(r[1], r[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n2) {
        now = n2;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t) {
        throwOnInvalid = t;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber(o) {
      return typeof o === "number";
    }
    function isInteger2(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a, k) => {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger2(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart2(input, n2 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n2, "0");
      } else {
        padded = ("" + input).padStart(n2, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      return +d;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u in obj) {
        if (hasOwnProperty(obj, u)) {
          const v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart2(hours, 2)}:${padStart2(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart2(hours, 2)}${padStart2(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s2 = "";
      for (const token of splits) {
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class {
      static create(locale, opts = {}) {
        return new Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i = 0; i < fmt.length; i++) {
          const c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed, val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: false, val: currentFull });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      formatDateTime(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      formatDateTimeParts(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.formatToParts();
      }
      formatInterval(interval, opts = {}) {
        const df = this.loc.dtFormatter(interval.start, { ...this.opts, ...opts });
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.resolvedOptions();
      }
      num(n2, p = 0) {
        if (this.opts.forceSimple) {
          return padStart2(n2, p);
        }
        const opts = { ...this.opts };
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n2);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f, r) => f + r.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse(s2, ...patterns) {
      if (s2 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match2, cursor) => {
        const ret = {};
        let i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match2[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int2(match2, pos, fallback) {
      const m = match2[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match2, cursor) {
      const item = {
        year: int2(match2, cursor),
        month: int2(match2, cursor + 1, 1),
        day: int2(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      const item = {
        hours: int2(match2, cursor, 0),
        minutes: int2(match2, cursor + 1, 0),
        seconds: int2(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match2) {
      const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
      const hasNegativePrefix = s2[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s2) {
      return parse(
        s2,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s2) {
      return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse(
        s2,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s2) {
      return parse(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s2) {
      return parse(
        s2,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function antiTrunc(n2) {
      return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
    }
    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix, vals) {
      reverseUnits.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config.matrix) {
          matrix = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        const l2 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n2) => n2);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s2 = "P";
        if (this.years !== 0)
          s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s2 += this.weeks + "W";
        if (this.days !== 0)
          s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s2 += "T";
        if (this.hours !== 0)
          s2 += this.hours + "H";
        if (this.minutes !== 0)
          s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P")
          s2 += "T0S";
        return s2;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts
        };
        const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        let str2 = value.toFormat(fmt);
        if (opts.includePrefix) {
          str2 = "T" + str2;
        }
        return str2;
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        return this.as("milliseconds");
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result = {};
        for (const k of orderedUnits$1) {
          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k of Object.keys(this.values)) {
          result[k] = asNumber(fn(this.values[k], k));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u) => Duration.normalizeUnit(u));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k of orderedUnits$1) {
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber(vals[k])) {
              own += vals[k];
            }
            const i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
            for (const down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            }
          } else if (isNumber(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone$1(this, { values: built }, true).normalize();
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k of Object.keys(this.values)) {
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u of orderedUnits$1) {
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s2, e] = (text || "").split("/", 2);
        if (s2 && e) {
          let start, startIsValid;
          try {
            start = DateTime.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s2, opts);
            if (dur.isValid) {
              return Interval.before(end, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
        let { s: s2 } = this, i = 0;
        while (s2 < this.e) {
          const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s2 } = this, idx = 1, next;
        const results = [];
        while (s2 < this.e) {
          const added = this.start.plus(dur.mapUnits((x) => x * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return Interval.fromDateTimes(s2, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s2, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i) => [
          { time: i.s, type: "s" },
          { time: i.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
        for (const i of arr) {
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a, b) => b.year - a.year],
        ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
        ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
        [
          "weeks",
          (a, b) => {
            const days = dayDiff(a, b);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str2) {
      let value = parseInt(str2, 10);
      if (isNaN(value)) {
        value = "";
        for (let i = 0; i < str2.length; i++) {
          const code = str2.charCodeAt(i);
          if (str2[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str2[i]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min, max] = numberingSystemsUTF16[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i) => i) {
      return { regex, deser: ([s2]) => post(parseDigits(s2)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s2]) => s2 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts) {
      const { type: type2, value } = part;
      if (type2 === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      const style = formatOpts[type2];
      let val = partTypeStyleToTokenVal[type2];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
      return [`^${re}$`, units];
    }
    function match(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i in handlers) {
          if (hasOwnProperty(handlers, i)) {
            const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r, k) => {
        const f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
    }
    function explainFromTokens(locale, input, format) {
      const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
        if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const parts = formatter.formatDateTimeParts(getDummyDateTime());
      return parts.map((p) => tokenForPart(p, formatOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      const js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(weekData) };
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return { year, ordinal, ...timeObject(gregData) };
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(ordinalData) };
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger2(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger2(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger2(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime({ ...current, ...alts, old: current });
    }
    function fixOffset(localTS, o, tz) {
      let utcGuess = localTS - o * 60 * 1e3;
      const o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      let [ts, o] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return { ts, o };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0) {
        const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(
          new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat(dt, format, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate(o, extended) {
      const longFormat = o.c.year > 9999 || o.c.year < 0;
      let c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart2(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart2(o.c.month);
        c += "-";
        c += padStart2(o.c.day);
      } else {
        c += padStart2(o.c.month);
        c += padStart2(o.c.day);
      }
      return c;
    }
    function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c = padStart2(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart2(o.c.minute);
        if (o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart2(o.c.minute);
      }
      if (o.c.second !== 0 || !suppressSeconds) {
        c += padStart2(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart2(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart2(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart2(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart2(Math.trunc(o.o / 60));
          c += ":";
          c += padStart2(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o;
      if (!isUndefined(obj.year)) {
        for (const u of orderedUnits) {
          if (isUndefined(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime({ ts, zone, loc, o });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime = class {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings.defaultZone;
        let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        let c = null, o = null;
        if (!invalid) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c, o] = [config.old.c, config.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime.invalid("Timestamp out of range");
        } else {
          return new DateTime({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u of units) {
          const v = normalized[u];
          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
        if (invalid) {
          return DateTime.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t) => t.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o] = objToTS(mixed, this.o, this.zone);
        return clone(this, { ts, o });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c = toISODate(this, ext);
        c += "T";
        c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c = includePrefix ? "T" : "";
        return c + toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        this.value = value;
        this.successful = true;
      }
      map(f) {
        return new Success(f(this.value));
      }
      flatMap(f) {
        return f(this.value);
      }
      mapErr(f) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f) {
        return new Failure(f(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f) {
        if (first.successful) {
          if (second.successful)
            return f(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f) {
        return flatMap2(first, second, (a, b) => success(f(a, b)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    (function(module3, exports2) {
      !function(n2, t) {
        module3.exports = t();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n2) {
          var t = {};
          function r(e) {
            if (t[e])
              return t[e].exports;
            var u = t[e] = { i: e, l: false, exports: {} };
            return n2[e].call(u.exports, u, u.exports, r), u.l = true, u.exports;
          }
          return r.m = n2, r.c = t, r.d = function(n3, t2, e) {
            r.o(n3, t2) || Object.defineProperty(n3, t2, { configurable: false, enumerable: true, get: e });
          }, r.r = function(n3) {
            Object.defineProperty(n3, "__esModule", { value: true });
          }, r.n = function(n3) {
            var t2 = n3 && n3.__esModule ? function() {
              return n3.default;
            } : function() {
              return n3;
            };
            return r.d(t2, "a", t2), t2;
          }, r.o = function(n3, t2) {
            return Object.prototype.hasOwnProperty.call(n3, t2);
          }, r.p = "", r(r.s = 0);
        }([function(n2, t, r) {
          function e(n3) {
            if (!(this instanceof e))
              return new e(n3);
            this._ = n3;
          }
          var u = e.prototype;
          function o(n3, t2) {
            for (var r2 = 0; r2 < n3; r2++)
              t2(r2);
          }
          function i(n3, t2, r2) {
            return function(n4, t3) {
              o(t3.length, function(r3) {
                n4(t3[r3], r3, t3);
              });
            }(function(r3, e2, u2) {
              t2 = n3(t2, r3, e2, u2);
            }, r2), t2;
          }
          function a(n3, t2) {
            return i(function(t3, r2, e2, u2) {
              return t3.concat([n3(r2, e2, u2)]);
            }, [], t2);
          }
          function f(n3, t2) {
            var r2 = { v: 0, buf: t2 };
            return o(n3, function() {
              var n4;
              r2 = { v: r2.v << 1 | (n4 = r2.buf, n4[0] >> 7), buf: function(n5) {
                var t3 = i(function(n6, t4, r3, e2) {
                  return n6.concat(r3 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r3));
                }, [], n5);
                return Buffer.from(a(function(n6) {
                  return (n6 << 1 & 65535) >> 8;
                }, t3));
              }(r2.buf) };
            }), r2;
          }
          function c() {
            return "undefined" != typeof Buffer;
          }
          function s2() {
            if (!c())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l2(n3) {
            s2();
            var t2 = i(function(n4, t3) {
              return n4 + t3;
            }, 0, n3);
            if (t2 % 8 != 0)
              throw new Error("The bits [" + n3.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
            var r2, u2 = t2 / 8, o2 = (r2 = function(n4) {
              return n4 > 48;
            }, i(function(n4, t3) {
              return n4 || (r2(t3) ? t3 : n4);
            }, null, n3));
            if (o2)
              throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t3, r3) {
              var e2 = u2 + r3;
              return e2 > t3.length ? x(r3, u2.toString() + " bytes") : b(e2, i(function(n4, t4) {
                var r4 = f(t4, n4.buf);
                return { coll: n4.coll.concat(r4.v), buf: r4.buf };
              }, { coll: [], buf: t3.slice(r3, e2) }, n3).coll);
            });
          }
          function h(n3, t2) {
            return new e(function(r2, e2) {
              return s2(), e2 + t2 > r2.length ? x(e2, t2 + " bytes for " + n3) : b(e2 + t2, r2.slice(e2, e2 + t2));
            });
          }
          function p(n3, t2) {
            if ("number" != typeof (r2 = t2) || Math.floor(r2) !== r2 || t2 < 0 || t2 > 6)
              throw new Error(n3 + " requires integer length in range [0, 6].");
            var r2;
          }
          function d(n3) {
            return p("uintBE", n3), h("uintBE(" + n3 + ")", n3).map(function(t2) {
              return t2.readUIntBE(0, n3);
            });
          }
          function v(n3) {
            return p("uintLE", n3), h("uintLE(" + n3 + ")", n3).map(function(t2) {
              return t2.readUIntLE(0, n3);
            });
          }
          function g(n3) {
            return p("intBE", n3), h("intBE(" + n3 + ")", n3).map(function(t2) {
              return t2.readIntBE(0, n3);
            });
          }
          function m(n3) {
            return p("intLE", n3), h("intLE(" + n3 + ")", n3).map(function(t2) {
              return t2.readIntLE(0, n3);
            });
          }
          function y(n3) {
            return n3 instanceof e;
          }
          function E(n3) {
            return "[object Array]" === {}.toString.call(n3);
          }
          function w(n3) {
            return c() && Buffer.isBuffer(n3);
          }
          function b(n3, t2) {
            return { status: true, index: n3, value: t2, furthest: -1, expected: [] };
          }
          function x(n3, t2) {
            return E(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n3, expected: t2 };
          }
          function B(n3, t2) {
            if (!t2)
              return n3;
            if (n3.furthest > t2.furthest)
              return n3;
            var r2 = n3.furthest === t2.furthest ? function(n4, t3) {
              if (function() {
                if (void 0 !== e._supportsSet)
                  return e._supportsSet;
                var n5 = "undefined" != typeof Set;
                return e._supportsSet = n5, n5;
              }() && Array.from) {
                for (var r3 = new Set(n4), u2 = 0; u2 < t3.length; u2++)
                  r3.add(t3[u2]);
                var o2 = Array.from(r3);
                return o2.sort(), o2;
              }
              for (var i2 = {}, a2 = 0; a2 < n4.length; a2++)
                i2[n4[a2]] = true;
              for (var f2 = 0; f2 < t3.length; f2++)
                i2[t3[f2]] = true;
              var c2 = [];
              for (var s3 in i2)
                ({}).hasOwnProperty.call(i2, s3) && c2.push(s3);
              return c2.sort(), c2;
            }(n3.expected, t2.expected) : t2.expected;
            return { status: n3.status, index: n3.index, value: n3.value, furthest: t2.furthest, expected: r2 };
          }
          var j = {};
          function S(n3, t2) {
            if (w(n3))
              return { offset: t2, line: -1, column: -1 };
            n3 in j || (j[n3] = {});
            for (var r2 = j[n3], e2 = 0, u2 = 0, o2 = 0, i2 = t2; i2 >= 0; ) {
              if (i2 in r2) {
                e2 = r2[i2].line, 0 === o2 && (o2 = r2[i2].lineStart);
                break;
              }
              ("\n" === n3.charAt(i2) || "\r" === n3.charAt(i2) && "\n" !== n3.charAt(i2 + 1)) && (u2++, 0 === o2 && (o2 = i2 + 1)), i2--;
            }
            var a2 = e2 + u2, f2 = t2 - o2;
            return r2[t2] = { line: a2, lineStart: o2 }, { offset: t2, line: a2 + 1, column: f2 + 1 };
          }
          function _(n3) {
            if (!y(n3))
              throw new Error("not a parser: " + n3);
          }
          function L(n3, t2) {
            return "string" == typeof n3 ? n3.charAt(t2) : n3[t2];
          }
          function O(n3) {
            if ("number" != typeof n3)
              throw new Error("not a number: " + n3);
          }
          function k(n3) {
            if ("function" != typeof n3)
              throw new Error("not a function: " + n3);
          }
          function P(n3) {
            if ("string" != typeof n3)
              throw new Error("not a string: " + n3);
          }
          var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z = "  ";
          function R(n3, t2) {
            return new Array(t2 + 1).join(n3);
          }
          function U(n3, t2, r2) {
            var e2 = t2 - n3.length;
            return e2 <= 0 ? n3 : R(r2, e2) + n3;
          }
          function W(n3, t2, r2, e2) {
            return { from: n3 - t2 > 0 ? n3 - t2 : 0, to: n3 + r2 > e2 ? e2 : n3 + r2 };
          }
          function D(n3, t2) {
            var r2, e2, u2, o2, f2, c2 = t2.index, s3 = c2.offset, l3 = 1;
            if (s3 === n3.length)
              return "Got the end of the input";
            if (w(n3)) {
              var h2 = s3 - s3 % I, p2 = s3 - h2, d2 = W(h2, F, M + I, n3.length), v2 = a(function(n4) {
                return a(function(n5) {
                  return U(n5.toString(16), 2, "0");
                }, n4);
              }, function(n4, t3) {
                var r3 = n4.length, e3 = [], u3 = 0;
                if (r3 <= t3)
                  return [n4.slice()];
                for (var o3 = 0; o3 < r3; o3++)
                  e3[u3] || e3.push([]), e3[u3].push(n4[o3]), (o3 + 1) % t3 == 0 && u3++;
                return e3;
              }(n3.slice(d2.from, d2.to).toJSON().data, I));
              o2 = function(n4) {
                return 0 === n4.from && 1 === n4.to ? { from: n4.from, to: n4.to } : { from: n4.from / I, to: Math.floor(n4.to / I) };
              }(d2), e2 = h2 / I, r2 = 3 * p2, p2 >= 4 && (r2 += 1), l3 = 2, u2 = a(function(n4) {
                return n4.length <= 4 ? n4.join(" ") : n4.slice(0, 4).join(" ") + "  " + n4.slice(4).join(" ");
              }, v2), (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2);
            } else {
              var g2 = n3.split(/\r\n|[\n\r\u2028\u2029]/);
              r2 = c2.column - 1, e2 = c2.line - 1, o2 = W(e2, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f2 = o2.to.toString().length;
            }
            var m2 = e2 - o2.from;
            return w(n3) && (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2), i(function(t3, e3, u3) {
              var i2, a2 = u3 === m2, c3 = a2 ? "> " : z;
              return i2 = w(n3) ? U((8 * (o2.from + u3)).toString(16), f2, "0") : U((o2.from + u3 + 1).toString(), f2, " "), [].concat(t3, [c3 + i2 + " | " + e3], a2 ? [z + R(" ", f2) + " | " + U("", r2, " ") + R("^", l3)] : []);
            }, [], u2).join("\n");
          }
          function N(n3, t2) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n3, t2), "\n\n", (r2 = t2.expected, 1 === r2.length ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
            var r2;
          }
          function G(n3) {
            return void 0 !== n3.flags ? n3.flags : [n3.global ? "g" : "", n3.ignoreCase ? "i" : "", n3.multiline ? "m" : "", n3.unicode ? "u" : "", n3.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n3 = [].slice.call(arguments), t2 = n3.length, r2 = 0; r2 < t2; r2 += 1)
              _(n3[r2]);
            return e(function(r3, e2) {
              for (var u2, o2 = new Array(t2), i2 = 0; i2 < t2; i2 += 1) {
                if (!(u2 = B(n3[i2]._(r3, e2), u2)).status)
                  return u2;
                o2[i2] = u2.value, e2 = u2.index;
              }
              return B(b(e2, o2), u2);
            });
          }
          function J() {
            var n3 = [].slice.call(arguments);
            if (0 === n3.length)
              throw new Error("seqMap needs at least one argument");
            var t2 = n3.pop();
            return k(t2), C.apply(null, n3).map(function(n4) {
              return t2.apply(null, n4);
            });
          }
          function T() {
            var n3 = [].slice.call(arguments), t2 = n3.length;
            if (0 === t2)
              return Y("zero alternates");
            for (var r2 = 0; r2 < t2; r2 += 1)
              _(n3[r2]);
            return e(function(t3, r3) {
              for (var e2, u2 = 0; u2 < n3.length; u2 += 1)
                if ((e2 = B(n3[u2]._(t3, r3), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n3, t2) {
            return H(n3, t2).or(X([]));
          }
          function H(n3, t2) {
            return _(n3), _(t2), J(n3, t2.then(n3).many(), function(n4, t3) {
              return [n4].concat(t3);
            });
          }
          function K(n3) {
            P(n3);
            var t2 = "'" + n3 + "'";
            return e(function(r2, e2) {
              var u2 = e2 + n3.length, o2 = r2.slice(e2, u2);
              return o2 === n3 ? b(u2, o2) : x(e2, t2);
            });
          }
          function Q(n3, t2) {
            !function(n4) {
              if (!(n4 instanceof RegExp))
                throw new Error("not a regexp: " + n4);
              for (var t3 = G(n4), r3 = 0; r3 < t3.length; r3++) {
                var e2 = t3.charAt(r3);
                if ("i" !== e2 && "m" !== e2 && "u" !== e2 && "s" !== e2)
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n4);
              }
            }(n3), arguments.length >= 2 ? O(t2) : t2 = 0;
            var r2 = function(n4) {
              return RegExp("^(?:" + n4.source + ")", G(n4));
            }(n3), u2 = "" + n3;
            return e(function(n4, e2) {
              var o2 = r2.exec(n4.slice(e2));
              if (o2) {
                if (0 <= t2 && t2 <= o2.length) {
                  var i2 = o2[0], a2 = o2[t2];
                  return b(e2 + i2.length, a2);
                }
                return x(e2, "valid match group (0 to " + o2.length + ") in " + u2);
              }
              return x(e2, u2);
            });
          }
          function X(n3) {
            return e(function(t2, r2) {
              return b(r2, n3);
            });
          }
          function Y(n3) {
            return e(function(t2, r2) {
              return x(r2, n3);
            });
          }
          function Z(n3) {
            if (y(n3))
              return e(function(t2, r2) {
                var e2 = n3._(t2, r2);
                return e2.index = r2, e2.value = "", e2;
              });
            if ("string" == typeof n3)
              return Z(K(n3));
            if (n3 instanceof RegExp)
              return Z(Q(n3));
            throw new Error("not a string, regexp, or parser: " + n3);
          }
          function $(n3) {
            return _(n3), e(function(t2, r2) {
              var e2 = n3._(t2, r2), u2 = t2.slice(r2, e2.index);
              return e2.status ? x(r2, 'not "' + u2 + '"') : b(r2, null);
            });
          }
          function nn(n3) {
            return k(n3), e(function(t2, r2) {
              var e2 = L(t2, r2);
              return r2 < t2.length && n3(e2) ? b(r2 + 1, e2) : x(r2, "a character/byte matching " + n3);
            });
          }
          function tn(n3, t2) {
            arguments.length < 2 && (t2 = n3, n3 = void 0);
            var r2 = e(function(n4, e2) {
              return r2._ = t2()._, r2._(n4, e2);
            });
            return n3 ? r2.desc(n3) : r2;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u.parse = function(n3) {
            if ("string" != typeof n3 && !w(n3))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t2, r2 = this.skip(an)._(n3, 0);
            return t2 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n3, r2.furthest), expected: r2.expected }, delete j[n3], t2;
          }, u.tryParse = function(n3) {
            var t2 = this.parse(n3);
            if (t2.status)
              return t2.value;
            var r2 = N(n3, t2), e2 = new Error(r2);
            throw e2.type = "ParsimmonError", e2.result = t2, e2;
          }, u.assert = function(n3, t2) {
            return this.chain(function(r2) {
              return n3(r2) ? X(r2) : Y(t2);
            });
          }, u.or = function(n3) {
            return T(this, n3);
          }, u.trim = function(n3) {
            return this.wrap(n3, n3);
          }, u.wrap = function(n3, t2) {
            return J(n3, this, t2, function(n4, t3) {
              return t3;
            });
          }, u.thru = function(n3) {
            return n3(this);
          }, u.then = function(n3) {
            return _(n3), C(this, n3).map(function(n4) {
              return n4[1];
            });
          }, u.many = function() {
            var n3 = this;
            return e(function(t2, r2) {
              for (var e2 = [], u2 = void 0; ; ) {
                if (!(u2 = B(n3._(t2, r2), u2)).status)
                  return B(b(r2, e2), u2);
                if (r2 === u2.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r2 = u2.index, e2.push(u2.value);
              }
            });
          }, u.tieWith = function(n3) {
            return P(n3), this.map(function(t2) {
              if (function(n4) {
                if (!E(n4))
                  throw new Error("not an array: " + n4);
              }(t2), t2.length) {
                P(t2[0]);
                for (var r2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                  P(t2[e2]), r2 += n3 + t2[e2];
                return r2;
              }
              return "";
            });
          }, u.tie = function() {
            return this.tieWith("");
          }, u.times = function(n3, t2) {
            var r2 = this;
            return arguments.length < 2 && (t2 = n3), O(n3), O(t2), e(function(e2, u2) {
              for (var o2 = [], i2 = void 0, a2 = void 0, f2 = 0; f2 < n3; f2 += 1) {
                if (a2 = B(i2 = r2._(e2, u2), a2), !i2.status)
                  return a2;
                u2 = i2.index, o2.push(i2.value);
              }
              for (; f2 < t2 && (a2 = B(i2 = r2._(e2, u2), a2), i2.status); f2 += 1)
                u2 = i2.index, o2.push(i2.value);
              return B(b(u2, o2), a2);
            });
          }, u.result = function(n3) {
            return this.map(function() {
              return n3;
            });
          }, u.atMost = function(n3) {
            return this.times(0, n3);
          }, u.atLeast = function(n3) {
            return J(this.times(n3), this.many(), function(n4, t2) {
              return n4.concat(t2);
            });
          }, u.map = function(n3) {
            k(n3);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(b(u2.index, n3(u2.value)), u2) : u2;
            });
          }, u.contramap = function(n3) {
            k(n3);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2.parse(n3(r2.slice(e2)));
              return u2.status ? b(e2 + r2.length, u2.value) : u2;
            });
          }, u.promap = function(n3, t2) {
            return k(n3), k(t2), this.contramap(n3).map(t2);
          }, u.skip = function(n3) {
            return C(this, n3).map(function(n4) {
              return n4[0];
            });
          }, u.mark = function() {
            return J(en, this, en, function(n3, t2, r2) {
              return { start: n3, value: t2, end: r2 };
            });
          }, u.node = function(n3) {
            return J(en, this, en, function(t2, r2, e2) {
              return { name: n3, value: r2, start: t2, end: e2 };
            });
          }, u.sepBy = function(n3) {
            return V(this, n3);
          }, u.sepBy1 = function(n3) {
            return H(this, n3);
          }, u.lookahead = function(n3) {
            return this.skip(Z(n3));
          }, u.notFollowedBy = function(n3) {
            return this.skip($(n3));
          }, u.desc = function(n3) {
            E(n3) || (n3 = [n3]);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status || (u2.expected = n3), u2;
            });
          }, u.fallback = function(n3) {
            return this.or(X(n3));
          }, u.ap = function(n3) {
            return J(n3, this, function(n4, t2) {
              return n4(t2);
            });
          }, u.chain = function(n3) {
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(n3(u2.value)._(r2, u2.index), u2) : u2;
            });
          }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
          var en = e(function(n3, t2) {
            return b(t2, S(n3, t2));
          }), un = e(function(n3, t2) {
            return t2 >= n3.length ? x(t2, "any character/byte") : b(t2 + 1, L(n3, t2));
          }), on = e(function(n3, t2) {
            return b(n3.length, n3.slice(t2));
          }), an = e(function(n3, t2) {
            return t2 < n3.length ? x(t2, "EOF") : b(t2, null);
          }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T(gn, vn, dn).desc("newline"), yn = T(mn, an);
          e.all = on, e.alt = T, e.any = un, e.cr = dn, e.createLanguage = function(n3) {
            var t2 = {};
            for (var r2 in n3)
              ({}).hasOwnProperty.call(n3, r2) && function(r3) {
                t2[r3] = tn(function() {
                  return n3[r3](t2);
                });
              }(r2);
            return t2;
          }, e.crlf = gn, e.custom = function(n3) {
            return e(n3(b, x));
          }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x, e.makeSuccess = b, e.newline = mn, e.noneOf = function(n3) {
            return nn(function(t2) {
              return n3.indexOf(t2) < 0;
            }).desc("none of '" + n3 + "'");
          }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n3) {
            for (var t2 = n3.split(""), r2 = 0; r2 < t2.length; r2++)
              t2[r2] = "'" + t2[r2] + "'";
            return nn(function(t3) {
              return n3.indexOf(t3) >= 0;
            }).desc(t2);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n3, t2) {
            return nn(function(r2) {
              return n3 <= r2 && r2 <= t2;
            }).desc(n3 + "-" + t2);
          }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n3, t2 = {}, r2 = 0, u2 = (n3 = arguments, Array.prototype.slice.call(n3)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
              var a2 = u2[i2];
              if (!y(a2)) {
                if (E(a2) && 2 === a2.length && "string" == typeof a2[0] && y(a2[1])) {
                  var f2 = a2[0];
                  if (Object.prototype.hasOwnProperty.call(t2, f2))
                    throw new Error("seqObj: duplicate key " + f2);
                  t2[f2] = true, r2++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r2)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n4, t3) {
              for (var r3, e2 = {}, i3 = 0; i3 < o2; i3 += 1) {
                var a3, f3;
                if (E(u2[i3]) ? (a3 = u2[i3][0], f3 = u2[i3][1]) : (a3 = null, f3 = u2[i3]), !(r3 = B(f3._(n4, t3), r3)).status)
                  return r3;
                a3 && (e2[a3] = r3.value), t3 = r3.index;
              }
              return B(b(t3, e2), r3);
            });
          }, e.string = K, e.succeed = X, e.takeWhile = function(n3) {
            return k(n3), e(function(t2, r2) {
              for (var e2 = r2; e2 < t2.length && n3(L(t2, e2)); )
                e2++;
              return b(e2, t2.slice(r2, e2));
            });
          }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l2, bitSeqObj: function(n3) {
            s2();
            var t2 = {}, r2 = 0, e2 = a(function(n4) {
              if (E(n4)) {
                var e3 = n4;
                if (2 !== e3.length)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P(e3[0]), O(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t2[e3[0]] = true, r2++, e3;
              }
              return O(n4), [null, n4];
            }, n3);
            if (r2 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n3.join(", ") + "]");
            var u2 = a(function(n4) {
              return n4[0];
            }, e2);
            return l2(a(function(n4) {
              return n4[1];
            }, e2)).map(function(n4) {
              return i(function(n5, t3) {
                return null !== t3[0] && (n5[t3[0]] = t3[1]), n5;
              }, {}, a(function(t3, r3) {
                return [t3, n4[r3]];
              }, u2));
            });
          }, byte: function(n3) {
            if (s2(), O(n3), n3 > 255)
              throw new Error("Value specified to byte constructor (" + n3 + "=0x" + n3.toString(16) + ") is larger in value than a single byte.");
            var t2 = (n3 > 15 ? "0x" : "0x0") + n3.toString(16);
            return e(function(r2, e2) {
              var u2 = L(r2, e2);
              return u2 === n3 ? b(e2 + 1, u2) : x(e2, t2);
            });
          }, buffer: function(n3) {
            return h("buffer", n3).map(function(n4) {
              return Buffer.from(n4);
            });
          }, encodedString: function(n3, t2) {
            return h("string", t2).map(function(t3) {
              return t3.toString(n3);
            });
          }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v, uint8LE: v(1), uint16LE: v(2), uint32LE: v(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n3) {
            return n3.readFloatBE(0);
          }), floatLE: h("floatLE", 4).map(function(n3) {
            return n3.readFloatLE(0);
          }), doubleBE: h("doubleBE", 8).map(function(n3) {
            return n3.readDoubleBE(0);
          }), doubleLE: h("doubleLE", 8).map(function(n3) {
            return n3.readDoubleLE(0);
          }) }, n2.exports = e;
        }]);
      });
    })(parsimmon_umd_min);
    var emojiRegex = () => {
      return /(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDD-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF6](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC2\uDED0-\uDED9\uDEE0-\uDEE7]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u).map((str2) => str2.toLocaleLowerCase()), parsimmon_umd_min.exports.whitespace.map((_) => "-"), parsimmon_umd_min.exports.any.map((_) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_min.exports.whitespace.map((_) => " "), parsimmon_umd_min.exports.any.map((_) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity > 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString2(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f) => toString2(f, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString2(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString2;
      function wrapValue(val) {
        if (isNull2(val))
          return { type: "null", value: val };
        else if (isNumber2(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean2(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate2(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer !== null && linkNormalizer !== void 0 ? linkNormalizer : (x) => x;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) !== null && _a !== void 0 ? _a : "").localeCompare((_b = link2.subpath) !== null && _b !== void 0 ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
              let comp = compareValue(f1[index], f2[index]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) === null || _a === void 0 ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v) => deepCopy(v)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber2(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber2;
      function isDate2(val) {
        return val instanceof DateTime;
      }
      Values2.isDate = isDate2;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull2(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull2;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean2(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean2;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate2(val) && !isLink(val) && val !== void 0 && !isNull2(val);
      }
      Values2.isObject = isObject2;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return Link.header(split[0], split[1], embed, display);
        } else
          return Link.file(linkpath, embed, display);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display) {
        return new Link(Object.assign({}, this, { display }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replace("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) === null || _a === void 0 ? void 0 : _a.replace("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) === null || _b === void 0 ? void 0 : _b.replace("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) !== null && _a !== void 0 ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index(obj, index2) {
        return { type: "index", object: obj, index: index2 };
      }
      Fields2.index = index;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index2 = 1; index2 < parts.length; index2++) {
          result = Fields2.index(result, Fields2.literal(parts[index2]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty() {
        return { type: "empty" };
      }
      Sources2.empty = empty;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime.local(),
      today: () => DateTime.local().startOf("day"),
      yesterday: () => DateTime.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime.local().startOf("week"),
      "start-of-week": () => DateTime.local().startOf("week"),
      eow: () => DateTime.local().endOf("week"),
      "end-of-week": () => DateTime.local().endOf("week"),
      soy: () => DateTime.local().startOf("year"),
      "start-of-year": () => DateTime.local().startOf("year"),
      eoy: () => DateTime.local().endOf("year"),
      "end-of-year": () => DateTime.local().endOf("year"),
      som: () => DateTime.local().startOf("month"),
      "start-of-month": () => DateTime.local().startOf("month"),
      eom: () => DateTime.local().endOf("month"),
      "end-of-month": () => DateTime.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep, combine) {
      return parsimmon_umd_min.exports.seqMap(child, parsimmon_umd_min.exports.seq(parsimmon_umd_min.exports.optWhitespace, sep, parsimmon_umd_min.exports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine(first, rest[0][1], rest[0][3]);
        for (let index = 1; index < rest.length; index++) {
          node = combine(node, rest[index][1], rest[index][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_min.exports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q) => parsimmon_umd_min.exports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str2) => Number.parseFloat(str2)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q) => parsimmon_umd_min.exports.string('"').then(parsimmon_umd_min.exports.alt(q.escapeCharacter, parsimmon_umd_min.exports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_min.exports.string('"')).desc("string"),
      escapeCharacter: (_) => parsimmon_umd_min.exports.string("\\").then(parsimmon_umd_min.exports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_) => parsimmon_umd_min.exports.regexp(/true|false|True|False/).map((str2) => str2.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("#"), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/\p{Letter}/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_) => parsimmon_umd_min.exports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!").atMost(1), q.link, (p, l2) => {
        if (p.length > 0)
          l2.embed = true;
        return l2;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_) => parsimmon_umd_min.exports.regexp(/\+|-/).map((str2) => str2).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_) => parsimmon_umd_min.exports.regexp(/\*|\/|%/).map((str2) => str2).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_) => parsimmon_umd_min.exports.regexp(/>=|<=|!=|>|<|=/).map((str2) => str2).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_) => parsimmon_umd_min.exports.regexp(/and|or|&|\|/i).map((str2) => {
        if (str2.toLowerCase() == "and")
          return "&";
        else if (str2.toLowerCase() == "or")
          return "|";
        else
          return str2;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/\d{4}/), parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (year, _2, month) => {
        return DateTime.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_) => parsimmon_umd_min.exports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_min.exports.string)),
      date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("T"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), parsimmon_umd_min.exports.regexp(/\d{3}/), (_, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_min.exports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("+").or(parsimmon_umd_min.exports.string("-")), parsimmon_umd_min.exports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_min.exports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q) => parsimmon_umd_min.exports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_) => parsimmon_umd_min.exports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_min.exports.string)),
      duration: (q) => parsimmon_umd_min.exports.seqMap(q.number, parsimmon_umd_min.exports.optWhitespace, q.durationType, (count, _, t) => DURATION_TYPES[t].mapUnits((x) => x * count)).sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).or(parsimmon_umd_min.exports.optWhitespace)).map((durations) => durations.reduce((p, c) => p.plus(c))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_) => parsimmon_umd_min.exports.string("null"),
      // Source parsing.
      tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("csv(").skip(parsimmon_umd_min.exports.optWhitespace), q.string, parsimmon_umd_min.exports.string(")"), (_1, path, _2) => Sources.csv(path)),
      linkIncomingSource: (q) => q.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("outgoing(").skip(parsimmon_umd_min.exports.optWhitespace), q.link, parsimmon_umd_min.exports.string(")"), (_1, link, _2) => Sources.link(link.path, false)),
      folderSource: (q) => q.string.map((str2) => Sources.folder(str2)),
      parensSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.source, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _2, field, _3, _4) => field),
      negateSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.string("!")), q.atomSource, (_, source) => Sources.negate(source)),
      atomSource: (q) => parsimmon_umd_min.exports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
      binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s2) => s2), Sources.binaryOp),
      source: (q) => q.binaryOpSource,
      // Field parsing.
      variableField: (q) => q.identifier.chain((r) => {
        if (KEYWORDS.includes(r.toUpperCase())) {
          return parsimmon_umd_min.exports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_min.exports.succeed(Fields.variable(r));
        }
      }).desc("variable"),
      numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("date("), parsimmon_umd_min.exports.optWhitespace, q.datePlus, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, date, _2, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("dur("), parsimmon_umd_min.exports.optWhitespace, q.duration, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, dur, _2, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q) => q.rawNull.map((_) => Fields.NULL),
      linkField: (q) => q.link.map((f) => Fields.literal(f)),
      listField: (q) => q.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("[").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("]"))).map((l2) => Fields.list(l2)).desc("list ('[1, 2, 3]')"),
      objectField: (q) => parsimmon_umd_min.exports.seqMap(q.identifier.or(q.string), parsimmon_umd_min.exports.string(":").trim(parsimmon_umd_min.exports.optWhitespace), q.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("{").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q) => parsimmon_umd_min.exports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
      inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).lookahead(q.atomInlineField)),
      inlineField: (q) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(q.atomInlineField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace), q.inlineFieldList, (f, _s, l2) => [f].concat(l2)), q.atomInlineField),
      atomField: (q) => parsimmon_umd_min.exports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q.embedLink.map((l2) => Fields.literal(l2)),
        q.negatedField,
        q.linkField,
        q.listField,
        q.objectField,
        q.lambdaField,
        q.parensField,
        q.boolField,
        q.numberField,
        q.stringField,
        q.dateField,
        q.durationField,
        q.nullField,
        q.variableField
      ),
      indexField: (q) => parsimmon_umd_min.exports.seqMap(q.atomField, parsimmon_umd_min.exports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!"), q.indexField, (_, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _2, field, _3, _4) => field),
      lambdaField: (q) => parsimmon_umd_min.exports.seqMap(q.identifier.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("(").trim(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.string(")").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.string("=>").trim(parsimmon_umd_min.exports.optWhitespace), q.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), q.identifier, (_, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.optWhitespace, q.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string("]"), (_, _2, field, _3, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_, _1, fields, _2, _3) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q) => q.binaryBooleanField,
      field: (q) => q.binaryOpField
    });
    function parseField2(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t) => t.trim()).join("");
    }
    var QUERY_LANGUAGE = parsimmon_umd_min.exports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str2) => str2.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.whitespace), parsimmon_umd_min.exports.regexp(/AS/i).skip(parsimmon_umd_min.exports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      namedField: (q) => parsimmon_umd_min.exports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q) => q.queryType.skip(parsimmon_umd_min.exports.whitespace).chain((qtype) => {
        switch (qtype) {
          case "table":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), parsimmon_umd_min.exports.sepBy(q.namedField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (withoutId, fields) => {
              return { type: "table", fields, showId: withoutId.length == 0 };
            });
          case "list":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type: "list",
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            });
          case "task":
            return parsimmon_umd_min.exports.succeed({ type: "task" });
          case "calendar":
            return parsimmon_umd_min.exports.seqMap(q.namedField, (field) => {
              return {
                type: "calendar",
                showId: true,
                field
              };
            });
          default:
            return parsimmon_umd_min.exports.fail(`Unrecognized query type '${qtype}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FROM/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.source, (_1, _2, source) => source),
      whereClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WHERE/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (where, _, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/SORT/i), parsimmon_umd_min.exports.whitespace, q.sortField.sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (sort, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/LIMIT/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FLATTEN/i).skip(parsimmon_umd_min.exports.whitespace), q.namedField, (_, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/GROUP BY/i).skip(parsimmon_umd_min.exports.whitespace), q.namedField, (_, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q) => parsimmon_umd_min.exports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
      query: (q) => parsimmon_umd_min.exports.seqMap(q.headerClause.trim(parsimmon_umd_min.exports.optWhitespace), q.fromClause.trim(parsimmon_umd_min.exports.optWhitespace).atMost(1), q.clause.trim(parsimmon_umd_min.exports.optWhitespace).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var getAPI5 = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI5;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  AssessModal: () => AssessModal,
  BaseModal: () => BaseModal,
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// Exercise.ts
var import_obsidian = require("obsidian");
var Exercise = class {
  constructor(app, exerciseInfo) {
    this.remark = "";
    Object.assign(this, exerciseInfo);
    this.app_ = app;
    this.history = (exerciseInfo == null ? void 0 : exerciseInfo.history) || [];
  }
  static extractIdFromLink(el) {
    const match = el.match(/\^\s*(\S*)/);
    return (match == null ? void 0 : match[1]) || "";
  }
  start() {
    this.start_time = (0, import_obsidian.moment)().valueOf();
    this.app_.workspace.openLinkText(this.source, this.source, true);
  }
  close() {
    this.end_time = (0, import_obsidian.moment)().valueOf();
    this.history.push({
      startTimeStamp: this.start_time,
      endTimeStamp: this.end_time,
      status: this.state,
      remark: this.remark
    });
  }
  getStartTime() {
    return (0, import_obsidian.moment)(this.start_time);
  }
  getEndTime() {
    return (0, import_obsidian.moment)(this.end_time);
  }
  getDurationAsString() {
    const dur = import_obsidian.moment.duration(this.getEndTime().diff(this.getStartTime()));
    const hours = Math.floor(dur.asHours());
    const minutes = dur.minutes();
    const seconds = dur.seconds();
    return `
	- ${hours} hours
	- ${minutes} mins
	- ${seconds} seconds`;
  }
  getDurationInSeconds() {
    const dur = import_obsidian.moment.duration(this.getEndTime().diff(this.getStartTime()));
    return dur.asSeconds();
  }
  setStatus(status) {
    this.state = status;
  }
  setRemark(remark) {
    this.remark = remark;
  }
  getWikiLink() {
    return `[[${this.source}]]`;
  }
  static fromJSON(app, data) {
    return new Exercise(app, data);
  }
  toJSON() {
    return {
      source: this.source,
      id: this.id,
      subject: this.subject,
      index: this.index,
      state: this.state,
      start_time: this.start_time,
      end_time: this.end_time,
      remark: this.remark,
      history: this.history
    };
  }
};

// ExerciseBase.ts
var import_obsidian_dataview = __toESM(require_lib());
var import_obsidian4 = require("obsidian");

// Excalidraw.ts
var import_obsidian3 = require("obsidian");

// GenericFile.ts
var import_obsidian2 = require("obsidian");
var GenericFile = class {
  constructor(app, path) {
    this.app_ = app;
    this.path = (0, import_obsidian2.normalizePath)(path);
  }
  async read(file) {
    const path = file ? file.path : this.path;
    if (path) {
      const file2 = this.app_.metadataCache.getFirstLinkpathDest(path, path);
      if (file2)
        return await this.app_.vault.read(file2);
    }
    return "";
  }
};

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/utility/parser.ts
function parseJSON(content) {
  const jsonPattern = /```json\n([\s\S]*?)\n```/g;
  const match = jsonPattern.exec(content);
  return match && match[1] ? JSON.parse(match[1]) : null;
}
function getExerciseLinkText(excalidraw) {
  let elements = excalidraw.elements;
  return elements.filter((el) => el.strokeColor === EXERCISE_BOX.strokeColor && el.type === EXERCISE_BOX.type && !el.isDeleted).map((el) => `${excalidraw.name}#^${el.id}`);
}
function toYaml(obj, excluded_key = "_") {
  const sanitizedObject = Object.fromEntries(
    Object.entries(obj).filter(([key]) => !key.endsWith(excluded_key))
  );
  return `---
${dump(sanitizedObject)}---`;
}
function parseFrontmatter(content) {
  const pattern = /---\s*([\s\S]*?)\s*---/;
  const matches = pattern.exec(content);
  if (matches && matches[1]) {
    try {
      return load(matches[1]);
    } catch (e) {
      console.error("Error parsing YAML:", e);
      return void 0;
    }
  }
  return void 0;
}

// Excalidraw.ts
var EXERCISE_BOX = {
  strokeColor: "#846358",
  type: "rectangle"
};
var ExcalidrawFile2 = class extends GenericFile {
  constructor(app, name, excalidrawFileInfo) {
    super(app, excalidrawFileInfo.path);
    this.name = name;
    Object.assign(this, excalidrawFileInfo);
  }
  // 现在读取Excalidraw文件的目的只是读取其内部的Excalidraw Elements
  static async read(app, path) {
    const content = await app.vault.adapter.read((0, import_obsidian3.normalizePath)(path));
    const parsedJSONBlock = parseJSON(content);
    return parsedJSONBlock.elements;
  }
  filterForNewExercise() {
    return Array.from(this.exerciseArray).filter((ex) => !this.previeousExerciseArray.has(ex));
  }
  filterForDeletedExercise() {
    return Array.from(this.previeousExerciseArray).filter((ex) => !this.exerciseArray.has(ex));
  }
  get exerciseArray() {
    return new Set(getExerciseLinkText(this));
  }
};

// src/exercise_version.ts
function migrate_mapping(oj, index) {
  return {
    source: oj["link"],
    subject: oj["type"],
    state: oj["lastStatus"],
    remark: oj["lastRemark"],
    index,
    history: oj["lifeline"],
    id: oj["id"],
    start_time: 0,
    end_time: 0
  };
}

// src/constants.ts
var EXERCISE_SUBJECT = /* @__PURE__ */ ((EXERCISE_SUBJECT2) => {
  EXERCISE_SUBJECT2["MATH"] = "Math";
  EXERCISE_SUBJECT2["DSP"] = "DSP";
  EXERCISE_SUBJECT2["POLITICS"] = "Politics";
  return EXERCISE_SUBJECT2;
})(EXERCISE_SUBJECT || {});
var EXERCISE_STATUSES_SWAPPED = /* @__PURE__ */ ((EXERCISE_STATUSES_SWAPPED2) => {
  EXERCISE_STATUSES_SWAPPED2["new"] = "New";
  EXERCISE_STATUSES_SWAPPED2["inspiring"] = "Inspiring";
  EXERCISE_STATUSES_SWAPPED2["laser"] = "Laser";
  EXERCISE_STATUSES_SWAPPED2["stumble"] = "Stumble";
  EXERCISE_STATUSES_SWAPPED2["drifter"] = "Drifter";
  return EXERCISE_STATUSES_SWAPPED2;
})(EXERCISE_STATUSES_SWAPPED || {});

// ExerciseBase.ts
var EXERCISE_BASE = {
  ["Math" /* MATH */]: {
    path: (0, import_obsidian4.normalizePath)("Exercise Base - Math.md"),
    tag: "#excalidraw/math",
    subject: "Math",
    query_strategy: 0 /* NEW_EXERCISE_FIRST */
  },
  ["DSP" /* DSP */]: {
    path: (0, import_obsidian4.normalizePath)("Exercise Base - DSP.md"),
    tag: "#excalidraw/signals_and_systems",
    subject: "DSP",
    query_strategy: 0 /* NEW_EXERCISE_FIRST */
  },
  ["Politics" /* POLITICS */]: {
    path: (0, import_obsidian4.normalizePath)("Exercise Base - Politics.md"),
    tag: "#excalidraw/\u653F\u6CBB",
    subject: "Politics",
    query_strategy: 0 /* NEW_EXERCISE_FIRST */
  }
};
var ExerciseBase = class extends GenericFile {
  // exists: boolean;
  constructor(app, baseMetadata) {
    super(app, baseMetadata.path);
    this.dataViewAPI_ = (0, import_obsidian_dataview.getAPI)();
    this.query_strategy = 0 /* NEW_EXERCISE_FIRST */;
    this.excalidraws_ = {};
    this.exercises = [];
    this.dataViewAPI_ = (0, import_obsidian_dataview.getAPI)();
    Object.assign(this, baseMetadata);
  }
  async indexExcalidraw() {
    var _a;
    const targetExcalidrawPages = (_a = this.dataViewAPI_) == null ? void 0 : _a.pages(this.tag);
    for (let page of targetExcalidrawPages) {
      this.excalidraws_[page.file.name] = new ExcalidrawFile2(this.app_, page.file.name, {
        subject: this.subject,
        path: page.file.path,
        elements: await ExcalidrawFile2.read(this.app_, page.file.path)
      });
      this.excalidraws_[page.file.name].previeousExerciseArray = this.excalidraws_[page.file.name].exerciseArray;
    }
  }
  async initIndex() {
    await this.indexExcalidraw();
    const exerciseLinkArray = Object.values(this.excalidraws_).flatMap((excal) => getExerciseLinkText(excal));
    this.exercises.push(...exerciseLinkArray.map((el, index) => Exercise.fromJSON(this.app_, {
      source: el,
      subject: this.subject,
      state: "new" /* New */,
      remark: "",
      index,
      history: [],
      id: Exercise.extractIdFromLink(el),
      start_time: 0,
      end_time: 0
    })));
    this.size = this.exercises.length;
    this.items_completed = 0;
  }
  jsonify() {
    return `\`\`\`json
${JSON.stringify(this, (k, v) => {
      if (k.endsWith("_"))
        return void 0;
      return v;
    }, 4)}
\`\`\``;
  }
  async save() {
    const data = this.jsonify();
    await this.app_.vault.adapter.write(this.path, data);
  }
  static async read(app, path) {
    let baseJSON = parseJSON(await app.vault.adapter.read((0, import_obsidian4.normalizePath)(path)));
    return await ExerciseBase.fromJSON(app, baseJSON);
  }
  static async create(app, subject) {
    const base = new ExerciseBase(app, EXERCISE_BASE[subject]);
    await base.initIndex();
    await base.save();
    return base;
  }
  static async fromJSON(app, obj) {
    obj.exercises = obj.exercises.map((ex) => new Exercise(app, ex));
    let base = new ExerciseBase(app, obj);
    await base.indexExcalidraw();
    return base;
  }
  updateRuntimeBase(actionType, ct) {
    switch (actionType) {
      case "modify":
        if (ct instanceof Exercise) {
          this.exercises.splice(ct.index, 0, ct);
        }
        break;
      case "create":
        if (!(ct instanceof Exercise))
          this.exercises.push(...this.createNewExercise(ct));
        break;
      case "delete":
        if (Array.isArray(ct)) {
          for (let elt of ct) {
            this.exercises.forEach((ex, index) => {
              if (ex.source == elt)
                this.exercises.splice(index, 1);
            });
          }
        }
    }
    ;
    this.size = this.exercises.length;
    this.items_completed = this.calculateItemCompleted();
  }
  calculateItemCompleted() {
    let num = 0;
    this.exercises.forEach((ex) => ex.state == "laser" /* Laser */ ? num++ : -1);
    return num;
  }
  next() {
    let randomExerciseIndex = -1;
    if (this.query_strategy == 0 /* NEW_EXERCISE_FIRST */) {
      const newExercisesIndexes = this.exercises.map((ex) => ex.state == "new" /* New */ ? ex.index : -1).filter((index) => index !== -1);
      if (newExercisesIndexes.length === 0) {
        new import_obsidian4.Notice("No more new Exercises!");
        return;
      }
      randomExerciseIndex = newExercisesIndexes[Math.floor(Math.random() * newExercisesIndexes.length)];
      new import_obsidian4.Notice(`Exercise at ${randomExerciseIndex} is being pulled out.`, 3e3);
    }
    if (randomExerciseIndex != -1) {
      const nextExercise = this.exercises.splice(randomExerciseIndex, 1)[0];
      return nextExercise;
    }
  }
  static async migrateFromOBtoNB(app, data) {
    const ob = parseJSON(await app.vault.adapter.read((0, import_obsidian4.normalizePath)(data.path)));
    const newExercises = ob["exercises"].map((o, index) => migrate_mapping(o, index));
    return ExerciseBase.fromJSON(app, {
      exercises: newExercises.map((ex) => new Exercise(app, ex)),
      items_completed: 0,
      query_strategy: 0 /* NEW_EXERCISE_FIRST */,
      size: 0,
      tag: data.tag,
      subject: data.subject,
      path: data.path
    });
  }
  createNewExercise(exercisesLinkArray) {
    return exercisesLinkArray.map((link, index) => {
      return new Exercise(this.app_, {
        source: link,
        subject: this.subject,
        history: [],
        id: "",
        state: "new" /* New */,
        index: this.size + index,
        remark: "",
        start_time: 0,
        end_time: 0
      });
    });
  }
};

// main.ts
var import_obsidian_dataview4 = __toESM(require_lib());

// DataProcessor.ts
var import_obsidian6 = require("obsidian");
var import_obsidian_dataview3 = __toESM(require_lib());

// StatFile.ts
var import_obsidian5 = require("obsidian");
var import_obsidian_dataview2 = __toESM(require_lib());
var StatFile = class {
  constructor(app, dailydata) {
    this.dsp_averageTime = 0;
    this.dsp_exercises = 0;
    this.dsp_total_time = 0;
    this.math_averageTime = 0;
    this.math_exercises = 0;
    this.math_total_time = 0;
    this.politics_averageTime = 0;
    this.politics_exercises = 0;
    this.politics_total_time = 0;
    this.totoal_focus_time = 0;
    this.app_ = app;
    this.dv_ = (0, import_obsidian_dataview2.getAPI)();
    Object.assign(this, dailydata);
  }
  // stringify(): string
  static get path() {
    const date_string = (0, import_obsidian5.moment)().format("YYYY-MM-DD");
    return (0, import_obsidian5.normalizePath)(`\u{1F5D3}\uFE0FDaily notes/DF${date_string}.md`);
  }
  get path() {
    const date_string = (0, import_obsidian5.moment)().format("YYYY-MM-DD");
    return (0, import_obsidian5.normalizePath)(`\u{1F5D3}\uFE0FDaily notes/DF${date_string}.md`);
  }
  async save() {
    const content = toYaml(this, "_");
    await this.app_.vault.adapter.write((0, import_obsidian5.normalizePath)(this.path), content);
  }
  static fromFrontmatter(app, data) {
    return new StatFile(app, data);
  }
};

// DataProcessor.ts
var AVERAGE_TIME_KEY = "_averageTime";
var EXERCISES_KEY = "_exercises";
var TOTAL_TIME_KEY = "_total_time";
var DataProcessor = class {
  constructor(app, bases, statFile) {
    this.bases = {};
    this.app_ = app;
    this.bases = bases;
    this.statfile = statFile;
  }
  static async init(app) {
    const dvAPI = (0, import_obsidian_dataview3.getAPI)();
    let bases = {};
    for (let subject of Object.keys(EXERCISE_BASE)) {
      const exists2 = await app.vault.adapter.exists(EXERCISE_BASE[subject].path);
      bases[subject] = exists2 ? await ExerciseBase.read(app, EXERCISE_BASE[subject].path) : await ExerciseBase.create(app, subject);
    }
    const statFilePath = StatFile.path;
    const exists = await app.vault.adapter.exists(statFilePath);
    let statFile;
    if (exists) {
      const dayFrontmatter = parseFrontmatter(await app.vault.adapter.read((0, import_obsidian6.normalizePath)(statFilePath)));
      statFile = StatFile.fromFrontmatter(app, dayFrontmatter);
    } else {
      statFile = new StatFile(app);
      await statFile.save();
    }
    return new DataProcessor(app, bases, statFile);
  }
  getFieldValue(keySuffix) {
    var _a;
    return this.statfile[`${(_a = this.activeBase) == null ? void 0 : _a["subject"].toLowerCase()}${keySuffix}`];
  }
  async updateField(keySuffix, value) {
    var _a;
    this.statfile[`${(_a = this.activeBase) == null ? void 0 : _a["subject"].toLowerCase()}${keySuffix}`] = value;
  }
  async increaseExerciseCount() {
    let noe = this.getFieldValue(EXERCISES_KEY);
    this.updateField(EXERCISES_KEY, ++noe);
  }
  // This function calculates the average time spent on each exercise
  async calculateAverageTimePerExercise(seconds) {
    const noe = this.getFieldValue(EXERCISES_KEY);
    let fv = this.getFieldValue(AVERAGE_TIME_KEY);
    this.updateField(AVERAGE_TIME_KEY, (fv * noe + seconds) / (noe + 1));
    this.calculateTimeSpentOnSubjectForTheDay();
  }
  // This functions accumulates the number of exercises that has done so far
  accumulateExerciseCountForSubject() {
  }
  // This function calculates the time spent on a particular particular subject
  async calculateTimeSpentOnSubjectForTheDay() {
    const noe = this.getFieldValue(EXERCISES_KEY);
    const avgTime = this.getFieldValue(AVERAGE_TIME_KEY);
    this.updateField(TOTAL_TIME_KEY, noe * avgTime);
  }
  async run() {
    var _a, _b;
    this.activeExercise = (_a = this.activeBase) == null ? void 0 : _a.next();
    (_b = this.activeExercise) == null ? void 0 : _b.start();
  }
  async closeUpCurrentExercise(early = false) {
    var _a, _b, _c, _d;
    if (this.activeExercise) {
      if (early) {
        this.activeExercise.start_time = 0;
        (_a = this.activeBase) == null ? void 0 : _a.updateRuntimeBase("modify", this.activeExercise);
        await ((_b = this.activeBase) == null ? void 0 : _b.save());
      } else {
        this.activeExercise.close();
        await this.calculateAverageTimePerExercise(this.activeExercise.getDurationInSeconds());
        await this.increaseExerciseCount();
        await this.calculateTimeSpentOnSubjectForTheDay();
        (_c = this.activeBase) == null ? void 0 : _c.updateRuntimeBase("modify", this.activeExercise);
        await ((_d = this.activeBase) == null ? void 0 : _d.save());
        await this.statfile.save();
        new import_obsidian6.Notice(`Start Time: ${this.activeExercise.getStartTime().format("ddd MMM D HH:mm:ss")}

End Time: ${this.activeExercise.getEndTime().format("ddd MMM D HH:mm:ss")}

Duration: ${this.activeExercise.getDurationAsString()}`, 1e4);
      }
    }
    this.activeExercise = void 0;
  }
};

// main.ts
var MyPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.dataviewAPI = (0, import_obsidian_dataview4.getAPI)(this.app);
  }
  async onload() {
    this.cpu = await DataProcessor.init(this.app);
    this.baseModal = new BaseModal(this.app, this.cpu);
    this.onExFileChangeRef = this.app.vault.on("modify", this.onExcalidrawFileChange, this);
    this.addCommand({
      id: "switch-base",
      name: "Switch Base",
      callback: () => {
        this.baseModal.open();
      }
    });
    this.addCommand({
      id: "close-base",
      name: "Close Base",
      callback: () => {
        this.cpu.activeBase = void 0;
      }
    });
    this.registerDomEvent(document, "keydown", (ev) => {
      if (ev.ctrlKey && ev.shiftKey && ev.key == "A") {
        if (!this.cpu.activeBase) {
          new import_obsidian7.Notice("No Base is selected!");
          this.baseModal.open();
        } else {
          if (this.cpu.activeExercise) {
            new import_obsidian7.Notice("An active exercise is running!");
          } else {
            this.cpu.run();
          }
        }
      }
    });
    this.registerDomEvent(document, "keydown", (ev) => {
      if (ev.ctrlKey && ev.shiftKey && ev.key == "S") {
        if (!this.cpu.activeExercise)
          new import_obsidian7.Notice("Currently, No Exercise is active!");
        else {
          new AssessModal(this.app, this.cpu).open();
          new import_obsidian7.Notice("Successfully closed the active exercise");
        }
      }
    });
  }
  async onExcalidrawFileChange(file) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(file.path, file.path);
    const fileName = (tFile == null ? void 0 : tFile.basename) ? tFile == null ? void 0 : tFile.basename : "";
    new import_obsidian7.Notice("picking out changed excalidraw file", 3e3);
    const excalidrawFile = this.cpu.bases["Math" /* MATH */].excalidraws_[fileName] || this.cpu.bases["DSP" /* DSP */].excalidraws_[fileName] || this.cpu.bases["Politics" /* POLITICS */].excalidraws_[fileName];
    new import_obsidian7.Notice(`${file.name} Changed!`, 3e3);
    if (excalidrawFile) {
      const subject = excalidrawFile.subject;
      excalidrawFile.elements = await ExcalidrawFile2.read(this.app, excalidrawFile.path);
      new import_obsidian7.Notice(`Previous number of exercises in excalidrawFile file: ${excalidrawFile.previeousExerciseArray.size}

Current number of exercises in excalidrawFile file: ${excalidrawFile.exerciseArray.size}`, 2e3);
      const newLTArray = excalidrawFile.filterForNewExercise();
      const deletedLTArray = excalidrawFile.filterForDeletedExercise();
      if (newLTArray.length > 0 || deletedLTArray.length > 0) {
        this.cpu.bases[subject].updateRuntimeBase("delete", deletedLTArray);
        this.cpu.bases[subject].updateRuntimeBase("create", newLTArray);
        await this.cpu.bases[subject].save();
        excalidrawFile.previeousExerciseArray = new Set(excalidrawFile.exerciseArray);
      }
    }
  }
  onunload() {
    this.app.vault.offref(this.onExFileChangeRef);
  }
  async update() {
    for (let subject of Object.keys(EXERCISE_BASE)) {
      let n = 0;
      const nb = await ExerciseBase.migrateFromOBtoNB(this.app, EXERCISE_BASE[subject]);
      nb.size = nb.exercises.length;
      nb.exercises.forEach((ex) => {
        ex.state === "laser" /* Laser */ ? n++ : -1;
      });
      nb.items_completed = n;
      await nb.save();
    }
  }
  // async loadSettings() {
  // 	this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  // }
  //
  // async saveSettings() {
  // 	await this.saveData(this.settings);
  // }
};
var AssessModal = class extends import_obsidian7.Modal {
  constructor(app, cpu) {
    super(app);
    this.cpu = cpu;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: "Assess" });
    new import_obsidian7.Setting(this.contentEl).addDropdown((dp) => {
      dp.addOptions(EXERCISE_STATUSES_SWAPPED);
      this.status = dp.getValue();
      dp.onChange((v) => {
        this.status = v;
      });
    });
    new import_obsidian7.Setting(this.contentEl).setName("Exercise Summary").setDesc("You can write down your brilliant ideas about this exercise").addTextArea((ta) => {
      ta.onChange((v) => {
        this.remark = v;
      });
    });
    new import_obsidian7.Setting(this.contentEl).addButton((bt) => {
      bt.setButtonText("Confirm").setCta().onClick(() => {
        var _a, _b;
        if (this.cpu.activeExercise) {
          (_a = this.cpu.activeExercise) == null ? void 0 : _a.setStatus(this.status);
          (_b = this.cpu.activeExercise) == null ? void 0 : _b.setRemark(this.remark);
          this.cpu.closeUpCurrentExercise();
          this.close();
        }
      });
    });
    new import_obsidian7.Setting(this.contentEl).addButton((bt) => {
      bt.setButtonText("Quit Exercise Without Saving").setCta().onClick(() => {
        this.cpu.closeUpCurrentExercise(true);
        this.close();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var BaseModal = class extends import_obsidian7.Modal {
  constructor(app, cpu) {
    super(app);
    this.cpu = cpu;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: "Exercise Base Selection" });
    new import_obsidian7.Setting(this.contentEl).addDropdown((dp) => {
      this.cv = dp.addOptions(Object.values(EXERCISE_SUBJECT).reduce(
        (acc, item) => {
          acc[item] = item;
          return acc;
        },
        {}
      )).getValue();
      dp.onChange((v) => {
        this.cv = v;
      });
    });
    new import_obsidian7.Setting(this.contentEl).addButton((bt) => {
      bt.setCta().setButtonText("Confirm").onClick(() => {
        this.cpu.activeBase = this.cpu.bases[this.cv];
        this.close();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9zZXR0aW5ncy50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2FwaS9yZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9wYXJzaW1tb24vYnVpbGQvcGFyc2ltbW9uLnVtZC5taW4uanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9lbW9qaS1yZWdleC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL3V0aWwvbm9ybWFsaXplLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvZGF0YS1tb2RlbC92YWx1ZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2V4cHJlc3Npb24vZmllbGQudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9kYXRhLWluZGV4L3NvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2V4cHJlc3Npb24vcGFyc2UudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9xdWVyeS9xdWVyeS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL3F1ZXJ5L3BhcnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvaW5kZXgudHMiLCAibWFpbi50cyIsICJFeGVyY2lzZS50cyIsICJFeGVyY2lzZUJhc2UudHMiLCAiRXhjYWxpZHJhdy50cyIsICJHZW5lcmljRmlsZS50cyIsICJub2RlX21vZHVsZXMvanMteWFtbC9kaXN0L2pzLXlhbWwubWpzIiwgInNyYy91dGlsaXR5L3BhcnNlci50cyIsICJzcmMvZXhlcmNpc2VfdmVyc2lvbi50cyIsICJzcmMvY29uc3RhbnRzLnRzIiwgIkRhdGFQcm9jZXNzb3IudHMiLCAiU3RhdEZpbGUudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIHRoZXNlIGFyZW4ndCByZWFsbHkgcHJpdmF0ZSwgYnV0IG5vciBhcmUgdGhleSByZWFsbHkgdXNlZnVsIHRvIGRvY3VtZW50XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTHV4b25FcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREYXRlVGltZUVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIERhdGVUaW1lOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW50ZXJ2YWxFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBJbnRlcnZhbDogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZER1cmF0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRHVyYXRpb246ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5pdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHVuaXQpIHtcbiAgICBzdXBlcihgSW52YWxpZCB1bml0ICR7dW5pdH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgWm9uZUlzQWJzdHJhY3RFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlpvbmUgaXMgYW4gYWJzdHJhY3QgY2xhc3NcIik7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgbiA9IFwibnVtZXJpY1wiLFxuICBzID0gXCJzaG9ydFwiLFxuICBsID0gXCJsb25nXCI7XG5cbmV4cG9ydCBjb25zdCBEQVRFX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG4iLCAiaW1wb3J0IHsgWm9uZUlzQWJzdHJhY3RFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9uZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbG9jYWwgem9uZVxuICAgKiBAcmV0dXJuIHtTeXN0ZW1ab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgU3lzdGVtWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBvYmpUb0xvY2FsVFMgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgZHRmQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZSkge1xuICBpZiAoIWR0ZkNhY2hlW3pvbmVdKSB7XG4gICAgZHRmQ2FjaGVbem9uZV0gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBlcmE6IFwic2hvcnRcIixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZHRmQ2FjaGVbem9uZV07XG59XG5cbmNvbnN0IHR5cGVUb1BvcyA9IHtcbiAgeWVhcjogMCxcbiAgbW9udGg6IDEsXG4gIGRheTogMixcbiAgZXJhOiAzLFxuICBob3VyOiA0LFxuICBtaW51dGU6IDUsXG4gIHNlY29uZDogNixcbn07XG5cbmZ1bmN0aW9uIGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1xcdTIwMEUvZywgXCJcIiksXG4gICAgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSAoQUR8QkMpLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKSxcbiAgICBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWQ7XG4gIHJldHVybiBbZlllYXIsIGZNb250aCwgZkRheSwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdO1xufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGZpbGxlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IGZvcm1hdHRlZFtpXTtcbiAgICBjb25zdCBwb3MgPSB0eXBlVG9Qb3NbdHlwZV07XG5cbiAgICBpZiAodHlwZSA9PT0gXCJlcmFcIikge1xuICAgICAgZmlsbGVkW3Bvc10gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbmxldCBpYW5hWm9uZUNhY2hlID0ge307XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUFOQVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgaWYgKCFpYW5hWm9uZUNhY2hlW25hbWVdKSB7XG4gICAgICBpYW5hWm9uZUNhY2hlW25hbWVdID0gbmV3IElBTkFab25lKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaWFuYVpvbmVDYWNoZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBsb2NhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUgPSB7fTtcbiAgICBkdGZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZSBmb3Igc29tZSB2YWxpZCBJQU5BIG5hbWVzLiBVc2UgaXNWYWxpZFpvbmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkWm9uZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpO1xuICAgIGxldCBbeWVhciwgbW9udGgsIGRheSwgYWRPckJjLCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBkdGYuZm9ybWF0VG9QYXJ0c1xuICAgICAgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpXG4gICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICBpZiAoYWRPckJjID09PSBcIkJDXCIpIHtcbiAgICAgIHllYXIgPSAtTWF0aC5hYnMoeWVhcikgKyAxO1xuICAgIH1cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgdXNpbmcgaG91cjEyIGFuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDI1NTY0JmNhbj0yJnE9JTIyMjQlM0EwMCUyMiUyMGRhdGV0aW1lZm9ybWF0XG4gICAgY29uc3QgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIGNvbnN0IGFzVVRDID0gb2JqVG9Mb2NhbFRTKHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXI6IGFkanVzdGVkSG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IGFzVFMgPSArZGF0ZTtcbiAgICBjb25zdCBvdmVyID0gYXNUUyAlIDEwMDA7XG4gICAgYXNUUyAtPSBvdmVyID49IDAgPyBvdmVyIDogMTAwMCArIG92ZXI7XG4gICAgcmV0dXJuIChhc1VUQyAtIGFzVFMpIC8gKDYwICogMTAwMCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImlhbmFcIiAmJiBvdGhlclpvbmUubmFtZSA9PT0gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsRFRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsTnVtQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgaW50bFJlbENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlU3RyKSB7XG4gIC8vIEkgcmVhbGx5IHdhbnQgdG8gYXZvaWQgd3JpdGluZyBhIEJDUCA0NyBwYXJzZXJcbiAgLy8gc2VlLCBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vYmNwLTQ3XG4gIC8vIEluc3RlYWQsIHdlJ2xsIGRvIHRoaXM6XG5cbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG5cbiAgLy8gcHJpdmF0ZSBzdWJ0YWdzIGFuZCB1bmljb2RlIHN1YnRhZ3MgaGF2ZSBvcmRlcmluZyByZXF1aXJlbWVudHMsXG4gIC8vIGFuZCB3ZSdyZSBub3QgcHJvcGVybHkgcGFyc2luZyB0aGlzLCBzbyBqdXN0IHN0cmlwIG91dCB0aGVcbiAgLy8gcHJpdmF0ZSBvbmVzIGlmIHRoZXkgZXhpc3QuXG4gIGNvbnN0IHhJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXgtXCIpO1xuICBpZiAoeEluZGV4ICE9PSAtMSkge1xuICAgIGxvY2FsZVN0ciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgeEluZGV4KTtcbiAgfVxuXG4gIGNvbnN0IHVJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXUtXCIpO1xuICBpZiAodUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBbbG9jYWxlU3RyXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgc2VsZWN0ZWRTdHI7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gbG9jYWxlU3RyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHVJbmRleCk7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBzbWFsbGVyO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gW3NlbGVjdGVkU3RyLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRsQ29uZmlnU3RyaW5nKGxvY2FsZVN0ciwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikge1xuICBpZiAob3V0cHV0Q2FsZW5kYXIgfHwgbnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgaWYgKCFsb2NhbGVTdHIuaW5jbHVkZXMoXCItdS1cIikpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBcIi11XCI7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1jYS0ke291dHB1dENhbGVuZGFyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IGAtbnUtJHtudW1iZXJpbmdTeXN0ZW19YDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGRlZmF1bHRPSywgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZShkZWZhdWx0T0spO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgICBsZXQgeiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZHQuem9uZS5pc1VuaXZlcnNhbCkge1xuICAgICAgLy8gVVRDLTggb3IgRXRjL1VUQy04IGFyZSBub3QgcGFydCBvZiB0emRhdGEsIG9ubHkgRXRjL0dNVCs4IGFuZCB0aGUgbGlrZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGZpeGVkLW9mZnNldCBUWiBpcyBzZXQgdG8gdGhhdCB1bmxlc3MgaXQgaXM6XG4gICAgICAvLyAxLiBSZXByZXNlbnRpbmcgb2Zmc2V0IDAgd2hlbiBVVEMgaXMgdXNlZCB0byBtYWludGFpbiBwcmV2aW91cyBiZWhhdmlvciBhbmQgZG9lcyBub3QgYmVjb21lIEdNVC5cbiAgICAgIC8vIDIuIFVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyOlxuICAgICAgLy8gICAgLSBzb21lIGRvIG5vdCBzdXBwb3J0IEV0Yy9cbiAgICAgIC8vICAgIC0gPCBFdGMvR01ULTE0LCA+IEV0Yy9HTVQrMTIsIGFuZCAzMC1taW51dGUgb3IgNDUtbWludXRlIG9mZnNldHMgYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YVxuICAgICAgY29uc3QgZ210T2Zmc2V0ID0gLTEgKiAoZHQub2Zmc2V0IC8gNjApO1xuICAgICAgY29uc3Qgb2Zmc2V0WiA9IGdtdE9mZnNldCA+PSAwID8gYEV0Yy9HTVQrJHtnbXRPZmZzZXR9YCA6IGBFdGMvR01UJHtnbXRPZmZzZXR9YDtcbiAgICAgIGlmIChkdC5vZmZzZXQgIT09IDAgJiYgSUFOQVpvbmUuY3JlYXRlKG9mZnNldFopLnZhbGlkKSB7XG4gICAgICAgIHogPSBvZmZzZXRaO1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYWxsIGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy8rNDozMCBhcmUgcHJlc2VudCBpbiB0emRhdGEuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gbWFrZSBkby4gVHdvIGNhc2VzOlxuICAgICAgICAvLyAxLiBUaGUgZm9ybWF0IG9wdGlvbnMgdGVsbCB1cyB0byBzaG93IHRoZSB6b25lLiBXZSBjYW4ndCBkbyB0aGF0LCBzbyB0aGUgYmVzdFxuICAgICAgICAvLyB3ZSBjYW4gZG8gaXMgZm9ybWF0IHRoZSBkYXRlIGluIFVUQy5cbiAgICAgICAgLy8gMi4gVGhlIGZvcm1hdCBvcHRpb25zIGRvbid0IHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gVGhlbiB3ZSBjYW4gYWRqdXN0IHRoZW1cbiAgICAgICAgLy8gdGhlIHRpbWUgYW5kIHRlbGwgdGhlIGZvcm1hdHRlciB0byBzaG93IGl0IHRvIHVzIGluIFVUQywgc28gdGhhdCB0aGUgdGltZSBpcyByaWdodFxuICAgICAgICAvLyBhbmQgdGhlIGJhZCB6b25lIGRvZXNuJ3Qgc2hvdyB1cC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIGlmIChvcHRzLnRpbWVab25lTmFtZSkge1xuICAgICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmR0ID0gZHQub2Zmc2V0ID09PSAwID8gZHQgOiBEYXRlVGltZS5mcm9tTWlsbGlzKGR0LnRzICsgZHQub2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGludGxPcHRzLnRpbWVab25lID0gaW50bE9wdHMudGltZVpvbmUgfHwgejtcbiAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICBmb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IHN0eWxlOiBcImxvbmdcIiwgLi4ub3B0cyB9O1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShvcHRzLmxvY2FsZSwgb3B0cy5udW1iZXJpbmdTeXN0ZW0sIG9wdHMub3V0cHV0Q2FsZW5kYXIsIG9wdHMuZGVmYXVsdFRvRU4pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuIHJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlID0ge307XG4gICAgaW50bE51bUNhY2hlID0ge307XG4gICAgaW50bFJlbENhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBudW1iZXJpbmcsIG91dHB1dENhbGVuZGFyLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICBhbHRzLmRlZmF1bHRUb0VOIHx8IGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlZGVmYXVsdFRvRU4oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IGZhbHNlIH0pO1xuICB9XG5cbiAgbW9udGhzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UsIGRlZmF1bHRPSyA9IHRydWUpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgZGVmYXVsdE9LLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMoKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSwgZGVmYXVsdE9LID0gdHJ1ZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBkZWZhdWx0T0ssIEVuZ2xpc2gud2Vla2RheXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXRcbiAgICAgICAgICA/IHsgd2Vla2RheTogbGVuZ3RoLCB5ZWFyOiBcIm51bWVyaWNcIiwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH1cbiAgICAgICAgICA6IHsgd2Vla2RheTogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwV2Vla2RheXMoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmlkaWVtcyhkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0T0ssXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoLCBkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgRW5nbGlzaC5lcmFzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0geyBlcmE6IGxlbmd0aCB9O1xuXG4gICAgICAvLyBUaGlzIGlzIHByb2JsZW1hdGljLiBEaWZmZXJlbnQgY2FsZW5kYXJzIGFyZSBnb2luZyB0byBkZWZpbmUgZXJhcyB0b3RhbGx5IGRpZmZlcmVudGx5LiBXaGF0IEkgbmVlZCBpcyB0aGUgbWluaW11bSBzZXQgb2YgZGF0ZXNcbiAgICAgIC8vIHRvIGRlZmluaXRlbHkgZW51bWVyYXRlIHRoZW0uXG4gICAgICBpZiAoIXRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLmVyYUNhY2hlW2xlbmd0aF0gPSBbRGF0ZVRpbWUudXRjKC00MCwgMSwgMSksIERhdGVUaW1lLnV0YygyMDE3LCAxLCAxKV0ubWFwKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZXJhXCIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVyYUNhY2hlW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBleHRyYWN0KGR0LCBpbnRsT3B0cywgZmllbGQpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzKSxcbiAgICAgIHJlc3VsdHMgPSBkZi5mb3JtYXRUb1BhcnRzKCksXG4gICAgICBtYXRjaGluZyA9IHJlc3VsdHMuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IGZpZWxkKTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBudW1iZXJGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIHJlbEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlSZWxGb3JtYXR0ZXIodGhpcy5pbnRsLCB0aGlzLmlzRW5nbGlzaCgpLCBvcHRzKTtcbiAgfVxuXG4gIGxpc3RGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldENhY2hlZExGKHRoaXMuaW50bCwgb3B0cyk7XG4gIH1cblxuICBpc0VuZ2xpc2goKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBcImVuXCIgfHxcbiAgICAgIHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW4tdXNcIiB8fFxuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUuc3RhcnRzV2l0aChcImVuLXVzXCIpXG4gICAgKTtcbiAgfVxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gb3RoZXIubG9jYWxlICYmXG4gICAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gb3RoZXIubnVtYmVyaW5nU3lzdGVtICYmXG4gICAgICB0aGlzLm91dHB1dENhbGVuZGFyID09PSBvdGhlci5vdXRwdXRDYWxlbmRhclxuICAgICk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHNpZ25lZE9mZnNldCB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIEEgem9uZSB3aXRoIGEgZml4ZWQgb2Zmc2V0IChtZWFuaW5nIG5vIERTVClcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZE9mZnNldFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBVVENcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCB1dGNJbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgRml4ZWRPZmZzZXRab25lKDApO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBpbiBtaW51dGVzXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZShvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlIDogbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBGaXhlZE9mZnNldFpvbmUgZnJvbSBhIFVUQyBvZmZzZXQgc3RyaW5nLCBsaWtlIFwiVVRDKzZcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBvZmZzZXQgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQys2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQyswNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMtNjowMFwiKVxuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VTcGVjaWZpZXIocykge1xuICAgIGlmIChzKSB7XG4gICAgICBjb25zdCByID0gcy5tYXRjaCgvXnV0Yyg/OihbKy1dXFxkezEsMn0pKD86OihcXGR7Mn0pKT8pPyQvaSk7XG4gICAgICBpZiAocikge1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkT2Zmc2V0Wm9uZShzaWduZWRPZmZzZXQoclsxXSwgclsyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuZml4ZWQgPSBvZmZzZXQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJmaXhlZFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQgPT09IDAgPyBcIlVUQ1wiIDogYFVUQyR7Zm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gIH1cblxuICBnZXQgaWFuYU5hbWUoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIkV0Yy9VVENcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBFdGMvR01UJHtmb3JtYXRPZmZzZXQoLXRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICBjb25zdCBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJkZWZhdWx0XCIpIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIFN5c3RlbVpvbmUuaW5zdGFuY2U7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIGVsc2UgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihsb3dlcmVkKSB8fCBJQU5BWm9uZS5jcmVhdGUoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBpbnB1dC5vZmZzZXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgIC8vIFRoaXMgaXMgZHVtYiwgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byByZWFsbHkgd29ya1xuICAgIC8vIHNvIHdlJ3JlIGR1Y2sgY2hlY2tpbmcgaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcblxuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxubGV0IG5vdyA9ICgpID0+IERhdGUubm93KCksXG4gIGRlZmF1bHRab25lID0gXCJzeXN0ZW1cIixcbiAgZGVmYXVsdExvY2FsZSA9IG51bGwsXG4gIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudWxsLFxuICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBudWxsLFxuICB0d29EaWdpdEN1dG9mZlllYXIgPSA2MCxcbiAgdGhyb3dPbkludmFsaWQ7XG5cbi8qKlxuICogU2V0dGluZ3MgY29udGFpbnMgc3RhdGljIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBjb250cm9sIEx1eG9uJ3Mgb3ZlcmFsbCBiZWhhdmlvci4gTHV4b24gaXMgYSBzaW1wbGUgbGlicmFyeSB3aXRoIGZldyBvcHRpb25zLCBidXQgdGhlIG9uZXMgaXQgZG9lcyBoYXZlIGxpdmUgaGVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3Mge1xuICAvKipcbiAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCBub3coKSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAqL1xuICBzdGF0aWMgc2V0IG5vdyhuKSB7XG4gICAgbm93ID0gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFVzZSB0aGUgdmFsdWUgXCJzeXN0ZW1cIiB0byByZXNldCB0aGlzIHZhbHVlIHRvIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRab25lKHpvbmUpIHtcbiAgICBkZWZhdWx0Wm9uZSA9IHpvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgY3VycmVudGx5IHVzZWQgdG8gY3JlYXRlIERhdGVUaW1lcy4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHN5c3RlbSdzIHRpbWUgem9uZSAodGhlIG9uZSBzZXQgb24gdGhlIG1hY2hpbmUgdGhhdCBydW5zIHRoaXMgY29kZSkuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0Wm9uZSgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplWm9uZShkZWZhdWx0Wm9uZSwgU3lzdGVtWm9uZS5pbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRMb2NhbGUobG9jYWxlKSB7XG4gICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1dG9mZiB5ZWFyIGFmdGVyIHdoaWNoIGEgc3RyaW5nIGVuY29kaW5nIGEgeWVhciBhcyB0d28gZGlnaXRzIGlzIGludGVycHJldGVkIHRvIG9jY3VyIGluIHRoZSBjdXJyZW50IGNlbnR1cnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcigpIHtcbiAgICByZXR1cm4gdHdvRGlnaXRDdXRvZmZZZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3V0b2ZmIHllYXIgYWZ0ZXIgd2hpY2ggYSBzdHJpbmcgZW5jb2RpbmcgYSB5ZWFyIGFzIHR3byBkaWdpdHMgaXMgaW50ZXJwcmV0ZWQgdG8gb2NjdXIgaW4gdGhlIGN1cnJlbnQgY2VudHVyeS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMCAvLyBjdXQtb2ZmIHllYXIgaXMgMCwgc28gYWxsICd5eScgYXJlIGludGVycHJldHRlZCBhcyBjdXJyZW50IGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gNTAgLy8gJzQ5JyAtPiAxOTQ5OyAnNTAnIC0+IDIwNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMTk1MCAvLyBpbnRlcnByZXR0ZWQgYXMgNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMjA1MCAvLyBBTFNPIGludGVycHJldHRlZCBhcyA1MFxuICAgKi9cbiAgc3RhdGljIHNldCB0d29EaWdpdEN1dG9mZlllYXIoY3V0b2ZmWWVhcikge1xuICAgIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IGN1dG9mZlllYXIgJSAxMDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB0aHJvd09uSW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhyb3dPbkludmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB0aHJvd09uSW52YWxpZCh0KSB7XG4gICAgdGhyb3dPbkludmFsaWQgPSB0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IEx1eG9uJ3MgZ2xvYmFsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGVzKCkge1xuICAgIExvY2FsZS5yZXNldENhY2hlKCk7XG4gICAgSUFOQVpvbmUucmVzZXRDYWNoZSgpO1xuICB9XG59XG4iLCAiLypcbiAgVGhpcyBpcyBqdXN0IGEganVuayBkcmF3ZXIsIGNvbnRhaW5pbmcgYW55dGhpbmcgdXNlZCBhY3Jvc3MgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgQmVjYXVzZSBMdXhvbiBpcyBzbWFsbChpc2gpLCB0aGlzIHNob3VsZCBzdGF5IHNtYWxsIGFuZCB3ZSB3b24ndCB3b3JyeSBhYm91dCBzcGxpdHRpbmdcbiAgaXQgdXAgaW50bywgc2F5LCBwYXJzaW5nVXRpbC5qcyBhbmQgYmFzaWNVdGlsLmpzIGFuZCBzbyBvbi4gQnV0IHRoZXkgYXJlIGRpdmlkZWQgdXAgYnkgZmVhdHVyZSBhcmVhLlxuKi9cblxuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBUWVBFU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIiAmJiBvICUgMSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG59XG5cbi8vIENBUEFCSUxJVElFU1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVsYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmICEhSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gT0JKRUNUUyBBTkQgQVJSQVlTXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyLnJlZHVjZSgoYmVzdCwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuICAgIGlmICghYmVzdCkge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSBlbHNlIGlmIChjb21wYXJlKGJlc3RbMF0sIHBhaXJbMF0pID09PSBiZXN0WzBdKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfVxuICB9LCBudWxsKVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYSwgaykgPT4ge1xuICAgIGFba10gPSBvYmpba107XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbi8vIE5VTUJFUlMgQU5EIFNUUklOR1NcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJCZXR3ZWVuKHRoaW5nLCBib3R0b20sIHRvcCkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHRoaW5nKSAmJiB0aGluZyA+PSBib3R0b20gJiYgdGhpbmcgPD0gdG9wO1xufVxuXG4vLyB4ICUgbiBidXQgdGFrZXMgdGhlIHNpZ24gb2YgbiBpbnN0ZWFkIG9mIHhcbmV4cG9ydCBmdW5jdGlvbiBmbG9vck1vZCh4LCBuKSB7XG4gIHJldHVybiB4IC0gbiAqIE1hdGguZmxvb3IoeCAvIG4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RhcnQoaW5wdXQsIG4gPSAyKSB7XG4gIGNvbnN0IGlzTmVnID0gaW5wdXQgPCAwO1xuICBsZXQgcGFkZGVkO1xuICBpZiAoaXNOZWcpIHtcbiAgICBwYWRkZWQgPSBcIi1cIiArIChcIlwiICsgLWlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFkZGVkID0gKFwiXCIgKyBpbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9XG4gIHJldHVybiBwYWRkZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGbG9hdGluZyhzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNaWxsaXMoZnJhY3Rpb24pIHtcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCAoaW5zdGVhZCBvZiAwKSBpbiB0aGVzZSBjYXNlcywgd2hlcmUgZnJhY3Rpb24gaXMgbm90IHNldFxuICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb24pIHx8IGZyYWN0aW9uID09PSBudWxsIHx8IGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmID0gcGFyc2VGbG9hdChcIjAuXCIgKyBmcmFjdGlvbikgKiAxMDAwO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGYpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvKG51bWJlciwgZGlnaXRzLCB0b3dhcmRaZXJvID0gZmFsc2UpIHtcbiAgY29uc3QgZmFjdG9yID0gMTAgKiogZGlnaXRzLFxuICAgIHJvdW5kZXIgPSB0b3dhcmRaZXJvID8gTWF0aC50cnVuYyA6IE1hdGgucm91bmQ7XG4gIHJldHVybiByb3VuZGVyKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5cbi8vIERBVEUgQkFTSUNTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgY29uc3QgbW9kTW9udGggPSBmbG9vck1vZChtb250aCAtIDEsIDEyKSArIDEsXG4gICAgbW9kWWVhciA9IHllYXIgKyAobW9udGggLSBtb2RNb250aCkgLyAxMjtcblxuICBpZiAobW9kTW9udGggPT09IDIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcihtb2RZZWFyKSA/IDI5IDogMjg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFszMSwgbnVsbCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdW21vZE1vbnRoIC0gMV07XG4gIH1cbn1cblxuLy8gY292ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgbG9jYWwgdGltZXN0YW1wIChlcG9jaCwgYnV0IHdpdGggdGhlIG9mZnNldCBiYWtlZCBpbilcbmV4cG9ydCBmdW5jdGlvbiBvYmpUb0xvY2FsVFMob2JqKSB7XG4gIGxldCBkID0gRGF0ZS5VVEMoXG4gICAgb2JqLnllYXIsXG4gICAgb2JqLm1vbnRoIC0gMSxcbiAgICBvYmouZGF5LFxuICAgIG9iai5ob3VyLFxuICAgIG9iai5taW51dGUsXG4gICAgb2JqLnNlY29uZCxcbiAgICBvYmoubWlsbGlzZWNvbmRcbiAgKTtcblxuICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMsIHllYXJzIGJldHdlZW4gMCBhbmQgOTkgYXJlIGludGVycHJldGVkIGFzIDE5WFg7IHJldmVydCB0aGF0XG4gIGlmIChvYmoueWVhciA8IDEwMCAmJiBvYmoueWVhciA+PSAwKSB7XG4gICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIGQuc2V0VVRDRnVsbFllYXIoZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCk7XG4gIH1cbiAgcmV0dXJuICtkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKSB7XG4gIGNvbnN0IHAxID1cbiAgICAgICh3ZWVrWWVhciArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0KSAtXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyAxMDApICtcbiAgICAgICAgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDQwMCkpICVcbiAgICAgIDcsXG4gICAgbGFzdCA9IHdlZWtZZWFyIC0gMSxcbiAgICBwMiA9IChsYXN0ICsgTWF0aC5mbG9vcihsYXN0IC8gNCkgLSBNYXRoLmZsb29yKGxhc3QgLyAxMDApICsgTWF0aC5mbG9vcihsYXN0IC8gNDAwKSkgJSA3O1xuICByZXR1cm4gcDEgPT09IDQgfHwgcDIgPT09IDMgPyA1MyA6IDUyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhcikge1xuICBpZiAoeWVhciA+IDk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSByZXR1cm4geWVhciA+IFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IHsgdGltZVpvbmVOYW1lOiBvZmZzZXRGb3JtYXQsIC4uLmludGxPcHRzIH07XG5cbiAgY29uc3QgcGFyc2VkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZClcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIik7XG4gIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xufVxuXG4vLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpIHtcbiAgbGV0IG9mZkhvdXIgPSBwYXJzZUludChvZmZIb3VyU3RyLCAxMCk7XG5cbiAgLy8gZG9uJ3QgfHwgdGhpcyBiZWNhdXNlIHdlIHdhbnQgdG8gcHJlc2VydmUgLTBcbiAgaWYgKE51bWJlci5pc05hTihvZmZIb3VyKSkge1xuICAgIG9mZkhvdXIgPSAwO1xuICB9XG5cbiAgY29uc3Qgb2ZmTWluID0gcGFyc2VJbnQob2ZmTWludXRlU3RyLCAxMCkgfHwgMCxcbiAgICBvZmZNaW5TaWduZWQgPSBvZmZIb3VyIDwgMCB8fCBPYmplY3QuaXMob2ZmSG91ciwgLTApID8gLW9mZk1pbiA6IG9mZk1pbjtcbiAgcmV0dXJuIG9mZkhvdXIgKiA2MCArIG9mZk1pblNpZ25lZDtcbn1cblxuLy8gQ09FUkNJT05cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBcIlwiIHx8IE51bWJlci5pc05hTihudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob2Zmc2V0LCBmb3JtYXQpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgbWludXRlcyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0ICUgNjApKSxcbiAgICBzaWduID0gb2Zmc2V0ID49IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7aG91cnN9JHttaW51dGVzID4gMCA/IGA6JHttaW51dGVzfWAgOiBcIlwifWA7XG4gICAgY2FzZSBcInRlY2hpZVwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgZm9ybWF0ICR7Zm9ybWF0fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHByb3BlcnR5IGZvcm1hdGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG4iLCAiaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIE9iamVjdC5rZXlzKG9iaikuc29ydCgpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjb25zdCBtb250aHNMb25nID0gW1xuICBcIkphbnVhcnlcIixcbiAgXCJGZWJydWFyeVwiLFxuICBcIk1hcmNoXCIsXG4gIFwiQXByaWxcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5lXCIsXG4gIFwiSnVseVwiLFxuICBcIkF1Z3VzdFwiLFxuICBcIlNlcHRlbWJlclwiLFxuICBcIk9jdG9iZXJcIixcbiAgXCJOb3ZlbWJlclwiLFxuICBcIkRlY2VtYmVyXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzU2hvcnQgPSBbXG4gIFwiSmFuXCIsXG4gIFwiRmViXCIsXG4gIFwiTWFyXCIsXG4gIFwiQXByXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuXCIsXG4gIFwiSnVsXCIsXG4gIFwiQXVnXCIsXG4gIFwiU2VwXCIsXG4gIFwiT2N0XCIsXG4gIFwiTm92XCIsXG4gIFwiRGVjXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzTmFycm93ID0gW1wiSlwiLCBcIkZcIiwgXCJNXCIsIFwiQVwiLCBcIk1cIiwgXCJKXCIsIFwiSlwiLCBcIkFcIiwgXCJTXCIsIFwiT1wiLCBcIk5cIiwgXCJEXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGNhc2UgXCIyLWRpZ2l0XCI6XG4gICAgICByZXR1cm4gW1wiMDFcIiwgXCIwMlwiLCBcIjAzXCIsIFwiMDRcIiwgXCIwNVwiLCBcIjA2XCIsIFwiMDdcIiwgXCIwOFwiLCBcIjA5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNMb25nID0gW1xuICBcIk1vbmRheVwiLFxuICBcIlR1ZXNkYXlcIixcbiAgXCJXZWRuZXNkYXlcIixcbiAgXCJUaHVyc2RheVwiLFxuICBcIkZyaWRheVwiLFxuICBcIlNhdHVyZGF5XCIsXG4gIFwiU3VuZGF5XCIsXG5dO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IFtcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTmFycm93ID0gW1wiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCIsIFwiU1wiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmlkaWVtcyA9IFtcIkFNXCIsIFwiUE1cIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTG9uZyA9IFtcIkJlZm9yZSBDaHJpc3RcIiwgXCJBbm5vIERvbWluaVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNTaG9ydCA9IFtcIkJDXCIsIFwiQURcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTmFycm93ID0gW1wiQlwiLCBcIkFcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc0xvbmddO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyaWRpZW1Gb3JEYXRlVGltZShkdCkge1xuICByZXR1cm4gbWVyaWRpZW1zW2R0LmhvdXIgPCAxMiA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiB3ZWVrZGF5cyhsZW5ndGgpW2R0LndlZWtkYXkgLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gbW9udGhzKGxlbmd0aClbZHQubW9udGggLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGVyYXMobGVuZ3RoKVtkdC55ZWFyIDwgMCA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgbnVtZXJpYyA9IFwiYWx3YXlzXCIsIG5hcnJvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IHVuaXRzID0ge1xuICAgIHllYXJzOiBbXCJ5ZWFyXCIsIFwieXIuXCJdLFxuICAgIHF1YXJ0ZXJzOiBbXCJxdWFydGVyXCIsIFwicXRyLlwiXSxcbiAgICBtb250aHM6IFtcIm1vbnRoXCIsIFwibW8uXCJdLFxuICAgIHdlZWtzOiBbXCJ3ZWVrXCIsIFwid2suXCJdLFxuICAgIGRheXM6IFtcImRheVwiLCBcImRheVwiLCBcImRheXNcIl0sXG4gICAgaG91cnM6IFtcImhvdXJcIiwgXCJoci5cIl0sXG4gICAgbWludXRlczogW1wibWludXRlXCIsIFwibWluLlwiXSxcbiAgICBzZWNvbmRzOiBbXCJzZWNvbmRcIiwgXCJzZWMuXCJdLFxuICB9O1xuXG4gIGNvbnN0IGxhc3RhYmxlID0gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXS5pbmRleE9mKHVuaXQpID09PSAtMTtcblxuICBpZiAobnVtZXJpYyA9PT0gXCJhdXRvXCIgJiYgbGFzdGFibGUpIHtcbiAgICBjb25zdCBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b21vcnJvd1wiIDogYG5leHQgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IGBsYXN0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b2RheVwiIDogYHRoaXMgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgZGVmYXVsdDogLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNJblBhc3QgPSBPYmplY3QuaXMoY291bnQsIC0wKSB8fCBjb3VudCA8IDAsXG4gICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgc2luZ3VsYXIgPSBmbXRWYWx1ZSA9PT0gMSxcbiAgICBsaWxVbml0cyA9IHVuaXRzW3VuaXRdLFxuICAgIGZtdFVuaXQgPSBuYXJyb3dcbiAgICAgID8gc2luZ3VsYXJcbiAgICAgICAgPyBsaWxVbml0c1sxXVxuICAgICAgICA6IGxpbFVuaXRzWzJdIHx8IGxpbFVuaXRzWzFdXG4gICAgICA6IHNpbmd1bGFyXG4gICAgICA/IHVuaXRzW3VuaXRdWzBdXG4gICAgICA6IHVuaXQ7XG4gIHJldHVybiBpc0luUGFzdCA/IGAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9IGFnb2AgOiBgaW4gJHtmbXRWYWx1ZX0gJHtmbXRVbml0fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJpbmcoa25vd25Gb3JtYXQpIHtcbiAgLy8gdGhlc2UgYWxsIGhhdmUgdGhlIG9mZnNldHMgcmVtb3ZlZCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZW1cbiAgLy8gd2l0aG91dCBhbGwgdGhlIGludGwgc3R1ZmYgdGhpcyBpcyBiYWNrZmlsbGluZ1xuICBjb25zdCBmaWx0ZXJlZCA9IHBpY2soa25vd25Gb3JtYXQsIFtcbiAgICAgIFwid2Vla2RheVwiLFxuICAgICAgXCJlcmFcIixcbiAgICAgIFwieWVhclwiLFxuICAgICAgXCJtb250aFwiLFxuICAgICAgXCJkYXlcIixcbiAgICAgIFwiaG91clwiLFxuICAgICAgXCJtaW51dGVcIixcbiAgICAgIFwic2Vjb25kXCIsXG4gICAgICBcInRpbWVab25lTmFtZVwiLFxuICAgICAgXCJob3VyQ3ljbGVcIixcbiAgICBdKSxcbiAgICBrZXkgPSBzdHJpbmdpZnkoZmlsdGVyZWQpLFxuICAgIGRhdGVUaW1lSHVnZSA9IFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9IVUdFKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiSEg6bW06c3NcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0UpOlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBkIExMTCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBhZFN0YXJ0IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlbnMoc3BsaXRzLCB0b2tlblRvU3RyaW5nKSB7XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBzcGxpdHMpIHtcbiAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgcyArPSB0b2tlbi52YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgKz0gdG9rZW5Ub1N0cmluZyh0b2tlbi52YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cblxuY29uc3QgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyA9IHtcbiAgRDogRm9ybWF0cy5EQVRFX1NIT1JULFxuICBERDogRm9ybWF0cy5EQVRFX01FRCxcbiAgREREOiBGb3JtYXRzLkRBVEVfRlVMTCxcbiAgRERERDogRm9ybWF0cy5EQVRFX0hVR0UsXG4gIHQ6IEZvcm1hdHMuVElNRV9TSU1QTEUsXG4gIHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTLFxuICB0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCxcbiAgdHR0dDogRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQsXG4gIFQ6IEZvcm1hdHMuVElNRV8yNF9TSU1QTEUsXG4gIFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTLFxuICBUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCxcbiAgVFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQsXG4gIGY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlQsXG4gIGZmOiBGb3JtYXRzLkRBVEVUSU1FX01FRCxcbiAgZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEwsXG4gIGZmZmY6IEZvcm1hdHMuREFURVRJTUVfSFVHRSxcbiAgRjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMsXG4gIEZGOiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMsXG4gIEZGRjogRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyxcbiAgRkZGRjogRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtYXR0ZXIge1xuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXR0ZXIobG9jYWxlLCBvcHRzKTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUZvcm1hdChmbXQpIHtcbiAgICBsZXQgY3VycmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50RnVsbCA9IFwiXCIsXG4gICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGZhbHNlLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBzdGF0aWMgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzW3Rva2VuXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG4gICAgY29uc3QgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWUoZHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lUGFydHMoZHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXRUb1BhcnRzKCk7XG4gIH1cblxuICBmb3JtYXRJbnRlcnZhbChpbnRlcnZhbCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmxvYy5kdEZvcm1hdHRlcihpbnRlcnZhbC5zdGFydCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmR0Zi5mb3JtYXRSYW5nZShpbnRlcnZhbC5zdGFydC50b0pTRGF0ZSgpLCBpbnRlcnZhbC5lbmQudG9KU0RhdGUoKSk7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoZHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxuXG4gIG51bShuLCBwID0gMCkge1xuICAgIC8vIHdlIGdldCBzb21lIHBlcmYgb3V0IG9mIGRvaW5nIHRoaXMgaGVyZSwgYW5ub3lpbmdseVxuICAgIGlmICh0aGlzLm9wdHMuZm9yY2VTaW1wbGUpIHtcbiAgICAgIHJldHVybiBwYWRTdGFydChuLCBwKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfTtcblxuICAgIGlmIChwID4gMCkge1xuICAgICAgb3B0cy5wYWRUbyA9IHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9jLm51bWJlckZvcm1hdHRlcihvcHRzKS5mb3JtYXQobik7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZtdCkge1xuICAgIGNvbnN0IGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgIHVzZURhdGVUaW1lRm9ybWF0dGVyID0gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgJiYgdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgIT09IFwiZ3JlZ29yeVwiLFxuICAgICAgc3RyaW5nID0gKG9wdHMsIGV4dHJhY3QpID0+IHRoaXMubG9jLmV4dHJhY3QoZHQsIG9wdHMsIGV4dHJhY3QpLFxuICAgICAgZm9ybWF0T2Zmc2V0ID0gKG9wdHMpID0+IHtcbiAgICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgICAgcmV0dXJuIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBtZXJpZGllbSA9ICgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tZXJpZGllbUZvckRhdGVUaW1lKGR0KVxuICAgICAgICAgIDogc3RyaW5nKHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9LCBcImRheXBlcmlvZFwiKSxcbiAgICAgIG1vbnRoID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhzdGFuZGFsb25lID8geyBtb250aDogbGVuZ3RoIH0gOiB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKSxcbiAgICAgIHdlZWtkYXkgPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoXG4gICAgICAgICAgICAgIHN0YW5kYWxvbmUgPyB7IHdlZWtkYXk6IGxlbmd0aCB9IDogeyB3ZWVrZGF5OiBsZW5ndGgsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9LFxuICAgICAgICAgICAgICBcIndlZWtkYXlcIlxuICAgICAgICAgICAgKSxcbiAgICAgIG1heWJlTWFjcm8gPSAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKTtcbiAgICAgICAgaWYgKGZvcm1hdE9wdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJhID0gKGxlbmd0aCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoID8gRW5nbGlzaC5lcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSA6IHN0cmluZyh7IGVyYTogbGVuZ3RoIH0sIFwiZXJhXCIpLFxuICAgICAgdG9rZW5Ub1N0cmluZyA9ICh0b2tlbikgPT4ge1xuICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cDovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lLTEvZGF0ZS10aW1lI1RPQy1TdGFuZGFsb25lLXZzLi1Gb3JtYXQtU3R5bGVzXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAvLyBtc1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQsIDIpO1xuICAgICAgICAgIC8vIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMCksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTAwKSk7XG4gICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlKTtcbiAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUsIDIpO1xuICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMik7XG4gICAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91cik7XG4gICAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciwgMik7XG4gICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzZcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwibmFycm93XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2OjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInNob3J0XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInRlY2hpZVwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRVNUXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJzaG9ydFwiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRWFzdGVybiBTdGFuZGFyZCBUaW1lXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJsb25nXCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIC8vIHpvbmVcbiAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZU5hbWU7XG4gICAgICAgICAgLy8gbWVyaWRpZW1zXG4gICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgIHJldHVybiBtZXJpZGllbSgpO1xuICAgICAgICAgIC8vIGRhdGVzXG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCJudW1lcmljXCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXkpO1xuICAgICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIjItZGlnaXRcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSwgMik7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDEsIGRvZXNuJ3Qgc2VlbSB0byB3b3JrXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyB5ZWFyc1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDIwMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKSA6IHRoaXMubnVtKGR0LnllYXIpO1xuICAgICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCIyLWRpZ2l0XCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDYpO1xuICAgICAgICAgIC8vIGVyYXNcbiAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBRFxuICAgICAgICAgICAgcmV0dXJuIGVyYShcInNob3J0XCIpO1xuICAgICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbm5vIERvbWluaVxuICAgICAgICAgICAgcmV0dXJuIGVyYShcImxvbmdcIik7XG4gICAgICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibmFycm93XCIpO1xuICAgICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCk7XG4gICAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyKTtcbiAgICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC50cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIHRva2VuVG9TdHJpbmcpO1xuICB9XG5cbiAgZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgY29uc3QgdG9rZW5Ub0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrXCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1cikgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5udW0obGlsZHVyLmdldChtYXBwZWQpLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCkpO1xuICB9XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZCB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gIH1cblxuICB0b01lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGFuYXRpb24pIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnJlYXNvbn06ICR7dGhpcy5leHBsYW5hdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgdW50cnVuY2F0ZVllYXIsXG4gIHNpZ25lZE9mZnNldCxcbiAgcGFyc2VJbnRlZ2VyLFxuICBwYXJzZU1pbGxpcyxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmNvbnN0IGlhbmFSZWdleCA9IC9bQS1aYS16XystXXsxLDI1Nn0oPzo6P1xcL1tBLVphLXowLTlfKy1dezEsMjU2fSg/OlxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcyguLi5yZWdleGVzKSB7XG4gIGNvbnN0IGZ1bGwgPSByZWdleGVzLnJlZHVjZSgoZiwgcikgPT4gZiArIHIuc291cmNlLCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChgXiR7ZnVsbH0kYCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKC4uLmV4dHJhY3RvcnMpIHtcbiAgcmV0dXJuIChtKSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFt7IC4uLm1lcmdlZFZhbHMsIC4uLnZhbCB9LCB6b25lIHx8IG1lcmdlZFpvbmUsIG5leHRdO1xuICAgICAgICB9LFxuICAgICAgICBbe30sIG51bGwsIDFdXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMsIC4uLnBhdHRlcm5zKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yIChjb25zdCBbcmVnZXgsIGV4dHJhY3Rvcl0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gcmVnZXguZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlUGFyc2UoLi4ua2V5cykge1xuICByZXR1cm4gKG1hdGNoLCBjdXJzb3IpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRba2V5c1tpXV0gPSBwYXJzZUludGVnZXIobWF0Y2hbY3Vyc29yICsgaV0pO1xuICAgIH1cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59XG5cbi8vIElTTyBhbmQgU1FMIHBhcnNpbmdcbmNvbnN0IG9mZnNldFJlZ2V4ID0gLyg/OihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLztcbmNvbnN0IGlzb0V4dGVuZGVkWm9uZSA9IGAoPzoke29mZnNldFJlZ2V4LnNvdXJjZX0/KD86XFxcXFsoJHtpYW5hUmVnZXguc291cmNlfSlcXFxcXSk/KT9gO1xuY29uc3QgaXNvVGltZUJhc2VSZWdleCA9IC8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Wy4sXShcXGR7MSwzMH0pKT8pPyk/LztcbmNvbnN0IGlzb1RpbWVSZWdleCA9IFJlZ0V4cChgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0ke2lzb0V4dGVuZGVkWm9uZX1gKTtcbmNvbnN0IGlzb1RpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86VCR7aXNvVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuY29uc3QgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy87XG5jb25zdCBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy87XG5jb25zdCBpc29PcmRpbmFsUmVnZXggPSAvKFxcZHs0fSktPyhcXGR7M30pLztcbmNvbnN0IGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIik7XG5jb25zdCBzcWxZbWRSZWdleCA9IC8oXFxkezR9KS0oXFxkXFxkKS0oXFxkXFxkKS87IC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbmNvbnN0IHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9ID8oPzoke29mZnNldFJlZ2V4LnNvdXJjZX18KCR7aWFuYVJlZ2V4LnNvdXJjZX0pKT9gXG4pO1xuY29uc3Qgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pWSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pVyk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pRCk/KD86VCg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUgpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsMjB9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbcywgeWVhclN0ciwgbW9udGhTdHIsIHdlZWtTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIG1pbGxpc2Vjb25kc1N0cl0gPVxuICAgIG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHllYXJTdHIpKSxcbiAgICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtb250aFN0cikpLFxuICAgICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhkYXlTdHIpKSxcbiAgICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGhvdXJTdHIpKSxcbiAgICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHNlY29uZFN0ciksIHNlY29uZFN0ciA9PT0gXCItMFwiKSxcbiAgICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSwgbmVnYXRpdmVTZWNvbmRzKSxcbiAgICB9LFxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwLFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogRW5nbGlzaC5tb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSArIDEsXG4gICAgZGF5OiBwYXJzZUludGVnZXIoZGF5U3RyKSxcbiAgICBob3VyOiBwYXJzZUludGVnZXIoaG91clN0ciksXG4gICAgbWludXRlOiBwYXJzZUludGVnZXIobWludXRlU3RyKSxcbiAgfTtcblxuICBpZiAoc2Vjb25kU3RyKSByZXN1bHQuc2Vjb25kID0gcGFyc2VJbnRlZ2VyKHNlY29uZFN0cik7XG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPVxuICAgICAgd2Vla2RheVN0ci5sZW5ndGggPiAzXG4gICAgICAgID8gRW5nbGlzaC53ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDFcbiAgICAgICAgOiBFbmdsaXNoLndlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSRkMgMjgyMi81MzIyXG5jb25zdCByZmMyODIyID1cbiAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgICAsXG4gICAgICB3ZWVrZGF5U3RyLFxuICAgICAgZGF5U3RyLFxuICAgICAgbW9udGhTdHIsXG4gICAgICB5ZWFyU3RyLFxuICAgICAgaG91clN0cixcbiAgICAgIG1pbnV0ZVN0cixcbiAgICAgIHNlY29uZFN0cixcbiAgICAgIG9ic09mZnNldCxcbiAgICAgIG1pbE9mZnNldCxcbiAgICAgIG9mZkhvdXJTdHIsXG4gICAgICBvZmZNaW51dGVTdHIsXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgcmZjODUwID1cbiAgICAvXihNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIGRheVN0ciwgbW9udGhTdHIsIHllYXJTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgeWVhclN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5jb25zdCBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvT3JkaW5hbFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPWW1kLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuLypcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzTnVtYmVyLFxuICBpc1VuZGVmaW5lZCxcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIER1cmF0aW9uXCI7XG5cbi8vIHVuaXQgY29udmVyc2lvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBsb3dPcmRlck1hdHJpeCA9IHtcbiAgICB3ZWVrczoge1xuICAgICAgZGF5czogNyxcbiAgICAgIGhvdXJzOiA3ICogMjQsXG4gICAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgZGF5czoge1xuICAgICAgaG91cnM6IDI0LFxuICAgICAgbWludXRlczogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGhvdXJzOiB7IG1pbnV0ZXM6IDYwLCBzZWNvbmRzOiA2MCAqIDYwLCBtaWxsaXNlY29uZHM6IDYwICogNjAgKiAxMDAwIH0sXG4gICAgbWludXRlczogeyBzZWNvbmRzOiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDEwMDAgfSxcbiAgICBzZWNvbmRzOiB7IG1pbGxpc2Vjb25kczogMTAwMCB9LFxuICB9LFxuICBjYXN1YWxNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiA1MixcbiAgICAgIGRheXM6IDM2NSxcbiAgICAgIGhvdXJzOiAzNjUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDM2NSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IDEzLFxuICAgICAgZGF5czogOTEsXG4gICAgICBob3VyczogOTEgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDkxICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiA0LFxuICAgICAgZGF5czogMzAsXG4gICAgICBob3VyczogMzAgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcblxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9LFxuICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgYWNjdXJhdGVNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA0LFxuICAgICAgaG91cnM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCkgLyA0LFxuICAgICAgbWludXRlczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjApIC8gNCxcbiAgICAgIHNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjApIC8gNCxcbiAgICAgIG1pbGxpc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIC8gNCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luTW9udGhBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH07XG5cbi8vIHVuaXRzIG9yZGVyZWQgYnkgc2l6ZVxuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1xuICBcInllYXJzXCIsXG4gIFwicXVhcnRlcnNcIixcbiAgXCJtb250aHNcIixcbiAgXCJ3ZWVrc1wiLFxuICBcImRheXNcIixcbiAgXCJob3Vyc1wiLFxuICBcIm1pbnV0ZXNcIixcbiAgXCJzZWNvbmRzXCIsXG4gIFwibWlsbGlzZWNvbmRzXCIsXG5dO1xuXG5jb25zdCByZXZlcnNlVW5pdHMgPSBvcmRlcmVkVW5pdHMuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMgXCJjcmVhdGUgYW5vdGhlciBpbnN0YW5jZSBqdXN0IGxpa2UgdGhpcyBvbmUsIGJ1dCB3aXRoIHRoZXNlIGNoYW5nZXNcIlxuZnVuY3Rpb24gY2xvbmUoZHVyLCBhbHRzLCBjbGVhciA9IGZhbHNlKSB7XG4gIC8vIGRlZXAgbWVyZ2UgZm9yIHZhbHNcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2YWx1ZXM6IGNsZWFyID8gYWx0cy52YWx1ZXMgOiB7IC4uLmR1ci52YWx1ZXMsIC4uLihhbHRzLnZhbHVlcyB8fCB7fSkgfSxcbiAgICBsb2M6IGR1ci5sb2MuY2xvbmUoYWx0cy5sb2MpLFxuICAgIGNvbnZlcnNpb25BY2N1cmFjeTogYWx0cy5jb252ZXJzaW9uQWNjdXJhY3kgfHwgZHVyLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICBtYXRyaXg6IGFsdHMubWF0cml4IHx8IGR1ci5tYXRyaXgsXG4gIH07XG4gIHJldHVybiBuZXcgRHVyYXRpb24oY29uZik7XG59XG5cbmZ1bmN0aW9uIGFudGlUcnVuYyhuKSB7XG4gIHJldHVybiBuIDwgMCA/IE1hdGguZmxvb3IobikgOiBNYXRoLmNlaWwobik7XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIGNvbnZlcnQobWF0cml4LCBmcm9tTWFwLCBmcm9tVW5pdCwgdG9NYXAsIHRvVW5pdCkge1xuICBjb25zdCBjb252ID0gbWF0cml4W3RvVW5pdF1bZnJvbVVuaXRdLFxuICAgIHJhdyA9IGZyb21NYXBbZnJvbVVuaXRdIC8gY29udixcbiAgICBzYW1lU2lnbiA9IE1hdGguc2lnbihyYXcpID09PSBNYXRoLnNpZ24odG9NYXBbdG9Vbml0XSksXG4gICAgLy8gb2ssIHNvIHRoaXMgaXMgd2lsZCwgYnV0IHNlZSB0aGUgbWF0cml4IGluIHRoZSB0ZXN0c1xuICAgIGFkZGVkID1cbiAgICAgICFzYW1lU2lnbiAmJiB0b01hcFt0b1VuaXRdICE9PSAwICYmIE1hdGguYWJzKHJhdykgPD0gMSA/IGFudGlUcnVuYyhyYXcpIDogTWF0aC50cnVuYyhyYXcpO1xuICB0b01hcFt0b1VuaXRdICs9IGFkZGVkO1xuICBmcm9tTWFwW2Zyb21Vbml0XSAtPSBhZGRlZCAqIGNvbnY7XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgcmV2ZXJzZVVuaXRzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29udmVydChtYXRyaXgsIHZhbHMsIHByZXZpb3VzLCB2YWxzLCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcbn1cblxuLy8gUmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHdpdGggYSB2YWx1ZSBvZiAwIGZyb20gYW4gb2JqZWN0XG5mdW5jdGlvbiByZW1vdmVaZXJvZXModmFscykge1xuICBjb25zdCBuZXdWYWxzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICBuZXdWYWxzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHM7XG59XG5cbi8qKlxuICogQSBEdXJhdGlvbiBvYmplY3QgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lLCBsaWtlIFwiMiBtb250aHNcIiBvciBcIjEgZGF5LCAxIGhvdXJcIi4gQ29uY2VwdHVhbGx5LCBpdCdzIGp1c3QgYSBtYXAgb2YgdW5pdHMgdG8gdGhlaXIgcXVhbnRpdGllcywgYWNjb21wYW5pZWQgYnkgc29tZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uIFRoZXkgY2FuIGJlIHVzZWQgb24gdGhlaXIgb3duIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgTHV4b24gdHlwZXM7IGZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c30gdG8gYWRkIGEgRHVyYXRpb24gb2JqZWN0IHRvIGEgRGF0ZVRpbWUsIHByb2R1Y2luZyBhbm90aGVyIERhdGVUaW1lLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gRHVyYXRpb246XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGEgRHVyYXRpb24sIHVzZSB7QGxpbmsgRHVyYXRpb24uZnJvbU1pbGxpc30sIHtAbGluayBEdXJhdGlvbi5mcm9tT2JqZWN0fSwgb3Ige0BsaW5rIER1cmF0aW9uLmZyb21JU099LlxuICogKiAqKlVuaXQgdmFsdWVzKiogU2VlIHRoZSB7QGxpbmsgRHVyYXRpb24jeWVhcnN9LCB7QGxpbmsgRHVyYXRpb24jbW9udGhzfSwge0BsaW5rIER1cmF0aW9uI3dlZWtzfSwge0BsaW5rIER1cmF0aW9uI2RheXN9LCB7QGxpbmsgRHVyYXRpb24jaG91cnN9LCB7QGxpbmsgRHVyYXRpb24jbWludXRlc30sIHtAbGluayBEdXJhdGlvbiNzZWNvbmRzfSwge0BsaW5rIER1cmF0aW9uI21pbGxpc2Vjb25kc30gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgIHtAbGluayBEdXJhdGlvbiNsb2NhbGV9IGFuZCB7QGxpbmsgRHVyYXRpb24jbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgbmV3IER1cmF0aW9ucyBvdXQgb2Ygb2xkIG9uZXMgdXNlIHtAbGluayBEdXJhdGlvbiNwbHVzfSwge0BsaW5rIER1cmF0aW9uI21pbnVzfSwge0BsaW5rIER1cmF0aW9uI25vcm1hbGl6ZX0sIHtAbGluayBEdXJhdGlvbiNzZXR9LCB7QGxpbmsgRHVyYXRpb24jcmVjb25maWd1cmV9LCB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30sIGFuZCB7QGxpbmsgRHVyYXRpb24jbmVnYXRlfS5cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBEdXJhdGlvbiBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBEdXJhdGlvbiNhc30sIHtAbGluayBEdXJhdGlvbiN0b0lTT30sIHtAbGluayBEdXJhdGlvbiN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgRHVyYXRpb24jdG9KU09OfVxuICpcbiAqIFRoZXJlJ3MgYXJlIG1vcmUgbWV0aG9kcyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgdmFsaWRpdHksIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVyYXRpb24ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY3VyYXRlID0gY29uZmlnLmNvbnZlcnNpb25BY2N1cmFjeSA9PT0gXCJsb25ndGVybVwiIHx8IGZhbHNlO1xuICAgIGxldCBtYXRyaXggPSBhY2N1cmF0ZSA/IGFjY3VyYXRlTWF0cml4IDogY2FzdWFsTWF0cml4O1xuXG4gICAgaWYgKGNvbmZpZy5tYXRyaXgpIHtcbiAgICAgIG1hdHJpeCA9IGNvbmZpZy5tYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBjb25maWcudmFsdWVzO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb252ZXJzaW9uQWNjdXJhY3kgPSBhY2N1cmF0ZSA/IFwibG9uZ3Rlcm1cIiA6IFwiY2FzdWFsXCI7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EdXJhdGlvbiA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIER1cmF0aW9uIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgb2YgbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKGNvdW50LCBvcHRzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IGNvdW50IH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiBJZiB0aGlzIG9iamVjdCBpcyBlbXB0eSB0aGVuIGEgemVybyBtaWxsaXNlY29uZHMgZHVyYXRpb24gaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoucXVhcnRlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3Vyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz1bXV0gLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY3VzdG9tIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYER1cmF0aW9uLmZyb21PYmplY3Q6IGFyZ3VtZW50IGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgZ290ICR7XG4gICAgICAgICAgb2JqID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygb2JqXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRHVyYXRpb24oe1xuICAgICAgdmFsdWVzOiBub3JtYWxpemVPYmplY3Qob2JqLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgICBjb252ZXJzaW9uQWNjdXJhY3k6IG9wdHMuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgICAgbWF0cml4OiBvcHRzLm1hdHJpeCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIER1cmF0aW9uTGlrZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBEdXJhdGlvbn0gZHVyYXRpb25MaWtlXG4gICAqIE9uZSBvZjpcbiAgICogLSBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogLSBudW1iZXIgcmVwcmVzZW50aW5nIG1pbGxpc2Vjb25kc1xuICAgKiAtIER1cmF0aW9uIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb25MaWtlKSB7XG4gICAgaWYgKGlzTnVtYmVyKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIGlmIChEdXJhdGlvbi5pc0R1cmF0aW9uKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBkdXJhdGlvbkxpa2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25MaWtlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBVbmtub3duIGR1cmF0aW9uIGFyZ3VtZW50ICR7ZHVyYXRpb25MaWtlfSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uTGlrZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDNZNk0xVzREVDEySDMwTTVTJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDMsIG1vbnRoczogNiwgd2Vla3M6IDEsIGRheXM6IDQsIGhvdXJzOiAxMiwgbWludXRlczogMzAsIHNlY29uZHM6IDUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQVDIzSCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyMyB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1A1WTNNJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDUsIG1vbnRoczogMyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09EdXJhdGlvbih0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSB0aW1lIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMToyMjozMy40NDQnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDIyLCBzZWNvbmRzOiAzMywgbWlsbGlzZWNvbmRzOiA0NDQgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnVDExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExMDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnVDExMDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPVGltZSh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT1RpbWVPbmx5KHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgZGF0ZXRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRHVyYXRpb25FcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICAgIHllYXI6IFwieWVhcnNcIixcbiAgICAgIHllYXJzOiBcInllYXJzXCIsXG4gICAgICBxdWFydGVyOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBxdWFydGVyczogXCJxdWFydGVyc1wiLFxuICAgICAgbW9udGg6IFwibW9udGhzXCIsXG4gICAgICBtb250aHM6IFwibW9udGhzXCIsXG4gICAgICB3ZWVrOiBcIndlZWtzXCIsXG4gICAgICB3ZWVrczogXCJ3ZWVrc1wiLFxuICAgICAgZGF5OiBcImRheXNcIixcbiAgICAgIGRheXM6IFwiZGF5c1wiLFxuICAgICAgaG91cjogXCJob3Vyc1wiLFxuICAgICAgaG91cnM6IFwiaG91cnNcIixcbiAgICAgIG1pbnV0ZTogXCJtaW51dGVzXCIsXG4gICAgICBtaW51dGVzOiBcIm1pbnV0ZXNcIixcbiAgICAgIHNlY29uZDogXCJzZWNvbmRzXCIsXG4gICAgICBzZWNvbmRzOiBcInNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgIH1bdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6IHVuaXRdO1xuXG4gICAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhIER1cmF0aW9uLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEdXJhdGlvbihvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkR1cmF0aW9uKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgIHRoZSBsb2NhbGUgb2YgYSBEdXJhdGlvbiwgc3VjaCAnZW4tR0InXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIER1cmF0aW9uLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIER1cmF0aW9uXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy4gWW91IG1heSB1c2UgdGhlc2UgdG9rZW5zOlxuICAgKiAqIGBTYCBmb3IgbWlsbGlzZWNvbmRzXG4gICAqICogYHNgIGZvciBzZWNvbmRzXG4gICAqICogYG1gIGZvciBtaW51dGVzXG4gICAqICogYGhgIGZvciBob3Vyc1xuICAgKiAqIGBkYCBmb3IgZGF5c1xuICAgKiAqIGB3YCBmb3Igd2Vla3NcbiAgICogKiBgTWAgZm9yIG1vbnRoc1xuICAgKiAqIGB5YCBmb3IgeWVhcnNcbiAgICogTm90ZXM6XG4gICAqICogQWRkIHBhZGRpbmcgYnkgcmVwZWF0aW5nIHRoZSB0b2tlbiwgZS5nLiBcInl5XCIgcGFkcyB0aGUgeWVhcnMgdG8gdHdvIGRpZ2l0cywgXCJoaGhoXCIgcGFkcyB0aGUgaG91cnMgb3V0IHRvIGZvdXIgZGlnaXRzXG4gICAqICogVG9rZW5zIGNhbiBiZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIHdpdGggc2luZ2xlIHF1b3Rlcy5cbiAgICogKiBUaGUgZHVyYXRpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHNldCBvZiB1bml0cyBpbiB0aGUgZm9ybWF0IHN0cmluZyB1c2luZyB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30gYW5kIHRoZSBEdXJhdGlvbnMncyBjb252ZXJzaW9uIGFjY3VyYWN5IHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5mbG9vcj10cnVlXSAtIGZsb29yIG51bWVyaWNhbCB2YWx1ZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwieSBkIHNcIikgLy89PiBcIjEgNiAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwieXkgZGQgc3NzXCIpIC8vPT4gXCIwMSAwNiAwMDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJNIFNcIikgLy89PiBcIjEyIDUxODQwMjAwMFwiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgLy8gcmV2ZXJzZS1jb21wYXQgc2luY2UgMS4yOyB3ZSBhbHdheXMgcm91bmQgZG93biBub3csIG5ldmVyIHVwLCBhbmQgd2UgZG8gaXQgYnkgZGVmYXVsdFxuICAgIGNvbnN0IGZtdE9wdHMgPSB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZmxvb3I6IG9wdHMucm91bmQgIT09IGZhbHNlICYmIG9wdHMuZmxvb3IgIT09IGZhbHNlLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLCBmbXRPcHRzKS5mb3JtYXREdXJhdGlvbkZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBEdXJhdGlvbiB3aXRoIGFsbCB1bml0cyBpbmNsdWRlZC5cbiAgICogVG8gbW9kaWZ5IGl0cyBiZWhhdmlvciB1c2UgdGhlIGBsaXN0U3R5bGVgIGFuZCBhbnkgSW50bC5OdW1iZXJGb3JtYXQgb3B0aW9uLCB0aG91Z2ggYHVuaXREaXNwbGF5YCBpcyBlc3BlY2lhbGx5IHJlbGV2YW50LlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvTnVtYmVyRm9ybWF0XG4gICAqIEBwYXJhbSBvcHRzIC0gT24gb3B0aW9uIG9iamVjdCB0byBvdmVycmlkZSB0aGUgZm9ybWF0dGluZy4gQWNjZXB0cyB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnQuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3RvciwgYXMgd2VsbCBhcyBgbGlzdFN0eWxlYC5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxLCBob3VyczogNSwgbWludXRlczogNiB9KVxuICAgKiBkdXIudG9IdW1hbigpIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgbGlzdFN0eWxlOiBcImxvbmdcIiB9KSAvLz0+ICcxIGRheSwgNSBob3VycywgYW5kIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyB1bml0RGlzcGxheTogXCJzaG9ydFwiIH0pIC8vPT4gJzEgZGF5LCA1IGhyLCA2IG1pbidcbiAgICogYGBgXG4gICAqL1xuICB0b0h1bWFuKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGwgPSBvcmRlcmVkVW5pdHNcbiAgICAgIC5tYXAoKHVuaXQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAgICAgLm51bWJlckZvcm1hdHRlcih7IHN0eWxlOiBcInVuaXRcIiwgdW5pdERpc3BsYXk6IFwibG9uZ1wiLCAuLi5vcHRzLCB1bml0OiB1bml0LnNsaWNlKDAsIC0xKSB9KVxuICAgICAgICAgIC5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChuKSA9PiBuKTtcblxuICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgLmxpc3RGb3JtYXR0ZXIoeyB0eXBlOiBcImNvbmp1bmN0aW9uXCIsIHN0eWxlOiBvcHRzLmxpc3RTdHlsZSB8fCBcIm5hcnJvd1wiLCAuLi5vcHRzIH0pXG4gICAgICAuZm9ybWF0KGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHsgLi4udGhpcy52YWx1ZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAzLCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1AzWVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDQsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDRNVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNSB9KS50b0lTTygpIC8vPT4gJ1A1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDUgfSkudG9JU08oKSAvLz0+ICdQVDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA2IH0pLnRvSVNPKCkgLy89PiAnUFQwLjAwNlMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKCkge1xuICAgIC8vIHdlIGNvdWxkIHVzZSB0aGUgZm9ybWF0dGVyLCBidXQgdGhpcyBpcyBhbiBlYXNpZXIgd2F5IHRvIGdldCB0aGUgbWluaW11bSBzdHJpbmdcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgcyA9IFwiUFwiO1xuICAgIGlmICh0aGlzLnllYXJzICE9PSAwKSBzICs9IHRoaXMueWVhcnMgKyBcIllcIjtcbiAgICBpZiAodGhpcy5tb250aHMgIT09IDAgfHwgdGhpcy5xdWFydGVycyAhPT0gMCkgcyArPSB0aGlzLm1vbnRocyArIHRoaXMucXVhcnRlcnMgKiAzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMud2Vla3MgIT09IDApIHMgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgIGlmICh0aGlzLmRheXMgIT09IDApIHMgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDAgfHwgdGhpcy5taW51dGVzICE9PSAwIHx8IHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIHMgKz0gXCJUXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDApIHMgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgIGlmICh0aGlzLm1pbnV0ZXMgIT09IDApIHMgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIC8vIHRoaXMgd2lsbCBoYW5kbGUgXCJmbG9hdGluZyBwb2ludCBtYWRuZXNzXCIgYnkgcmVtb3ZpbmcgZXh0cmEgZGVjaW1hbCBwbGFjZXNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU4ODAwNC9pcy1mbG9hdGluZy1wb2ludC1tYXRoLWJyb2tlblxuICAgICAgcyArPSByb3VuZFRvKHRoaXMuc2Vjb25kcyArIHRoaXMubWlsbGlzZWNvbmRzIC8gMTAwMCwgMykgKyBcIlNcIjtcbiAgICBpZiAocyA9PT0gXCJQXCIpIHMgKz0gXCJUMFNcIjtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiwgZm9ybWF0dGVkIGFzIGEgdGltZSBvZiBkYXkuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGR1cmF0aW9uIGlzIGludmFsaWQsIG5lZ2F0aXZlLCBvciBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoKSAvLz0+ICcxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDA6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTEwMDAwLjAwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IG1pbGxpcyA9IHRoaXMudG9NaWxsaXMoKTtcbiAgICBpZiAobWlsbGlzIDwgMCB8fCBtaWxsaXMgPj0gODY0MDAwMDApIHJldHVybiBudWxsO1xuXG4gICAgb3B0cyA9IHtcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzU2Vjb25kczogZmFsc2UsXG4gICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJleHRlbmRlZFwiLFxuICAgICAgLi4ub3B0cyxcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnNoaWZ0VG8oXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpO1xuXG4gICAgbGV0IGZtdCA9IG9wdHMuZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcImhobW1cIiA6IFwiaGg6bW1cIjtcblxuICAgIGlmICghb3B0cy5zdXBwcmVzc1NlY29uZHMgfHwgdmFsdWUuc2Vjb25kcyAhPT0gMCB8fCB2YWx1ZS5taWxsaXNlY29uZHMgIT09IDApIHtcbiAgICAgIGZtdCArPSBvcHRzLmZvcm1hdCA9PT0gXCJiYXNpY1wiID8gXCJzc1wiIDogXCI6c3NcIjtcbiAgICAgIGlmICghb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcyB8fCB2YWx1ZS5taWxsaXNlY29uZHMgIT09IDApIHtcbiAgICAgICAgZm10ICs9IFwiLlNTU1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdHIgPSB2YWx1ZS50b0Zvcm1hdChmbXQpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZVByZWZpeCkge1xuICAgICAgc3RyID0gXCJUXCIgKyBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXMoXCJtaWxsaXNlY29uZHNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3Vyc1wiID8geCAqIDIgOiB4KSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtYXBVbml0cyhmbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICByZXN1bHRba10gPSBhc051bWJlcihmbih0aGlzLnZhbHVlc1trXSwgaykpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ3llYXJzJykgLy89PiAyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdtb250aHMnKSAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ2RheXMnKSAvLz0+IDNcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1tEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyB5ZWFyczogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgaG91cnM6IDgsIG1pbnV0ZXM6IDMwIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG1peGVkID0geyAuLi50aGlzLnZhbHVlcywgLi4ubm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCkgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG1peGVkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSBhbmQvb3IgbnVtYmVyaW5nU3lzdGVtLiAgUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBkdXIucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjb252ZXJzaW9uQWNjdXJhY3ksIG1hdHJpeCB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pO1xuICAgIGNvbnN0IG9wdHMgPSB7IGxvYywgbWF0cml4LCBjb252ZXJzaW9uQWNjdXJhY3kgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzY2FsZSB1bml0cyB0byBpdHMgbGFyZ2VzdCByZXByZXNlbnRhdGlvblxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA5MDAwMCB9KS5yZXNjYWxlKCkudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogMSwgc2Vjb25kczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlc2NhbGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSByZW1vdmVaZXJvZXModGhpcy5ub3JtYWxpemUoKS5zaGlmdFRvQWxsKCkudG9PYmplY3QoKSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBEdXJhdGlvbiBpbnRvIGl0cyByZXByZXNlbnRhdGlvbiBpbiBhIGRpZmZlcmVudCBzZXQgb2YgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkuc2hpZnRUbygnbWludXRlcycsICdtaWxsaXNlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiA2MCwgbWlsbGlzZWNvbmRzOiAzMDAwMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUbyguLi51bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVuaXRzID0gdW5pdHMubWFwKCh1KSA9PiBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHUpKTtcblxuICAgIGNvbnN0IGJ1aWx0ID0ge30sXG4gICAgICBhY2N1bXVsYXRlZCA9IHt9LFxuICAgICAgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBsZXQgbGFzdFVuaXQ7XG5cbiAgICBmb3IgKGNvbnN0IGsgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAodW5pdHMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGxhc3RVbml0ID0gaztcblxuICAgICAgICBsZXQgb3duID0gMDtcblxuICAgICAgICAvLyBhbnl0aGluZyB3ZSBoYXZlbid0IGJvaWxlZCBkb3duIHlldCBzaG91bGQgZ2V0IGJvaWxlZCB0byB0aGlzIHVuaXRcbiAgICAgICAgZm9yIChjb25zdCBhayBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgICAgIG93biArPSB0aGlzLm1hdHJpeFtha11ba10gKiBhY2N1bXVsYXRlZFtha107XG4gICAgICAgICAgYWNjdW11bGF0ZWRbYWtdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgdGhhdCdzIGFscmVhZHkgaW4gdGhpcyB1bml0XG4gICAgICAgIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICAgIG93biArPSB2YWxzW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaSA9IE1hdGgudHJ1bmMob3duKTtcbiAgICAgICAgYnVpbHRba10gPSBpO1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IChvd24gKiAxMDAwIC0gaSAqIDEwMDApIC8gMTAwMDtcblxuICAgICAgICAvLyBwbHVzIGFueXRoaW5nIGZ1cnRoZXIgZG93biB0aGUgY2hhaW4gdGhhdCBzaG91bGQgYmUgcm9sbGVkIHVwIGluIHRvIHRoaXNcbiAgICAgICAgZm9yIChjb25zdCBkb3duIGluIHZhbHMpIHtcbiAgICAgICAgICBpZiAob3JkZXJlZFVuaXRzLmluZGV4T2YoZG93bikgPiBvcmRlcmVkVW5pdHMuaW5kZXhPZihrKSkge1xuICAgICAgICAgICAgY29udmVydCh0aGlzLm1hdHJpeCwgdmFscywgZG93biwgYnVpbHQsIGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGtlZXAgaXQgaW4gdGhlIHdpbmdzIHRvIGJvaWwgaXQgbGF0ZXJcbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSB2YWxzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGxlZnRvdmVyIGJlY29tZXMgdGhlIGRlY2ltYWwgZm9yIHRoZSBsYXN0IHVuaXRcbiAgICAvLyBsYXN0VW5pdCBtdXN0IGJlIGRlZmluZWQgc2luY2UgdW5pdHMgaXMgbm90IGVtcHR5XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgIGlmIChhY2N1bXVsYXRlZFtrZXldICE9PSAwKSB7XG4gICAgICAgIGJ1aWx0W2xhc3RVbml0XSArPVxuICAgICAgICAgIGtleSA9PT0gbGFzdFVuaXQgPyBhY2N1bXVsYXRlZFtrZXldIDogYWNjdW11bGF0ZWRba2V5XSAvIHRoaXMubWF0cml4W2xhc3RVbml0XVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogYnVpbHQgfSwgdHJ1ZSkubm9ybWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogU2hpZnQgdGhpcyBEdXJhdGlvbiB0byBhbGwgYXZhaWxhYmxlIHVuaXRzLlxuICAgKiBTYW1lIGFzIHNoaWZ0VG8oXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIilcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvQWxsKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5zaGlmdFRvKFxuICAgICAgXCJ5ZWFyc1wiLFxuICAgICAgXCJtb250aHNcIixcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIFwiZGF5c1wiLFxuICAgICAgXCJob3Vyc1wiLFxuICAgICAgXCJtaW51dGVzXCIsXG4gICAgICBcInNlY29uZHNcIixcbiAgICAgIFwibWlsbGlzZWNvbmRzXCJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmVnYXRpdmUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5uZWdhdGUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogLTEsIHNlY29uZHM6IC0zMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbmVnYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBuZWdhdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgbmVnYXRlZFtrXSA9IHRoaXMudmFsdWVzW2tdID09PSAwID8gMCA6IC10aGlzLnZhbHVlc1trXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBuZWdhdGVkIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnllYXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMucXVhcnRlcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRocy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1vbnRocyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMud2Vla3MgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuZGF5cyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91cnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmhvdXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGVzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbnV0ZXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5zZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbGxpc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRHVyYXRpb24gaXMgaW52YWxpZC4gSW52YWxpZCBkdXJhdGlvbnMgYXJlIHJldHVybmVkIGJ5IGRpZmYgb3BlcmF0aW9uc1xuICAgKiBvbiBpbnZhbGlkIERhdGVUaW1lcyBvciBJbnRlcnZhbHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIER1cmF0aW9ucyBhcmUgZXF1YWwgaWZmIHRoZXkgaGF2ZSB0aGUgc2FtZSB1bml0cyBhbmQgdGhlIHNhbWUgdmFsdWVzIGZvciBlYWNoIHVuaXQuXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcSh2MSwgdjIpIHtcbiAgICAgIC8vIENvbnNpZGVyIDAgYW5kIHVuZGVmaW5lZCBhcyBlcXVhbFxuICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IDApIHJldHVybiB2MiA9PT0gdW5kZWZpbmVkIHx8IHYyID09PSAwO1xuICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoIWVxKHRoaXMudmFsdWVzW3VdLCBvdGhlci52YWx1ZXNbdV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0ZVRpbWUsIHsgZnJpZW5kbHlEYXRlVGltZSB9IGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWRJbnRlcnZhbEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjtcblxuLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuZnVuY3Rpb24gdmFsaWRhdGVTdGFydEVuZChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgIXN0YXJ0LmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBzdGFydFwiKTtcbiAgfSBlbHNlIGlmICghZW5kIHx8ICFlbmQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIGVuZFwiKTtcbiAgfSBlbHNlIGlmIChlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFxuICAgICAgXCJlbmQgYmVmb3JlIHN0YXJ0XCIsXG4gICAgICBgVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9JHtzdGFydC50b0lTTygpfSBhbmQgZW5kPSR7ZW5kLnRvSVNPKCl9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwuZnJvbURhdGVUaW1lc30sIHtAbGluayBJbnRlcnZhbC5hZnRlcn0sIHtAbGluayBJbnRlcnZhbC5iZWZvcmV9LCBvciB7QGxpbmsgSW50ZXJ2YWwuZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBJbnRlcnZhbCNzdGFydH0gYW5kIHtAbGluayBJbnRlcnZhbCNlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjY291bnR9LCB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSwge0BsaW5rIEludGVydmFsI2hhc1NhbWV9LCB7QGxpbmsgSW50ZXJ2YWwjY29udGFpbnN9LCB7QGxpbmsgSW50ZXJ2YWwjaXNBZnRlcn0sIG9yIHtAbGluayBJbnRlcnZhbCNpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNzZXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRBdH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEJ5fSwge0BsaW5rIEludGVydmFsI2RpdmlkZUVxdWFsbHl9LCB7QGxpbmsgSW50ZXJ2YWwubWVyZ2V9LCB7QGxpbmsgSW50ZXJ2YWwueG9yfSwge0BsaW5rIEludGVydmFsI3VuaW9ufSwge0BsaW5rIEludGVydmFsI2ludGVyc2VjdGlvbn0sIG9yIHtAbGluayBJbnRlcnZhbCNkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI2VxdWFsc30sIHtAbGluayBJbnRlcnZhbCNvdmVybGFwc30sIHtAbGluayBJbnRlcnZhbCNhYnV0c1N0YXJ0fSwge0BsaW5rIEludGVydmFsI2FidXRzRW5kfSwge0BsaW5rIEludGVydmFsI2VuZ3VsZnN9XG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9TdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU099LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09EYXRlfSwge0BsaW5rIEludGVydmFsI3RvSVNPVGltZX0sIHtAbGluayBJbnRlcnZhbCN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgSW50ZXJ2YWwjdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYWZ0ZXIoc3RhcnQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0LCBkdC5wbHVzKGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUjZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uI2Zyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3MsIGVdID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpO1xuICAgIGlmIChzICYmIGUpIHtcbiAgICAgIGxldCBzdGFydCwgc3RhcnRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZCwgZW5kSXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmJlZm9yZShlbmQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNJbnRlcnZhbChvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkludGVydmFsKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQpLFxuICAgICAgZW5kID0gdGhpcy5lbmQuc3RhcnRPZih1bml0KTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpKSArIDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBZnRlcihkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc2V0KHsgc3RhcnQsIGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQgfHwgdGhpcy5zLCBlbmQgfHwgdGhpcy5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcigoZCkgPT4gdGhpcy5jb250YWlucyhkKSlcbiAgICAgICAgLnNvcnQoKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IOKAkyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIEludGVydmFsLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXNcbiAgICoge0BsaW5rIERhdGVUaW1lLkRBVEVfRlVMTH0gb3Ige0BsaW5rIERhdGVUaW1lLlRJTUVfU0lNUExFfS4gVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kXG4gICAqIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiBJbnRlcnZhbCBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlblxuICAgKiBzcGVjaWZpZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmb3JtYXRPcHRzPURhdGVUaW1lLkRBVEVfU0hPUlRdIC0gRWl0aGVyIGEgRGF0ZVRpbWUgcHJlc2V0IG9yXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBzdGFydCBEYXRlVGltZS5cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDExLzcvMjAyMiDigJMgMTEvOC8yMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiBOb3ZlbWJlciA3IOKAkyA4LCAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyLUZSJyB9KTsgLy89PiA34oCTOCBub3ZlbWJyZSAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+IDY6MDAg4oCTIDg6MDAgUE1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiBNb24sIE5vdiAwNywgNjowMCDigJMgODowMCBwXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLnMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXRJbnRlcnZhbCh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTTyhvcHRzKX0vJHt0aGlzLmUudG9JU08ob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGF0ZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgdGltZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT0RhdGUoKX0vJHt0aGlzLmUudG9JU09EYXRlKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09UaW1lKG9wdHMpfS8ke3RoaXMuZS50b0lTT1RpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICAgKiBzdHJpbmcuICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGVcbiAgICogZm9ybWF0dGluZyB0b29sLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZUZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLiBUaGlzIHN0cmluZyBmb3JtYXRzIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5zZXBhcmF0b3IgPSAgJyDigJMgJ10gLSBBIHNlcGFyYXRvciB0byBwbGFjZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kXG4gICAqIHJlcHJlc2VudGF0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZGF0ZUZvcm1hdCwgeyBzZXBhcmF0b3IgPSBcIiDigJMgXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9JHtzZXBhcmF0b3J9JHt0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHRpbWUgc3Bhbm5lZCBieSB0aGlzIGludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA4ODQ4OTI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ2RheXMnKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiAxLjAyNDE4MTIxNTI3Nzc3NzggfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LjgyMDk1IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LCBzZWNvbmRzOiA0OS4yNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgc2Vjb25kczogODg0ODkuMjU3IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICB0b0R1cmF0aW9uKHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG1hcEZuIG9uIHRoZSBpbnRlcnZhbCBzdGFydCBhbmQgZW5kLCByZXR1cm5pbmcgYSBuZXcgSW50ZXJ2YWwgZnJvbSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnRvVVRDKCkpXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC5wbHVzKHsgaG91cnM6IDIgfSkpXG4gICAqL1xuICBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygpWzBdIC8vPT4gJ0phbnVhcnknXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcpWzBdIC8vPT4gJ0phbidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnKVswXSAvLz0+ICcxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9IClbMF0gLy89PiAnamFudi4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2aEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmnKuyBJJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHMoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyNtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2KfZhNin2KvZhtmK2YYnXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyN3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAn4YCU4YC24YCU4YCA4YC6JywgJ+GAiuGAlOGAsScgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZyBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgKiBLZXlzOlxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogQGV4YW1wbGUgSW5mby5mZWF0dXJlcygpIC8vPT4geyByZWxhdGl2ZTogZmFsc2UgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmU6IGhhc1JlbGF0aXZlKCkgfTtcbiAgfVxufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gZGF5RGlmZihlYXJsaWVyLCBsYXRlcikge1xuICBjb25zdCB1dGNEYXlTdGFydCA9IChkdCkgPT4gZHQudG9VVEMoMCwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pLnN0YXJ0T2YoXCJkYXlcIikudmFsdWVPZigpLFxuICAgIG1zID0gdXRjRGF5U3RhcnQobGF0ZXIpIC0gdXRjRGF5U3RhcnQoZWFybGllcik7XG4gIHJldHVybiBNYXRoLmZsb29yKER1cmF0aW9uLmZyb21NaWxsaXMobXMpLmFzKFwiZGF5c1wiKSk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hPcmRlckRpZmZzKGN1cnNvciwgbGF0ZXIsIHVuaXRzKSB7XG4gIGNvbnN0IGRpZmZlcnMgPSBbXG4gICAgW1wieWVhcnNcIiwgKGEsIGIpID0+IGIueWVhciAtIGEueWVhcl0sXG4gICAgW1wicXVhcnRlcnNcIiwgKGEsIGIpID0+IGIucXVhcnRlciAtIGEucXVhcnRlciArIChiLnllYXIgLSBhLnllYXIpICogNF0sXG4gICAgW1wibW9udGhzXCIsIChhLCBiKSA9PiBiLm1vbnRoIC0gYS5tb250aCArIChiLnllYXIgLSBhLnllYXIpICogMTJdLFxuICAgIFtcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGRheXMgPSBkYXlEaWZmKGEsIGIpO1xuICAgICAgICByZXR1cm4gKGRheXMgLSAoZGF5cyAlIDcpKSAvIDc7XG4gICAgICB9LFxuICAgIF0sXG4gICAgW1wiZGF5c1wiLCBkYXlEaWZmXSxcbiAgXTtcblxuICBjb25zdCByZXN1bHRzID0ge307XG4gIGNvbnN0IGVhcmxpZXIgPSBjdXJzb3I7XG4gIGxldCBsb3dlc3RPcmRlciwgaGlnaFdhdGVyO1xuXG4gIGZvciAoY29uc3QgW3VuaXQsIGRpZmZlcl0gb2YgZGlmZmVycykge1xuICAgIGlmICh1bml0cy5pbmRleE9mKHVuaXQpID49IDApIHtcbiAgICAgIGxvd2VzdE9yZGVyID0gdW5pdDtcblxuICAgICAgcmVzdWx0c1t1bml0XSA9IGRpZmZlcihjdXJzb3IsIGxhdGVyKTtcbiAgICAgIGhpZ2hXYXRlciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgaWYgKGhpZ2hXYXRlciA+IGxhdGVyKSB7XG4gICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgb3B0cykge1xuICBsZXQgW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl0gPSBoaWdoT3JkZXJEaWZmcyhlYXJsaWVyLCBsYXRlciwgdW5pdHMpO1xuXG4gIGNvbnN0IHJlbWFpbmluZ01pbGxpcyA9IGxhdGVyIC0gY3Vyc29yO1xuXG4gIGNvbnN0IGxvd2VyT3JkZXJVbml0cyA9IHVuaXRzLmZpbHRlcihcbiAgICAodSkgPT4gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiXS5pbmRleE9mKHUpID49IDBcbiAgKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWdoV2F0ZXIgPCBsYXRlcikge1xuICAgICAgaGlnaFdhdGVyID0gY3Vyc29yLnBsdXMoeyBbbG93ZXN0T3JkZXJdOiAxIH0pO1xuICAgIH1cblxuICAgIGlmIChoaWdoV2F0ZXIgIT09IGN1cnNvcikge1xuICAgICAgcmVzdWx0c1tsb3dlc3RPcmRlcl0gPSAocmVzdWx0c1tsb3dlc3RPcmRlcl0gfHwgMCkgKyByZW1haW5pbmdNaWxsaXMgLyAoaGlnaFdhdGVyIC0gY3Vyc29yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkdXJhdGlvbiA9IER1cmF0aW9uLmZyb21PYmplY3QocmVzdWx0cywgb3B0cyk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMocmVtYWluaW5nTWlsbGlzLCBvcHRzKVxuICAgICAgLnNoaWZ0VG8oLi4ubG93ZXJPcmRlclVuaXRzKVxuICAgICAgLnBsdXMoZHVyYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxufVxuIiwgImNvbnN0IG51bWJlcmluZ1N5c3RlbXMgPSB7XG4gIGFyYWI6IFwiW1xcdTA2NjAtXFx1MDY2OV1cIixcbiAgYXJhYmV4dDogXCJbXFx1MDZGMC1cXHUwNkY5XVwiLFxuICBiYWxpOiBcIltcXHUxQjUwLVxcdTFCNTldXCIsXG4gIGJlbmc6IFwiW1xcdTA5RTYtXFx1MDlFRl1cIixcbiAgZGV2YTogXCJbXFx1MDk2Ni1cXHUwOTZGXVwiLFxuICBmdWxsd2lkZTogXCJbXFx1RkYxMC1cXHVGRjE5XVwiLFxuICBndWpyOiBcIltcXHUwQUU2LVxcdTBBRUZdXCIsXG4gIGhhbmlkZWM6IFwiW+OAh3zkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nV1cIixcbiAga2htcjogXCJbXFx1MTdFMC1cXHUxN0U5XVwiLFxuICBrbmRhOiBcIltcXHUwQ0U2LVxcdTBDRUZdXCIsXG4gIGxhb286IFwiW1xcdTBFRDAtXFx1MEVEOV1cIixcbiAgbGltYjogXCJbXFx1MTk0Ni1cXHUxOTRGXVwiLFxuICBtbHltOiBcIltcXHUwRDY2LVxcdTBENkZdXCIsXG4gIG1vbmc6IFwiW1xcdTE4MTAtXFx1MTgxOV1cIixcbiAgbXltcjogXCJbXFx1MTA0MC1cXHUxMDQ5XVwiLFxuICBvcnlhOiBcIltcXHUwQjY2LVxcdTBCNkZdXCIsXG4gIHRhbWxkZWM6IFwiW1xcdTBCRTYtXFx1MEJFRl1cIixcbiAgdGVsdTogXCJbXFx1MEM2Ni1cXHUwQzZGXVwiLFxuICB0aGFpOiBcIltcXHUwRTUwLVxcdTBFNTldXCIsXG4gIHRpYnQ6IFwiW1xcdTBGMjAtXFx1MEYyOV1cIixcbiAgbGF0bjogXCJcXFxcZFwiLFxufTtcblxuY29uc3QgbnVtYmVyaW5nU3lzdGVtc1VURjE2ID0ge1xuICBhcmFiOiBbMTYzMiwgMTY0MV0sXG4gIGFyYWJleHQ6IFsxNzc2LCAxNzg1XSxcbiAgYmFsaTogWzY5OTIsIDcwMDFdLFxuICBiZW5nOiBbMjUzNCwgMjU0M10sXG4gIGRldmE6IFsyNDA2LCAyNDE1XSxcbiAgZnVsbHdpZGU6IFs2NTI5NiwgNjUzMDNdLFxuICBndWpyOiBbMjc5MCwgMjc5OV0sXG4gIGtobXI6IFs2MTEyLCA2MTIxXSxcbiAga25kYTogWzMzMDIsIDMzMTFdLFxuICBsYW9vOiBbMzc5MiwgMzgwMV0sXG4gIGxpbWI6IFs2NDcwLCA2NDc5XSxcbiAgbWx5bTogWzM0MzAsIDM0MzldLFxuICBtb25nOiBbNjE2MCwgNjE2OV0sXG4gIG15bXI6IFs0MTYwLCA0MTY5XSxcbiAgb3J5YTogWzI5MTgsIDI5MjddLFxuICB0YW1sZGVjOiBbMzA0NiwgMzA1NV0sXG4gIHRlbHU6IFszMTc0LCAzMTgzXSxcbiAgdGhhaTogWzM2NjQsIDM2NzNdLFxuICB0aWJ0OiBbMzg3MiwgMzg4MV0sXG59O1xuXG5jb25zdCBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIGxldCB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChzdHJbaV0uc2VhcmNoKG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYykgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlICs9IGhhbmlkZWNDaGFycy5pbmRleE9mKHN0cltpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gbnVtYmVyaW5nU3lzdGVtc1VURjE2W2tleV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZ2l0UmVnZXgoeyBudW1iZXJpbmdTeXN0ZW0gfSwgYXBwZW5kID0gXCJcIikge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgJHtudW1iZXJpbmdTeXN0ZW1zW251bWJlcmluZ1N5c3RlbSB8fCBcImxhdG5cIl19JHthcHBlbmR9YCk7XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VNaWxsaXMsIGlzVW5kZWZpbmVkLCB1bnRydW5jYXRlWWVhciwgc2lnbmVkT2Zmc2V0LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCB7IGRpZ2l0UmVnZXgsIHBhcnNlRGlnaXRzIH0gZnJvbSBcIi4vZGlnaXRzLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3QgTUlTU0lOR19GVFAgPSBcIm1pc3NpbmcgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIHN1cHBvcnRcIjtcblxuZnVuY3Rpb24gaW50VW5pdChyZWdleCwgcG9zdCA9IChpKSA9PiBpKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcG9zdChwYXJzZURpZ2l0cyhzKSkgfTtcbn1cblxuY29uc3QgTkJTUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKTtcbmNvbnN0IHNwYWNlT3JOQlNQID0gYFsgJHtOQlNQfV1gO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiLCBmYWxzZSksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIsIGZhbHNlKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxuICB0aW1lWm9uZU5hbWU6IHtcbiAgICBsb25nOiBcIlpaWlpaXCIsXG4gICAgc2hvcnQ6IFwiWlpaXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0b2tlbkZvclBhcnQocGFydCwgZm9ybWF0T3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiB0cnVlLFxuICAgICAgdmFsOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFt0eXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICB1bml0cyA9IHRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKSxcbiAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoKHQpID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgaWYgKGRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgaW52YWxpZFJlYXNvbjogZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh1bml0cyksXG4gICAgICByZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpLFxuICAgICAgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldF0gPSBtYXRjaGVzXG4gICAgICAgID8gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKVxuICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgcmVnZXgsIHJhd01hdGNoZXMsIG1hdGNoZXMsIHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCk7XG4gIHJldHVybiBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKSB7XG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXREYXRlVGltZVBhcnRzKGdldER1bW15RGF0ZVRpbWUoKSk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHApID0+IHRva2VuRm9yUGFydChwLCBmb3JtYXRPcHRzKSk7XG59XG4iLCAiaW1wb3J0IHtcbiAgaW50ZWdlckJldHdlZW4sXG4gIGlzTGVhcFllYXIsXG4gIHRpbWVPYmplY3QsXG4gIGRheXNJblllYXIsXG4gIGRheXNJbk1vbnRoLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIGlzSW50ZWdlcixcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW52YWxpZC5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmZ1bmN0aW9uIGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXG4gIGlmICh5ZWFyIDwgMTAwICYmIHllYXIgPj0gMCkge1xuICAgIGQuc2V0VVRDRnVsbFllYXIoZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCk7XG4gIH1cblxuICBjb25zdCBqcyA9IGQuZ2V0VVRDRGF5KCk7XG5cbiAgcmV0dXJuIGpzID09PSAwID8gNyA6IGpzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIHJldHVybiBkYXkgKyAoaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyKVttb250aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpIHtcbiAgY29uc3QgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgbW9udGgwID0gdGFibGUuZmluZEluZGV4KChpKSA9PiBpIDwgb3JkaW5hbCksXG4gICAgZGF5ID0gb3JkaW5hbCAtIHRhYmxlW21vbnRoMF07XG4gIHJldHVybiB7IG1vbnRoOiBtb250aDAgKyAxLCBkYXkgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub1dlZWsoZ3JlZ09iaikge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdPYmosXG4gICAgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpLFxuICAgIHdlZWtkYXkgPSBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSk7XG5cbiAgbGV0IHdlZWtOdW1iZXIgPSBNYXRoLmZsb29yKChvcmRpbmFsIC0gd2Vla2RheSArIDEwKSAvIDcpLFxuICAgIHdlZWtZZWFyO1xuXG4gIGlmICh3ZWVrTnVtYmVyIDwgMSkge1xuICAgIHdlZWtZZWFyID0geWVhciAtIDE7XG4gICAgd2Vla051bWJlciA9IHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAod2Vla051bWJlciA+IHdlZWtzSW5XZWVrWWVhcih5ZWFyKSkge1xuICAgIHdlZWtZZWFyID0geWVhciArIDE7XG4gICAgd2Vla051bWJlciA9IDE7XG4gIH0gZWxzZSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyO1xuICB9XG5cbiAgcmV0dXJuIHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXksIC4uLnRpbWVPYmplY3QoZ3JlZ09iaikgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtUb0dyZWdvcmlhbih3ZWVrRGF0YSkge1xuICBjb25zdCB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5IH0gPSB3ZWVrRGF0YSxcbiAgICB3ZWVrZGF5T2ZKYW40ID0gZGF5T2ZXZWVrKHdlZWtZZWFyLCAxLCA0KSxcbiAgICB5ZWFySW5EYXlzID0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG5cbiAgbGV0IG9yZGluYWwgPSB3ZWVrTnVtYmVyICogNyArIHdlZWtkYXkgLSB3ZWVrZGF5T2ZKYW40IC0gMyxcbiAgICB5ZWFyO1xuXG4gIGlmIChvcmRpbmFsIDwgMSkge1xuICAgIHllYXIgPSB3ZWVrWWVhciAtIDE7XG4gICAgb3JkaW5hbCArPSBkYXlzSW5ZZWFyKHllYXIpO1xuICB9IGVsc2UgaWYgKG9yZGluYWwgPiB5ZWFySW5EYXlzKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyICsgMTtcbiAgICBvcmRpbmFsIC09IGRheXNJblllYXIod2Vla1llYXIpO1xuICB9IGVsc2Uge1xuICAgIHllYXIgPSB3ZWVrWWVhcjtcbiAgfVxuXG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdCh3ZWVrRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvT3JkaW5hbChncmVnRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdEYXRhO1xuICBjb25zdCBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSk7XG4gIHJldHVybiB7IHllYXIsIG9yZGluYWwsIC4uLnRpbWVPYmplY3QoZ3JlZ0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsVG9HcmVnb3JpYW4ob3JkaW5hbERhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBvcmRpbmFsIH0gPSBvcmRpbmFsRGF0YTtcbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KG9yZGluYWxEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLndlZWtZZWFyKSxcbiAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla051bWJlciwgMSwgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhcikpLFxuICAgIHZhbGlkV2Vla2RheSA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrZGF5LCAxLCA3KTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtZZWFyXCIsIG9iai53ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vlaykge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtcIiwgb2JqLndlZWspO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWtkYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrZGF5XCIsIG9iai53ZWVrZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRPcmRpbmFsRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE9yZGluYWwgPSBpbnRlZ2VyQmV0d2VlbihvYmoub3JkaW5hbCwgMSwgZGF5c0luWWVhcihvYmoueWVhcikpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkT3JkaW5hbCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm9yZGluYWxcIiwgb2JqLm9yZGluYWwpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRNb250aCA9IGludGVnZXJCZXR3ZWVuKG9iai5tb250aCwgMSwgMTIpLFxuICAgIHZhbGlkRGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLmRheSwgMSwgZGF5c0luTW9udGgob2JqLnllYXIsIG9iai5tb250aCkpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTW9udGgpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtb250aFwiLCBvYmoubW9udGgpO1xuICB9IGVsc2UgaWYgKCF2YWxpZERheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImRheVwiLCBvYmouZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRUaW1lRGF0YShvYmopIHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IG9iajtcbiAgY29uc3QgdmFsaWRIb3VyID1cbiAgICAgIGludGVnZXJCZXR3ZWVuKGhvdXIsIDAsIDIzKSB8fFxuICAgICAgKGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDApLFxuICAgIHZhbGlkTWludXRlID0gaW50ZWdlckJldHdlZW4obWludXRlLCAwLCA1OSksXG4gICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICB2YWxpZE1pbGxpc2Vjb25kID0gaW50ZWdlckJldHdlZW4obWlsbGlzZWNvbmQsIDAsIDk5OSk7XG5cbiAgaWYgKCF2YWxpZEhvdXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJob3VyXCIsIGhvdXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbnV0ZSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbnV0ZVwiLCBtaW51dGUpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInNlY29uZFwiLCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbGxpc2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWlsbGlzZWNvbmRcIiwgbWlsbGlzZWNvbmQpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IEludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQge1xuICBpc1VuZGVmaW5lZCxcbiAgbWF5YmVBcnJheSxcbiAgaXNEYXRlLFxuICBpc051bWJlcixcbiAgYmVzdEJ5LFxuICBkYXlzSW5Nb250aCxcbiAgZGF5c0luWWVhcixcbiAgaXNMZWFwWWVhcixcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG4gIG9ialRvTG9jYWxUUyxcbiAgcGFkU3RhcnQsXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCBkaWZmIGZyb20gXCIuL2ltcGwvZGlmZi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSRkMyODIyRGF0ZSwgcGFyc2VJU09EYXRlLCBwYXJzZUhUVFBEYXRlLCBwYXJzZVNRTCB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlRnJvbVRva2VucyxcbiAgZXhwbGFpbkZyb21Ub2tlbnMsXG4gIGZvcm1hdE9wdHNUb1Rva2VucyxcbiAgZXhwYW5kTWFjcm9Ub2tlbnMsXG59IGZyb20gXCIuL2ltcGwvdG9rZW5QYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGdyZWdvcmlhblRvV2VlayxcbiAgd2Vla1RvR3JlZ29yaWFuLFxuICBncmVnb3JpYW5Ub09yZGluYWwsXG4gIG9yZGluYWxUb0dyZWdvcmlhbixcbiAgaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEsXG4gIGhhc0ludmFsaWRXZWVrRGF0YSxcbiAgaGFzSW52YWxpZE9yZGluYWxEYXRhLFxuICBoYXNJbnZhbGlkVGltZURhdGEsXG59IGZyb20gXCIuL2ltcGwvY29udmVyc2lvbnMuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5pbXBvcnQge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IsXG4gIEludmFsaWRVbml0RXJyb3IsXG4gIEludmFsaWREYXRlVGltZUVycm9yLFxufSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIERhdGVUaW1lXCI7XG5jb25zdCBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgYHRoZSB6b25lIFwiJHt6b25lLm5hbWV9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuXG4vLyB3ZSBjYWNoZSB3ZWVrIGRhdGEgb24gdGhlIERUIG9iamVjdCBhbmQgdGhpcyBpbnRlcm1lZGlhdGVzIHRoZSBjYWNoZVxuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRXZWVrRGF0YShkdCkge1xuICBpZiAoZHQud2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC53ZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhkdC5jKTtcbiAgfVxuICByZXR1cm4gZHQud2Vla0RhdGE7XG59XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucywgXCJtYWtlIGEgbmV3IG9iamVjdCB3aXRoIHRoZXNlIG1vZGlmaWNhdGlvbnNcIi4gYWxsIFwic2V0dGVyc1wiIHJlYWxseSB1c2UgdGhpc1xuLy8gdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB3aGlsZSBvbmx5IGNoYW5naW5nIHNvbWUgb2YgdGhlIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGNsb25lKGluc3QsIGFsdHMpIHtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICB0czogaW5zdC50cyxcbiAgICB6b25lOiBpbnN0LnpvbmUsXG4gICAgYzogaW5zdC5jLFxuICAgIG86IGluc3QubyxcbiAgICBsb2M6IGluc3QubG9jLFxuICAgIGludmFsaWQ6IGluc3QuaW52YWxpZCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IC4uLmN1cnJlbnQsIC4uLmFsdHMsIG9sZDogY3VycmVudCB9KTtcbn1cblxuLy8gZmluZCB0aGUgcmlnaHQgb2Zmc2V0IGEgZ2l2ZW4gbG9jYWwgdGltZS4gVGhlIG8gaW5wdXQgaXMgb3VyIGd1ZXNzLCB3aGljaCBkZXRlcm1pbmVzIHdoaWNoXG4vLyBvZmZzZXQgd2UnbGwgcGljayBpbiBhbWJpZ3VvdXMgY2FzZXMgKGUuZy4gdGhlcmUgYXJlIHR3byAzIEFNcyBiL2MgRmFsbGJhY2sgRFNUKVxuZnVuY3Rpb24gZml4T2Zmc2V0KGxvY2FsVFMsIG8sIHR6KSB7XG4gIC8vIE91ciBVVEMgdGltZSBpcyBqdXN0IGEgZ3Vlc3MgYmVjYXVzZSBvdXIgb2Zmc2V0IGlzIGp1c3QgYSBndWVzc1xuICBsZXQgdXRjR3Vlc3MgPSBsb2NhbFRTIC0gbyAqIDYwICogMTAwMDtcblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG4gIGNvbnN0IG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcblxuICAvLyBJZiBzbywgb2Zmc2V0IGRpZG4ndCBjaGFuZ2UgYW5kIHdlJ3JlIGRvbmVcbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH1cblxuICAvLyBJZiBub3QsIGNoYW5nZSB0aGUgdHMgYnkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIG9mZnNldFxuICB1dGNHdWVzcyAtPSAobzIgLSBvKSAqIDYwICogMTAwMDtcblxuICAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcbiAgY29uc3QgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuICBpZiAobzIgPT09IG8zKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgbzJdO1xuICB9XG5cbiAgLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuICByZXR1cm4gW2xvY2FsVFMgLSBNYXRoLm1pbihvMiwgbzMpICogNjAgKiAxMDAwLCBNYXRoLm1heChvMiwgbzMpXTtcbn1cblxuLy8gY29udmVydCBhbiBlcG9jaCB0aW1lc3RhbXAgaW50byBhIGNhbGVuZGFyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBvZmZzZXRcbmZ1bmN0aW9uIHRzVG9PYmoodHMsIG9mZnNldCkge1xuICB0cyArPSBvZmZzZXQgKiA2MCAqIDEwMDA7XG5cbiAgY29uc3QgZCA9IG5ldyBEYXRlKHRzKTtcblxuICByZXR1cm4ge1xuICAgIHllYXI6IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGQuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGQuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGQuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogZC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIH07XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBlcG9jaCB0aW1lc3RhbXBcbmZ1bmN0aW9uIG9ialRvVFMob2JqLCBvZmZzZXQsIHpvbmUpIHtcbiAgcmV0dXJuIGZpeE9mZnNldChvYmpUb0xvY2FsVFMob2JqKSwgb2Zmc2V0LCB6b25lKTtcbn1cblxuLy8gY3JlYXRlIGEgbmV3IERUIGluc3RhbmNlIGJ5IGFkZGluZyBhIGR1cmF0aW9uLCBhZGp1c3RpbmcgZm9yIERTVHNcbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIGNvbnN0IG9QcmUgPSBpbnN0Lm8sXG4gICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgIG1vbnRoID0gaW5zdC5jLm1vbnRoICsgTWF0aC50cnVuYyhkdXIubW9udGhzKSArIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSAqIDMsXG4gICAgYyA9IHtcbiAgICAgIC4uLmluc3QuYyxcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheTpcbiAgICAgICAgTWF0aC5taW4oaW5zdC5jLmRheSwgZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLmRheXMpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIud2Vla3MpICogNyxcbiAgICB9LFxuICAgIG1pbGxpc1RvQWRkID0gRHVyYXRpb24uZnJvbU9iamVjdCh7XG4gICAgICB5ZWFyczogZHVyLnllYXJzIC0gTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICAgIG1vbnRoczogZHVyLm1vbnRocyAtIE1hdGgudHJ1bmMoZHVyLm1vbnRocyksXG4gICAgICB3ZWVrczogZHVyLndlZWtzIC0gTWF0aC50cnVuYyhkdXIud2Vla3MpLFxuICAgICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICAgIGhvdXJzOiBkdXIuaG91cnMsXG4gICAgICBtaW51dGVzOiBkdXIubWludXRlcyxcbiAgICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkdXIubWlsbGlzZWNvbmRzLFxuICAgIH0pLmFzKFwibWlsbGlzZWNvbmRzXCIpLFxuICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgbGV0IFt0cywgb10gPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKTtcblxuICBpZiAobWlsbGlzVG9BZGQgIT09IDApIHtcbiAgICB0cyArPSBtaWxsaXNUb0FkZDtcbiAgICAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG4gICAgbyA9IGluc3Quem9uZS5vZmZzZXQodHMpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHMsIG8gfTtcbn1cblxuLy8gaGVscGVyIHVzZWZ1bCBpbiB0dXJuaW5nIHRoZSByZXN1bHRzIG9mIHBhcnNpbmcgaW50byByZWFsIGRhdGVzXG4vLyBieSBoYW5kbGluZyB0aGUgem9uZSBvcHRpb25zXG5mdW5jdGlvbiBwYXJzZURhdGFUb0RhdGVUaW1lKHBhcnNlZCwgcGFyc2VkWm9uZSwgb3B0cywgZm9ybWF0LCB0ZXh0LCBzcGVjaWZpY09mZnNldCkge1xuICBjb25zdCB7IHNldFpvbmUsIHpvbmUgfSA9IG9wdHM7XG4gIGlmIChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBpbnRlcnByZXRhdGlvblpvbmUgPSBwYXJzZWRab25lIHx8IHpvbmUsXG4gICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChwYXJzZWQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgICBzcGVjaWZpY09mZnNldCxcbiAgICAgIH0pO1xuICAgIHJldHVybiBzZXRab25lID8gaW5zdCA6IGluc3Quc2V0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgIG5ldyBJbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyAke2Zvcm1hdH1gKVxuICAgICk7XG4gIH1cbn1cblxuLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcbmZ1bmN0aW9uIHRvVGVjaEZvcm1hdChkdCwgZm9ybWF0LCBhbGxvd1ogPSB0cnVlKSB7XG4gIHJldHVybiBkdC5pc1ZhbGlkXG4gICAgPyBGb3JtYXR0ZXIuY3JlYXRlKExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKSwge1xuICAgICAgICBhbGxvd1osXG4gICAgICAgIGZvcmNlU2ltcGxlOiB0cnVlLFxuICAgICAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpXG4gICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0lTT0RhdGUobywgZXh0ZW5kZWQpIHtcbiAgY29uc3QgbG9uZ0Zvcm1hdCA9IG8uYy55ZWFyID4gOTk5OSB8fCBvLmMueWVhciA8IDA7XG4gIGxldCBjID0gXCJcIjtcbiAgaWYgKGxvbmdGb3JtYXQgJiYgby5jLnllYXIgPj0gMCkgYyArPSBcIitcIjtcbiAgYyArPSBwYWRTdGFydChvLmMueWVhciwgbG9uZ0Zvcm1hdCA/IDYgOiA0KTtcblxuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHRvSVNPVGltZShcbiAgbyxcbiAgZXh0ZW5kZWQsXG4gIHN1cHByZXNzU2Vjb25kcyxcbiAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gIGluY2x1ZGVPZmZzZXQsXG4gIGV4dGVuZGVkWm9uZVxuKSB7XG4gIGxldCBjID0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiOlwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgaWYgKG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgICAgYyArPSBcIjpcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgfVxuXG4gIGlmIChvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuXG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NNaWxsaXNlY29uZHMpIHtcbiAgICAgIGMgKz0gXCIuXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwICYmICFleHRlbmRlZFpvbmUpIHtcbiAgICAgIGMgKz0gXCJaXCI7XG4gICAgfSBlbHNlIGlmIChvLm8gPCAwKSB7XG4gICAgICBjICs9IFwiLVwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vICUgNjApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyArPSBcIitcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gJSA2MCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHRlbmRlZFpvbmUpIHtcbiAgICBjICs9IFwiW1wiICsgby56b25lLmlhbmFOYW1lICsgXCJdXCI7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCBvcHRzKSB7XG4gIGNvbnN0IHpvbmUgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgIHRzTm93ID0gU2V0dGluZ3Mubm93KCk7XG5cbiAgbGV0IHRzLCBvO1xuXG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgaWYgKCFpc1VuZGVmaW5lZChvYmoueWVhcikpIHtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQob2JqW3VdKSkge1xuICAgICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB8fCBoYXNJbnZhbGlkVGltZURhdGEob2JqKTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0UHJvdmlzID0gem9uZS5vZmZzZXQodHNOb3cpO1xuICAgIFt0cywgb10gPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0cyA9IHRzTm93O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IHRzLCB6b25lLCBsb2MsIG8gfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIGNvbnN0IHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICBmb3JtYXQgPSAoYywgdW5pdCkgPT4ge1xuICAgICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgdHJ1ZSk7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICAgIH0sXG4gICAgZGlmZmVyID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChvcHRzLmNhbGVuZGFyeSkge1xuICAgICAgICBpZiAoIWVuZC5oYXNTYW1lKHN0YXJ0LCB1bml0KSkge1xuICAgICAgICAgIHJldHVybiBlbmQuc3RhcnRPZih1bml0KS5kaWZmKHN0YXJ0LnN0YXJ0T2YodW5pdCksIHVuaXQpLmdldCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCk7XG4gICAgICB9XG4gICAgfTtcblxuICBpZiAob3B0cy51bml0KSB7XG4gICAgcmV0dXJuIGZvcm1hdChkaWZmZXIob3B0cy51bml0KSwgb3B0cy51bml0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdW5pdCBvZiBvcHRzLnVuaXRzKSB7XG4gICAgY29uc3QgY291bnQgPSBkaWZmZXIodW5pdCk7XG4gICAgaWYgKE1hdGguYWJzKGNvdW50KSA+PSAxKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzdGFydCA+IGVuZCA/IC0wIDogMCwgb3B0cy51bml0c1tvcHRzLnVuaXRzLmxlbmd0aCAtIDFdKTtcbn1cblxuZnVuY3Rpb24gbGFzdE9wdHMoYXJnTGlzdCkge1xuICBsZXQgb3B0cyA9IHt9LFxuICAgIGFyZ3M7XG4gIGlmIChhcmdMaXN0Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICAgIG9wdHMgPSBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV07XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCkuc2xpY2UoMCwgYXJnTGlzdC5sZW5ndGggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KTtcbiAgfVxuICByZXR1cm4gW29wdHMsIGFyZ3NdO1xufVxuXG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgRGF0ZVRpbWUubG9jYWx9LCB7QGxpbmsgRGF0ZVRpbWUudXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgRGF0ZVRpbWUuZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30sIHtAbGluayBEYXRlVGltZS5mcm9tSFRUUH0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUuZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjeWVhcn0sIHtAbGluayBEYXRlVGltZSNtb250aH0sXG4gKiB7QGxpbmsgRGF0ZVRpbWUjZGF5fSwge0BsaW5rIERhdGVUaW1lI2hvdXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXRlfSwge0BsaW5rIERhdGVUaW1lI3NlY29uZH0sIHtAbGluayBEYXRlVGltZSNtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIERhdGVUaW1lI3dlZWtZZWFyfSwge0BsaW5rIERhdGVUaW1lI3dlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIERhdGVUaW1lI3dlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjbG9jYWxlfSBhbmQge0BsaW5rIERhdGVUaW1lI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0fSwge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSwge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0TG9jYWxlfSwge0BsaW5rIERhdGVUaW1lLnBsdXN9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXN9LCB7QGxpbmsgRGF0ZVRpbWUjZW5kT2Z9LCB7QGxpbmsgRGF0ZVRpbWUjc3RhcnRPZn0sIHtAbGluayBEYXRlVGltZSN0b1VUQ30sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZX0sIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9KU09OfSwge0BsaW5rIERhdGVUaW1lI3RvSVNPfSwge0BsaW5rIERhdGVUaW1lI3RvSFRUUH0sIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0sIHtAbGluayBEYXRlVGltZSN0b1JGQzI4MjJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9TdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9LCB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVUaW1lIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgY29uZmlnLmludmFsaWQgfHxcbiAgICAgIChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8XG4gICAgICAoIXpvbmUuaXNWYWxpZCA/IHVuc3VwcG9ydGVkWm9uZSh6b25lKSA6IG51bGwpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG5cbiAgICBsZXQgYyA9IG51bGwsXG4gICAgICBvID0gbnVsbDtcbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIFtjLCBvXSA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvdCA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmMgPSBjO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubyA9IG87XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRGF0ZVRpbWUgPSB0cnVlO1xuICB9XG5cbiAgLy8gQ09OU1RSVUNUXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZvciB0aGUgY3VycmVudCBpbnN0YW50LCBpbiB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKlxuICAgKiBVc2UgU2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vfj4gbm93IGluIHRoZSBJU08gZm9ybWF0XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhbCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGBsb2NhbCgpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoeyB6b25lOiBcIkFtZXJpY2EvTmV3X1lvcmtcIiB9KSAgICAgIC8vfj4gbm93LCBpbiBVUyBlYXN0IGNvYXN0IHRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMCwgd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIHsgem9uZTogXCJ1dGNcIiB9KSAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMCwgaW4gVVRDXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSkgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBsb2NhbCgpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGluIFVUQ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGB1dGMoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgdXRjKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG5cbiAgICBvcHRzLnpvbmUgPSBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU0RhdGUoZGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHMgPSBpc0RhdGUoZGF0ZSkgPyBkYXRlLnZhbHVlT2YoKSA6IE5hTjtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYGZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhICR7dHlwZW9mIG1pbGxpc2Vjb25kc30gd2l0aCB2YWx1ZSAke21pbGxpc2Vjb25kc31gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKHNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIoc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21TZWNvbmRzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHNlY29uZHMgKiAxMDAwLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcicgYW5kICdob3VyJyB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXIgLSBhIHllYXIsIHN1Y2ggYXMgMTk4N1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoIC0gYSBtb250aCwgMS0xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheSAtIGEgZGF5IG9mIHRoZSBtb250aCwgMS0zMSwgZGVwZW5kaW5nIG9uIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm9yZGluYWwgLSBkYXkgb2YgdGhlIHllYXIsIDEtMzY1IG9yIDM2NlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtZZWFyIC0gYW4gSVNPIHdlZWsgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtOdW1iZXIgLSBhbiBJU08gd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtkYXkgLSBhbiBJU08gd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gaW50ZXJwcmV0IHRoZSBudW1iZXJzIGluIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciB6b25lLiBDYW4gdGFrZSBhbnkgdmFsdWUgdGFrZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHNldFpvbmUoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiwgbW9udGg6IDUsIGRheTogMjV9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiB9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9KSAvL34+IHRvZGF5IGF0IDEwOjI2OjA2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ3V0YycgfSksXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgd2Vla1llYXI6IDIwMTYsIHdlZWtOdW1iZXI6IDIsIHdlZWtkYXk6IDMgfSkudG9JU09EYXRlKCkgLy89PiAnMjAxNi0wMS0xMydcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgb2Zmc2V0UHJvdmlzID0gIWlzVW5kZWZpbmVkKG9wdHMuc3BlY2lmaWNPZmZzZXQpXG4gICAgICAgID8gb3B0cy5zcGVjaWZpY09mZnNldFxuICAgICAgICA6IHpvbmVUb1VzZS5vZmZzZXQodHNOb3cpLFxuICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZVVuaXQpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcixcbiAgICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuXG4gICAgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlV2Vla0RhdGEgPSBkZWZpbml0ZVdlZWtEZWYgfHwgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3IpO1xuXG4gICAgLy8gY29uZmlndXJlIG91cnNlbHZlcyB0byBkZWFsIHdpdGggZ3JlZ29yaWFuIGRhdGVzIG9yIHdlZWsgc3R1ZmZcbiAgICBsZXQgdW5pdHMsXG4gICAgICBkZWZhdWx0VmFsdWVzLFxuICAgICAgb2JqTm93ID0gdHNUb09iaih0c05vdywgb2Zmc2V0UHJvdmlzKTtcbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VW5pdFZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG1pc3Npbmcgc3R1ZmZcbiAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdSBvZiB1bml0cykge1xuICAgICAgY29uc3QgdiA9IG5vcm1hbGl6ZWRbdV07XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZpcnN0KSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBkZWZhdWx0VmFsdWVzW3VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IG9iak5vd1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuICAgIGNvbnN0IGhpZ2hlck9yZGVySW52YWxpZCA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gaGFzSW52YWxpZFdlZWtEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gaGFzSW52YWxpZE9yZGluYWxEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEobm9ybWFsaXplZCksXG4gICAgICBpbnZhbGlkID0gaGlnaGVyT3JkZXJJbnZhbGlkIHx8IGhhc0ludmFsaWRUaW1lRGF0YShub3JtYWxpemVkKTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuICAgIGNvbnN0IGdyZWdvcmlhbiA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gd2Vla1RvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gb3JkaW5hbFRvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogbm9ybWFsaXplZCxcbiAgICAgIFt0c0ZpbmFsLCBvZmZzZXRGaW5hbF0gPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiB0c0ZpbmFsLFxuICAgICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgICBsb2MsXG4gICAgICB9KTtcblxuICAgIC8vIGdyZWdvcmlhbiBkYXRhICsgd2Vla2RheSBzZXJ2ZXMgb25seSB0byB2YWxpZGF0ZVxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICAgIFwibWlzbWF0Y2hlZCB3ZWVrZGF5XCIsXG4gICAgICAgIGB5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiAke25vcm1hbGl6ZWQud2Vla2RheX0gYW5kIGEgZGF0ZSBvZiAke2luc3QudG9JU08oKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VJU09EYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgdGhlIG9mZnNldCBpcyBhbHdheXMgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjM6MTIgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJ0ZyaSwgMjUgTm92IDIwMTYgMTM6MjM6MTIgKzA2MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjMgWicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21SRkMyODIyKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlUkZDMjgyMkRhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJSRkMgMjgyMlwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21IVFRQKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSFRUUERhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJIVFRQXCIsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gaW5wdXQgc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL3BhcnNpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSB0aGUgbGluayBiZWxvdyBmb3IgdGhlIGZvcm1hdHMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm10KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbUZvcm1hdCByZXF1aXJlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIGEgZm9ybWF0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0cyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBbdmFscywgcGFyc2VkWm9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRdID0gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgYGZvcm1hdCAke2ZtdH1gLCB0ZXh0LCBzcGVjaWZpY09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU1FMKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlU1FMKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRGF0ZVRpbWUgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGVUaW1lRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZVRpbWUuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0RhdGVUaW1lKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRGF0ZVRpbWUpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIGZvcm1hdCBzdHJpbmcgZm9yIGEgc2V0IG9mIG9wdGlvbnNcbiAgICogQHBhcmFtIGZvcm1hdE9wdHNcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBwYXJzZUZvcm1hdEZvck9wdHMoZm9ybWF0T3B0cywgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdG9rZW5MaXN0ID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gIXRva2VuTGlzdCA/IG51bGwgOiB0b2tlbkxpc3QubWFwKCh0KSA9PiAodCA/IHQudmFsIDogbnVsbCkpLmpvaW4oXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgdGhlIGZ1bGx5IGV4cGFuZGVkIGZvcm1hdCB0b2tlbiBmb3IgdGhlIGxvY2FsZVxuICAgKiBEb2VzIE5PVCBxdW90ZSBjaGFyYWN0ZXJzLCBzbyBxdW90ZWQgdG9rZW5zIHdpbGwgbm90IHJvdW5kIHRyaXAgY29ycmVjdGx5XG4gICAqIEBwYXJhbSBmbXRcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBleHBhbmRGb3JtYXQoZm10LCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkLm1hcCgodCkgPT4gdC52YWwpLmpvaW4oXCJcIik7XG4gIH1cblxuICAvLyBJTkZPXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ21vbnRoJyk7IC8vPT4gN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ2RheScpOyAvLz0+IDRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1t1bml0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWxlIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2VuLUdCJy4gVGhlIGxvY2FsZSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm91dHB1dENhbGVuZGFyIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbWUgem9uZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBEYXRlVGltZS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBnZXQgem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB6b25lTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLm5hbWUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkueWVhciAvLz0+IDIwMTdcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5jZWlsKHRoaXMuYy5tb250aCAvIDMpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkubW9udGggLy89PiA1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5tb250aCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgbW9udGggKDEtMzBpc2gpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuZGF5IC8vPT4gMjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3VyIG9mIHRoZSBkYXkgKDAtMjMpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuaG91ciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCkubWludXRlIC8vPT4gMzBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taW51dGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIpLnNlY29uZCAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCAoMC05OTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taWxsaXNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTIsIDMxKS53ZWVrWWVhciAvLz0+IDIwMTVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgKDEtNTJpc2gpLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLndlZWtOdW1iZXIgLy89PiAyMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMSwgMzEpLndlZWtkYXkgLy89PiA0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JkaW5hbCAobWVhbmluZyB0aGUgZGF5IG9mIHRoZSB5ZWFyKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkub3JkaW5hbCAvLz0+IDE0NVxuICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IG9yZGluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCBtb250aCBuYW1lLCBzdWNoIGFzICdPY3QnLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aFNob3J0IC8vPT4gT2N0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoTG9uZyAvLz0+IE9jdG9iZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aExvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IHdlZWtkYXksIHN1Y2ggYXMgJ01vbicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIHdlZWtkYXksIHN1Y2ggYXMgJ01vbmRheScuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlMb25nIC8vPT4gTW9uZGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheUxvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5vZmZzZXQgLy89PiAtMjQwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLm9mZnNldCAvLz0+IDBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICt0aGlzLm8gOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVTVFwiIG9yIFwiRURUXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVTaG9ydCgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwic2hvcnRcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb25nIGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIgb3IgXCJFYXN0ZXJuIERheWxpZ2h0IFRpbWVcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZUxvbmcoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcImxvbmdcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzT2Zmc2V0Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5pc1VuaXZlcnNhbCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luRFNUKCkge1xuICAgIGlmICh0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiAxLCBkYXk6IDEgfSkub2Zmc2V0IHx8XG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogNSB9KS5vZmZzZXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIERhdGVUaW1lIGlzIGluIGEgbGVhcCB5ZWFyLCBmYWxzZSBvdGhlcndpc2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuaXNJbkxlYXBZZWFyIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5pc0luTGVhcFllYXIgLy89PiBmYWxzZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luTGVhcFllYXIoKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgbW9udGhcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMikuZGF5c0luTW9udGggLy89PiAyOVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAzKS5kYXlzSW5Nb250aCAvLz0+IDMxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5c0luTW9udGgoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuZGF5c0luWWVhciAvLz0+IDM2NlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5kYXlzSW5ZZWFyIC8vPT4gMzY1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5c0luWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZGF5c0luWWVhcih0aGlzLnllYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAwNCkud2Vla3NJbldlZWtZZWFyIC8vPT4gNTNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykud2Vla3NJbldlZWtZZWFyIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrc0luV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHdlZWtzSW5XZWVrWWVhcih0aGlzLndlZWtZZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBJbnRsIG9wdGlvbnMgZm9yIHRoaXMgRGF0ZVRpbWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGJlaGF2aW9yIG9mIGZvcm1hdHRpbmcgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHRoZSBzYW1lIG9wdGlvbnMgYXMgdG9Mb2NhbGVTdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZWRMb2NhbGVPcHRpb25zKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBGb3JtYXR0ZXIuY3JlYXRlKFxuICAgICAgdGhpcy5sb2MuY2xvbmUob3B0cyksXG4gICAgICBvcHRzXG4gICAgKS5yZXNvbHZlZE9wdGlvbnModGhpcyk7XG4gICAgcmV0dXJuIHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyOiBjYWxlbmRhciB9O1xuICB9XG5cbiAgLy8gVFJBTlNGT1JNXG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBVVEMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0oJ3V0YycpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gb3B0aW9uYWxseSwgYW4gb2Zmc2V0IGZyb20gVVRDIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIG9wdGlvbnMgdG8gcGFzcyB0byBgc2V0Wm9uZSgpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvVVRDKG9mZnNldCA9IDAsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKG9mZnNldCksIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byB0aGUgaG9zdCdzIGxvY2FsIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgc2V0Wm9uZSgnbG9jYWwnKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b0xvY2FsKCkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBzcGVjaWZpZWQgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc2V0dGVyIGtlZXBzIHRoZSB1bmRlcmx5aW5nIHRpbWUgdGhlIHNhbWUgKGFzIGluLCB0aGUgc2FtZSB0aW1lc3RhbXApLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIHJlcG9ydCBkaWZmZXJlbnQgbG9jYWwgdGltZXMgYW5kIGNvbnNpZGVyIERTVHMgd2hlbiBtYWtpbmcgY29tcHV0YXRpb25zLCBhcyB3aXRoIHtAbGluayBEYXRlVGltZSNwbHVzfS4gWW91IG1heSB3aXNoIHRvIHVzZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0gYW5kIHtAbGluayBEYXRlVGltZSN0b1VUQ30gd2hpY2ggcHJvdmlkZSBzaW1wbGUgY29udmVuaWVuY2Ugd3JhcHBlcnMgZm9yIGNvbW1vbmx5IHVzZWQgem9uZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gYSB6b25lIGlkZW50aWZpZXIuIEFzIGEgc3RyaW5nLCB0aGF0IGNhbiBiZSBhbnkgSUFOQSB6b25lIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBmaXhlZC1vZmZzZXQgbmFtZSBvZiB0aGUgZm9ybSAnVVRDKzMnLCBvciB0aGUgc3RyaW5ncyAnbG9jYWwnIG9yICd1dGMnLiBZb3UgbWF5IGFsc28gc3VwcGx5IGFuIGluc3RhbmNlIG9mIGEge0BsaW5rIERhdGVUaW1lI1pvbmV9IGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5rZWVwTG9jYWxUaW1lPWZhbHNlXSAtIElmIHRydWUsIGFkanVzdCB0aGUgdW5kZXJseWluZyB0aW1lIHNvIHRoYXQgdGhlIGxvY2FsIHRpbWUgc3RheXMgdGhlIHNhbWUsIGJ1dCBpbiB0aGUgdGFyZ2V0IHpvbmUuIFlvdSBzaG91bGQgcmFyZWx5IG5lZWQgdGhpcy5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRab25lKHpvbmUsIHsga2VlcExvY2FsVGltZSA9IGZhbHNlLCBrZWVwQ2FsZW5kYXJUaW1lID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgem9uZSA9IG5vcm1hbGl6ZVpvbmUoem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLnpvbmUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdUUyA9IHRoaXMudHM7XG4gICAgICBpZiAoa2VlcExvY2FsVGltZSB8fCBrZWVwQ2FsZW5kYXJUaW1lKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGNvbnN0IGFzT2JqID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgICBbbmV3VFNdID0gb2JqVG9UUyhhc09iaiwgb2Zmc2V0R3Vlc3MsIHpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHM6IG5ld1RTLCB6b25lIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3Igb3V0cHV0Q2FsZW5kYXIuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSB0aGUgcHJvcGVydGllcyB0byBzZXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5sb2MuY2xvbmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgbG9jIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBKdXN0IGEgY29udmVuaWVudCBhbGlhcyBmb3IgcmVjb25maWd1cmUoeyBsb2NhbGUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnNldExvY2FsZSgnZW4tR0InKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIFlvdSBjYW4gb25seSBzZXQgdW5pdHMgd2l0aCB0aGlzIG1ldGhvZDsgZm9yIFwic2V0dGluZ1wiIG1ldGFkYXRhLCBzZWUge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSBhbmQge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3QodmFsdWVzLCBub3JtYWxpemVVbml0KSxcbiAgICAgIHNldHRpbmdXZWVrU3R1ZmYgPVxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrWWVhcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla051bWJlcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla2RheSksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGxldCBtaXhlZDtcbiAgICBpZiAoc2V0dGluZ1dlZWtTdHVmZikge1xuICAgICAgbWl4ZWQgPSB3ZWVrVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub1dlZWsodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpKSB7XG4gICAgICBtaXhlZCA9IG9yZGluYWxUb0dyZWdvcmlhbih7IC4uLmdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLCAuLi5ub3JtYWxpemVkIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXhlZCA9IHsgLi4udGhpcy50b09iamVjdCgpLCAuLi5ub3JtYWxpemVkIH07XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBzZXQgdGhlIGRheSBidXQgd2UgZW5kZWQgdXAgb24gYW4gb3ZlcmZsb3cgZGF0ZSxcbiAgICAgIC8vIHVzZSB0aGUgbGFzdCBkYXkgb2YgdGhlIHJpZ2h0IG1vbnRoXG4gICAgICBpZiAoaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpKSB7XG4gICAgICAgIG1peGVkLmRheSA9IE1hdGgubWluKGRheXNJbk1vbnRoKG1peGVkLnllYXIsIG1peGVkLm1vbnRoKSwgbWl4ZWQuZGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbdHMsIG9dID0gb2JqVG9UUyhtaXhlZCwgdGhpcy5vLCB0aGlzLnpvbmUpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzLCBvIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKDEyMykgLy9+PiBpbiAxMjMgbWlsbGlzZWNvbmRzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBtaW51dGVzOiAxNSB9KSAvL34+IGluIDE1IG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IC0xIH0pIC8vfj4gdGhpcyB0aW1lIHllc3RlcmRheVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0IGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNwbHVzfVxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbikubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSB1bml0IG9mIHRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGJlZ2lubmluZyBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignbW9udGgnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZigneWVhcicpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd3ZWVrJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDMnLCB3ZWVrcyBhbHdheXMgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignZGF5JykudG9JU09UaW1lKCk7IC8vPT4gJzAwOjAwLjAwMC0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2hvdXInKS50b0lTT1RpbWUoKTsgLy89PiAnMDU6MDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXJ0T2YodW5pdCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBvID0ge30sXG4gICAgICBub3JtYWxpemVkVW5pdCA9IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCk7XG4gICAgc3dpdGNoIChub3JtYWxpemVkVW5pdCkge1xuICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgIG8ubW9udGggPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInF1YXJ0ZXJzXCI6XG4gICAgICBjYXNlIFwibW9udGhzXCI6XG4gICAgICAgIG8uZGF5ID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgby5ob3VyID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICBvLm1pbnV0ZSA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBvLnNlY29uZCA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICBvLm1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gbm8gZGVmYXVsdCwgaW52YWxpZCB1bml0cyB0aHJvdyBpbiBub3JtYWxpemVVbml0KClcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwid2Vla3NcIikge1xuICAgICAgby53ZWVrZGF5ID0gMTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwicXVhcnRlcnNcIikge1xuICAgICAgY29uc3QgcSA9IE1hdGguY2VpbCh0aGlzLm1vbnRoIC8gMyk7XG4gICAgICBvLm1vbnRoID0gKHEgLSAxKSAqIDMgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldChvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGVuZCAobWVhbmluZyB0aGUgbGFzdCBtaWxsaXNlY29uZCkgb2YgYSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgZW5kIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignbW9udGgnKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3llYXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTEyLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3dlZWsnKS50b0lTTygpOyAvLyA9PiAnMjAxNC0wMy0wOVQyMzo1OTo1OS45OTktMDU6MDAnLCB3ZWVrcyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignZGF5JykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignaG91cicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMDU6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIGVuZE9mKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHRoaXMucGx1cyh7IFt1bml0XTogMSB9KVxuICAgICAgICAgIC5zdGFydE9mKHVuaXQpXG4gICAgICAgICAgLm1pbnVzKDEpXG4gICAgICA6IHRoaXM7XG4gIH1cblxuICAvLyBPVVRQVVRcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlIGZvcm1hdHRpbmcgdG9vbC4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvZm9ybWF0dGluZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgQXByIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2ZyJykudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnLCB7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJISCAnaG91cnMgYW5kJyBtbSAnbWludXRlcydcIikgLy89PiAnMjAgaG91cnMgYW5kIDU1IG1pbnV0ZXMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZGF0ZS4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzIGBEYXRlVGltZS5EQVRFX0ZVTExgIG9yIGBEYXRlVGltZS5USU1FX1NJTVBMRWAuXG4gICAqIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvblxuICAgKiBvZiB0aGUgRGF0ZVRpbWUgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdE9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+ICdBcHJpbCAyMCwgMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyJyB9KTsgLy89PiAnMjggYW/Du3QgMjAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+ICcxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfU0hPUlQpOyAvLz0+ICc0LzIwLzIwMTcsIDExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdsb25nJywgbW9udGg6ICdsb25nJywgZGF5OiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodXJzZGF5LCBBcHJpbCAyMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodSwgQXByIDIwLCAxMToyNyBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnLCBob3VyQ3ljbGU6ICdoMjMnIH0pOyAvLz0+ICcxMTozMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXREYXRlVGltZSh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0IFwicGFydHNcIiwgbWVhbmluZyBpbmRpdmlkdWFsIHRva2VucyBhbG9uZyB3aXRoIG1ldGFkYXRhLiBUaGlzIGlzIGFsbG93cyBjYWxsZXJzIHRvIHBvc3QtcHJvY2VzcyBpbmRpdmlkdWFsIHNlY3Rpb25zIG9mIHRoZSBmb3JtYXR0ZWQgb3V0cHV0LlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdC9mb3JtYXRUb1BhcnRzXG4gICAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLCBzYW1lIGFzIGB0b0xvY2FsZVN0cmluZ2AuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlUGFydHMoKTsgLy89PiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnZGF5JywgdmFsdWU6ICcyNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ21vbnRoJywgdmFsdWU6ICcwNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ3llYXInLCB2YWx1ZTogJzE5ODInIH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gXVxuICAgKi9cbiAgdG9Mb2NhbGVQYXJ0cyhvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lUGFydHModGhpcylcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPWZhbHNlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgzLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oe1xuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCI7XG5cbiAgICBsZXQgYyA9IHRvSVNPRGF0ZSh0aGlzLCBleHQpO1xuICAgIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUodGhpcywgZXh0LCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0LCBleHRlbmRlZFpvbmUpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgZGF0ZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzE5ODIwNTI1J1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoeyBmb3JtYXQgPSBcImV4dGVuZGVkXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3Mgd2VlayBkYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09XZWVrRGF0ZSgpIC8vPT4gJzE5ODItVzIxLTInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPV2Vla0RhdGUoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcImtra2stJ1cnV1ctY1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHRpbWUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT10cnVlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGMgPSBpbmNsdWRlUHJlZml4ID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICAgIGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIGV4dGVuZGVkWm9uZVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBSRkMgMjgyMi1jb21wYXRpYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCArMDAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgLTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvUkZDMjgyMigpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyBaWlpcIiwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEhUVFAgaGVhZGVycy4gVGhlIG91dHB1dCBpcyBhbHdheXMgZXhwcmVzc2VkIGluIEdNVC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgc3RyaW5nIGNvbmZvcm1zIHRvIFJGQyAxMTIzLlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgR01UJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMsIDE5KS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDE5OjAwOjAwIEdNVCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9IVFRQKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcy50b1VUQygpLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgJ0dNVCdcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTERhdGUoKSAvLz0+ICcyMDE0LTA3LTEzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTERhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVab25lOiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxUaW1lKHsgaW5jbHVkZU9mZnNldCA9IHRydWUsIGluY2x1ZGVab25lID0gZmFsc2UsIGluY2x1ZGVPZmZzZXRTcGFjZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGZtdCA9IFwiSEg6bW06c3MuU1NTXCI7XG5cbiAgICBpZiAoaW5jbHVkZVpvbmUgfHwgaW5jbHVkZU9mZnNldCkge1xuICAgICAgaWYgKGluY2x1ZGVPZmZzZXRTcGFjZSkge1xuICAgICAgICBmbXQgKz0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICAgICAgZm10ICs9IFwielwiO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICAgIGZtdCArPSBcIlpaXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IHRydWUgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUwob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnRvU1FMRGF0ZSgpfSAke3RoaXMudG9TUUxUaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9JU08oKSA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuIEFsaWFzIG9mIHtAbGluayBEYXRlVGltZSN0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50cyAvIDEwMDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyAoYXMgYSB3aG9sZSBudW1iZXIpIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvVW5peEludGVnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguZmxvb3IodGhpcy50cyAvIDEwMDApIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCU09OIHNlcmlhbGl6YWJsZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU0RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIERhdGVUaW1lJ3MgeWVhciwgbW9udGgsIGRheSwgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVDb25maWc9ZmFsc2VdIC0gaW5jbHVkZSBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgaW4gdGhlIG91dHB1dFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b09iamVjdCgpIC8vPT4geyB5ZWFyOiAyMDE3LCBtb250aDogNCwgZGF5OiAyMiwgaG91cjogMjAsIG1pbnV0ZTogNDksIHNlY29uZDogNDIsIG1pbGxpc2Vjb25kOiAyNjggfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgYmFzZSA9IHsgLi4udGhpcy5jIH07XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9KU0RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU4pO1xuICB9XG5cbiAgLy8gQ09NUEFSRVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gRGF0ZVRpbWVzIGFzIGEgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgRGF0ZVRpbWUgdG8gY29tcGFyZSB0aGlzIG9uZSB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciBhcnJheSBvZiB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaTEgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgyLTA1LTI1VDA5OjQ1JyksXG4gICAqICAgICBpMiA9IERhdGVUaW1lLmZyb21JU08oJzE5ODMtMTAtMTRUMTA6MzAnKTtcbiAgICogaTIuZGlmZihpMSkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA0MzgwNzUwMDAwMCB9XG4gICAqIGkyLmRpZmYoaTEsICdob3VycycpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMjE2OC43NSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTkuMDMxMjUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LCBob3VyczogMC43NSB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZihvdGhlckRhdGVUaW1lLCB1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJPcHRzID0geyBsb2NhbGU6IHRoaXMubG9jYWxlLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCAuLi5vcHRzIH07XG5cbiAgICBjb25zdCB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgb3RoZXJJc0xhdGVyID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCkgPiB0aGlzLnZhbHVlT2YoKSxcbiAgICAgIGVhcmxpZXIgPSBvdGhlcklzTGF0ZXIgPyB0aGlzIDogb3RoZXJEYXRlVGltZSxcbiAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICBkaWZmZWQgPSBkaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIHJpZ2h0IG5vdy5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNkaWZmfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZk5vdyh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZihEYXRlVGltZS5ub3coKSwgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHNwYW5uaW5nIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgYW5vdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIGVuZCBwb2ludCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bnRpbChvdGhlckRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEludGVydmFsLmZyb21EYXRlVGltZXModGhpcywgb3RoZXJEYXRlVGltZSkgOiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgRGF0ZVRpbWUgaXMgaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lIGFzIGFub3RoZXIgRGF0ZVRpbWUuXG4gICAqIEhpZ2hlci1vcmRlciB1bml0cyBtdXN0IGFsc28gYmUgaWRlbnRpY2FsIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiBgdHJ1ZWAuXG4gICAqIE5vdGUgdGhhdCB0aW1lIHpvbmVzIGFyZSAqKmlnbm9yZWQqKiBpbiB0aGlzIGNvbXBhcmlzb24sIHdoaWNoIGNvbXBhcmVzIHRoZSAqKmxvY2FsKiogY2FsZW5kYXIgdGltZS4gVXNlIHtAbGluayBEYXRlVGltZSNzZXRab25lfSB0byBjb252ZXJ0IG9uZSBvZiB0aGUgZGF0ZXMgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmIGFuZCBvbmx5IGlmIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG1pbGxpc2Vjb25kLCBoYXZlIHRoZSBzYW1lIHpvbmUgYW5kIGxvY2F0aW9uLCBhbmQgYXJlIGJvdGggdmFsaWQuXG4gICAqIFRvIGNvbXBhcmUganVzdCB0aGUgbWlsbGlzZWNvbmQgdmFsdWVzLCB1c2UgYCtkdDEgPT09ICtkdDJgLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlciAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNWYWxpZCAmJlxuICAgICAgb3RoZXIuaXNWYWxpZCAmJlxuICAgICAgdGhpcy52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKSAmJlxuICAgICAgdGhpcy56b25lLmVxdWFscyhvdGhlci56b25lKSAmJlxuICAgICAgdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0aGlzIHRpbWUgcmVsYXRpdmUgdG8gbm93LCBzdWNoIGFzIFwiaW4gdHdvIGRheXNcIi4gQ2FuIG9ubHkgaW50ZXJuYXRpb25hbGl6ZSBpZiB5b3VyXG4gICAqIHBsYXRmb3JtIHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LiBSb3VuZHMgZG93biBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3R5bGU9XCJsb25nXCJdIC0gdGhlIHN0eWxlIG9mIHVuaXRzLCBtdXN0IGJlIFwibG9uZ1wiLCBcInNob3J0XCIsIG9yIFwibmFycm93XCJcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHM7IGlmIG9taXR0ZWQsIG9yIGFuIGFycmF5LCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgYmVzdCB1bml0LiBVc2UgYW4gYXJyYXkgb3Igb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBvciBcInNlY29uZHNcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkZGluZz0wXSAtIHBhZGRpbmcgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGFsbG93cyB5b3UgdG8gcm91bmQgdXAgdGhlIHJlc3VsdCBpZiBpdCBmaXRzIGluc2lkZSB0aGUgdGhyZXNob2xkLiBEb24ndCB1c2UgaW4gY29tYmluYXRpb24gd2l0aCB7cm91bmQ6IGZhbHNlfSBiZWNhdXNlIHRoZSBkZWNpbWFsIG91dHB1dCB3aWxsIGluY2x1ZGUgdGhlIHBhZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiaW4gMSBkYXlcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS50b1JlbGF0aXZlKHsgZGF5czogMSB9KSAvLz0+IFwiZGVudHJvIGRlIDEgZMOtYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGFucyAyMyBoZXVyZXNcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoeyB1bml0OiBcImhvdXJzXCIgfSkgLy89PiBcIjQ4IGhvdXJzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgaG91cnM6IDM2IH0pLnRvUmVsYXRpdmUoeyByb3VuZDogZmFsc2UgfSkgLy89PiBcIjEuNSBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBiYXNlID0gb3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyA/ICh0aGlzIDwgYmFzZSA/IC1vcHRpb25zLnBhZGRpbmcgOiBvcHRpb25zLnBhZGRpbmcpIDogMDtcbiAgICBsZXQgdW5pdHMgPSBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdO1xuICAgIGxldCB1bml0ID0gb3B0aW9ucy51bml0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudW5pdCkpIHtcbiAgICAgIHVuaXRzID0gb3B0aW9ucy51bml0O1xuICAgICAgdW5pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShiYXNlLCB0aGlzLnBsdXMocGFkZGluZyksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImFsd2F5c1wiLFxuICAgICAgdW5pdHMsXG4gICAgICB1bml0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlIHJlbGF0aXZlIHRvIHRvZGF5LCBzdWNoIGFzIFwieWVzdGVyZGF5XCIgb3IgXCJuZXh0IG1vbnRoXCIuXG4gICAqIE9ubHkgaW50ZXJuYXRpb25hbGl6ZXMgb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdDsgaWYgb21pdHRlZCwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIHVuaXQuIFVzZSBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgb3IgXCJkYXlzXCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwidG9tb3Jyb3dcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcIlwibWHDsWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIiwgIi8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBRdWVyeSBTZXR0aW5ncyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeVNldHRpbmdzIHtcbiAgICAvKiogV2hhdCB0byByZW5kZXIgJ251bGwnIGFzIGluIHRhYmxlcy4gRGVmYXVsdHMgdG8gJy0nLiAqL1xuICAgIHJlbmRlck51bGxBczogc3RyaW5nO1xuICAgIC8qKiBJZiBlbmFibGVkLCB0YXNrcyBpbiBEYXRhdmlldyB2aWV3cyB3aWxsIGF1dG9tYXRpY2FsbHkgaGF2ZSB0aGVpciBjb21wbGV0aW9uIGRhdGUgYXBwZW5kZWQgd2hlbiB0aGV5IGFyZSBjaGVja2VkLiAqL1xuICAgIHRhc2tDb21wbGV0aW9uVHJhY2tpbmc6IGJvb2xlYW47XG4gICAgLyoqIElmIGVuYWJsZWQsIGF1dG9tYXRpYyBjb21wbGV0aW9ucyB3aWxsIHVzZSBlbW9qaSBzaG9ydGhhbmQg4pyFIFlZWVktTU0tREQgaW5zdGVhZCBvZiBbY29tcGxldGlvbjo6IGRhdGVdLiAqL1xuICAgIHRhc2tDb21wbGV0aW9uVXNlRW1vamlTaG9ydGhhbmQ6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgZmllbGQgdG8gYmUgYWRkZWQgYXMgYSB0YXNrJ3MgY29tcGxldGlvbiB3aGVuIGNoZWNrZWQuIE9ubHkgdXNlZCBpZiBjb21wbGV0aW9uVHJhY2tpbmcgaXMgZW5hYmxlZCBhbmQgZW1vamlTaG9ydGhhbmQgaXMgbm90LiAqL1xuICAgIHRhc2tDb21wbGV0aW9uVGV4dDogc3RyaW5nO1xuICAgIC8qKiBEYXRlIGZvcm1hdCBvZiB0aGUgdGFzaydzIGNvbXBsZXRpb24gdGltZXN0YW1wLiBPbmx5IHVzZWQgaWYgY29tcGxldGlvblRyYWNraW5nIGlzIGVuYWJsZWQgYW5kIGVtb2ppU2hvcnRoYW5kIGlzIG5vdC4gKi9cbiAgICB0YXNrQ29tcGxldGlvbkRhdGVGb3JtYXQ6IHN0cmluZztcbiAgICAvKiogV2hldGhlciBvciBub3Qgc3VidGFza3Mgc2hvdWxkIGJlIHJlY3Vyc2l2ZWx5IGNvbXBsZXRlZCBpbiBhZGRpdGlvbiB0byB0aGVpciBwYXJlbnQgdGFzay4gKi9cbiAgICByZWN1cnNpdmVTdWJUYXNrQ29tcGxldGlvbjogYm9vbGVhbjtcbiAgICAvKiogSWYgdHJ1ZSwgcmVuZGVyIGEgbW9kYWwgd2hpY2ggc2hvd3Mgbm8gcmVzdWx0cyB3ZXJlIHJldHVybmVkLiAqL1xuICAgIHdhcm5PbkVtcHR5UmVzdWx0OiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBhdXRvbWF0aWMgdmlldyByZWZyZXNoaW5nIGlzIGVuYWJsZWQuICovXG4gICAgcmVmcmVzaEVuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBpbnRlcnZhbCB0aGF0IHZpZXdzIGFyZSByZWZyZXNoZWQsIGJ5IGRlZmF1bHQuICovXG4gICAgcmVmcmVzaEludGVydmFsOiBudW1iZXI7XG4gICAgLyoqIFRoZSBkZWZhdWx0IGZvcm1hdCB0aGF0IGRhdGVzIGFyZSByZW5kZXJlZCBpbiAodXNpbmcgbHV4b24ncyBtb21lbnQtbGlrZSBmb3JtYXR0aW5nKS4gKi9cbiAgICBkZWZhdWx0RGF0ZUZvcm1hdDogc3RyaW5nO1xuICAgIC8qKiBUaGUgZGVmYXVsdCBmb3JtYXQgdGhhdCBkYXRlLXRpbWVzIGFyZSByZW5kZXJlZCBpbiAodXNpbmcgbHV4b25zIG1vbWVudC1saWtlIGZvcm1hdHRpbmcpLiAqL1xuICAgIGRlZmF1bHREYXRlVGltZUZvcm1hdDogc3RyaW5nO1xuICAgIC8qKiBNYXhpbXVtIGRlcHRoIHRoYXQgb2JqZWN0cyB3aWxsIGJlIGV4cGFuZGVkIHdoZW4gYmVpbmcgcmVuZGVyZWQgcmVjdXJzaXZlbHkuICovXG4gICAgbWF4UmVjdXJzaXZlUmVuZGVyRGVwdGg6IG51bWJlcjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgSUQgZmllbGQgKCdGaWxlJykuICovXG4gICAgdGFibGVJZENvbHVtbk5hbWU6IHN0cmluZztcbiAgICAvKiogVGhlIG5hbWUgb2YgZGVmYXVsdCBJRCBmaWVsZHMgb24gZ3JvdXBlZCBkYXRhICgnR3JvdXAnKS4gKi9cbiAgICB0YWJsZUdyb3VwQ29sdW1uTmFtZTogc3RyaW5nO1xuICAgIC8qKiBJbmNsdWRlIHRoZSByZXN1bHQgY291bnQgYXMgcGFydCBvZiB0aGUgb3V0cHV0LiAqL1xuICAgIHNob3dSZXN1bHRDb3VudDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUVVFUllfU0VUVElOR1M6IFF1ZXJ5U2V0dGluZ3MgPSB7XG4gICAgcmVuZGVyTnVsbEFzOiBcIlxcXFwtXCIsXG4gICAgdGFza0NvbXBsZXRpb25UcmFja2luZzogZmFsc2UsXG4gICAgdGFza0NvbXBsZXRpb25Vc2VFbW9qaVNob3J0aGFuZDogZmFsc2UsXG4gICAgdGFza0NvbXBsZXRpb25UZXh0OiBcImNvbXBsZXRpb25cIixcbiAgICB0YXNrQ29tcGxldGlvbkRhdGVGb3JtYXQ6IFwieXl5eS1NTS1kZFwiLFxuICAgIHJlY3Vyc2l2ZVN1YlRhc2tDb21wbGV0aW9uOiBmYWxzZSxcbiAgICB3YXJuT25FbXB0eVJlc3VsdDogdHJ1ZSxcbiAgICByZWZyZXNoRW5hYmxlZDogdHJ1ZSxcbiAgICByZWZyZXNoSW50ZXJ2YWw6IDI1MDAsXG4gICAgZGVmYXVsdERhdGVGb3JtYXQ6IFwiTU1NTSBkZCwgeXl5eVwiLFxuICAgIGRlZmF1bHREYXRlVGltZUZvcm1hdDogXCJoOm1tIGEgLSBNTU1NIGRkLCB5eXl5XCIsXG4gICAgbWF4UmVjdXJzaXZlUmVuZGVyRGVwdGg6IDQsXG5cbiAgICB0YWJsZUlkQ29sdW1uTmFtZTogXCJGaWxlXCIsXG4gICAgdGFibGVHcm91cENvbHVtbk5hbWU6IFwiR3JvdXBcIixcbiAgICBzaG93UmVzdWx0Q291bnQ6IHRydWUsXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydCBTZXR0aW5ncyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwb3J0U2V0dGluZ3Mge1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBIVE1MIHNob3VsZCBiZSB1c2VkIGZvciBmb3JtYXR0aW5nIGluIGV4cG9ydHMuICovXG4gICAgYWxsb3dIdG1sOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWFBPUlRfU0VUVElOR1M6IEV4cG9ydFNldHRpbmdzID0ge1xuICAgIGFsbG93SHRtbDogdHJ1ZSxcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdlbmVyYWwgRGF0YXZpZXcgU2V0dGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhdmlld1NldHRpbmdzIGV4dGVuZHMgUXVlcnlTZXR0aW5ncywgRXhwb3J0U2V0dGluZ3Mge1xuICAgIC8qKiBUaGUgcHJlZml4IGZvciBpbmxpbmUgcXVlcmllcyBieSBkZWZhdWx0LiAqL1xuICAgIGlubGluZVF1ZXJ5UHJlZml4OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBwcmVmaXggZm9yIGlubGluZSBKUyBxdWVyaWVzIGJ5IGRlZmF1bHQuICovXG4gICAgaW5saW5lSnNRdWVyeVByZWZpeDogc3RyaW5nO1xuICAgIC8qKiBJZiB0cnVlLCBpbmxpbmUgcXVlcmllcyBhcmUgYWxzbyBldmFsdWF0ZWQgaW4gZnVsbCBjb2RlYmxvY2tzLiAqL1xuICAgIGlubGluZVF1ZXJpZXNJbkNvZGVibG9ja3M6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIGV4ZWN1dGluZyBEYXRhdmlld0pTIHF1ZXJpZXMuICovXG4gICAgZW5hYmxlRGF0YXZpZXdKczogYm9vbGVhbjtcbiAgICAvKiogRW5hYmxlIG9yIGRpc2FibGUgcmVndWxhciBpbmxpbmUgcXVlcmllcy4gKi9cbiAgICBlbmFibGVJbmxpbmVEYXRhdmlldzogYm9vbGVhbjtcbiAgICAvKiogRW5hYmxlIG9yIGRpc2FibGUgZXhlY3V0aW5nIGlubGluZSBEYXRhdmlld0pTIHF1ZXJpZXMuICovXG4gICAgZW5hYmxlSW5saW5lRGF0YXZpZXdKczogYm9vbGVhbjtcbiAgICAvKiogRW5hYmxlIG9yIGRpc2FibGUgcmVuZGVyaW5nIGlubGluZSBmaWVsZHMgcHJldHRpbHkuICovXG4gICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzOiBib29sZWFuO1xuICAgIC8qKiBUaGUga2V5d29yZCBmb3IgRGF0YXZpZXdKUyBibG9ja3MuICovXG4gICAgZGF0YXZpZXdKc0tleXdvcmQ6IHN0cmluZztcbn1cblxuLyoqIERlZmF1bHQgc2V0dGluZ3MgZm9yIGRhdGF2aWV3IG9uIGluc3RhbGwuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogRGF0YXZpZXdTZXR0aW5ncyA9IHtcbiAgICAuLi5ERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgIC4uLkRFRkFVTFRfRVhQT1JUX1NFVFRJTkdTLFxuICAgIC4uLntcbiAgICAgICAgaW5saW5lUXVlcnlQcmVmaXg6IFwiPVwiLFxuICAgICAgICBpbmxpbmVKc1F1ZXJ5UHJlZml4OiBcIiQ9XCIsXG4gICAgICAgIGlubGluZVF1ZXJpZXNJbkNvZGVibG9ja3M6IHRydWUsXG4gICAgICAgIGVuYWJsZUlubGluZURhdGF2aWV3OiB0cnVlLFxuICAgICAgICBlbmFibGVEYXRhdmlld0pzOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlSW5saW5lRGF0YXZpZXdKczogZmFsc2UsXG4gICAgICAgIHByZXR0eVJlbmRlcklubGluZUZpZWxkczogdHJ1ZSxcbiAgICAgICAgZGF0YXZpZXdKc0tleXdvcmQ6IFwiZGF0YXZpZXdqc1wiLFxuICAgIH0sXG59O1xuIiwgIi8qKiBGdW5jdGlvbmFsIHJldHVybiB0eXBlIGZvciBlcnJvciBoYW5kbGluZy4gKi9cbmV4cG9ydCBjbGFzcyBTdWNjZXNzPFQsIEU+IHtcbiAgICBwdWJsaWMgc3VjY2Vzc2Z1bDogdHJ1ZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFQpIHtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwPFU+KGY6IChhOiBUKSA9PiBVKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGYodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmbGF0TWFwPFU+KGY6IChhOiBUKSA9PiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT4ge1xuICAgICAgICByZXR1cm4gZih0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwRXJyPFU+KGY6IChlOiBFKSA9PiBVKTogUmVzdWx0PFQsIFU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55IGFzIFJlc3VsdDxULCBVPjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmltYXA8VDIsIEUyPihzdWNjOiAoYTogVCkgPT4gVDIsIF9mYWlsOiAoYjogRSkgPT4gRTIpOiBSZXN1bHQ8VDIsIEUyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChzdWNjKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcHVibGljIG9yRWxzZShfdmFsdWU6IFQpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNhc3Q8VT4oKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2VUaHJvdyhfbWVzc2FnZT86IChlOiBFKSA9PiBzdHJpbmcpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuXG4vKiogRnVuY3Rpb25hbCByZXR1cm4gdHlwZSBmb3IgZXJyb3IgaGFuZGxpbmcuICovXG5leHBvcnQgY2xhc3MgRmFpbHVyZTxULCBFPiB7XG4gICAgcHVibGljIHN1Y2Nlc3NmdWw6IGZhbHNlO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBlcnJvcjogRSkge1xuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwPFU+KF9mOiAoYTogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBGYWlsdXJlPFUsIEU+O1xuICAgIH1cblxuICAgIHB1YmxpYyBmbGF0TWFwPFU+KF9mOiAoYTogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55IGFzIEZhaWx1cmU8VSwgRT47XG4gICAgfVxuXG4gICAgcHVibGljIG1hcEVycjxVPihmOiAoZTogRSkgPT4gVSk6IFJlc3VsdDxULCBVPiB7XG4gICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShmKHRoaXMuZXJyb3IpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmltYXA8VDIsIEUyPihfc3VjYzogKGE6IFQpID0+IFQyLCBmYWlsOiAoYjogRSkgPT4gRTIpOiBSZXN1bHQ8VDIsIEUyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVycihmYWlsKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcHVibGljIG9yRWxzZSh2YWx1ZTogVCk6IFQge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNhc3Q8VT4oKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2VUaHJvdyhtZXNzYWdlPzogKGU6IEUpID0+IHN0cmluZyk6IFQge1xuICAgICAgICBpZiAobWVzc2FnZSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UodGhpcy5lcnJvcikpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlwiICsgdGhpcy5lcnJvcik7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBSZXN1bHQ8VCwgRT4gPSBTdWNjZXNzPFQsIEU+IHwgRmFpbHVyZTxULCBFPjtcblxuLyoqIE1vbmFkaWMgJ1Jlc3VsdCcgdHlwZSB3aGljaCBlbmNhcHN1bGF0ZXMgd2hldGhlciBhIHByb2NlZHVyZSBzdWNjZWVkZWQgb3IgZmFpbGVkLCBhcyB3ZWxsIGFzIGl0J3MgcmV0dXJuIHZhbHVlLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBSZXN1bHQge1xuICAgIC8qKiBDb25zdHJ1Y3QgYSBuZXcgc3VjY2VzcyByZXN1bHQgd3JhcHBpbmcgdGhlIGdpdmVuIHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBzdWNjZXNzPFQsIEU+KHZhbHVlOiBUKTogUmVzdWx0PFQsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogQ29uc3RydWN0IGEgbmV3IGZhaWx1cmUgdmFsdWUgd3JhcHBpbmcgdGhlIGdpdmVuIGVycm9yLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBmYWlsdXJlPFQsIEU+KGVycm9yOiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGVycm9yKTtcbiAgICB9XG5cbiAgICAvKiogSm9pbiB0d28gcmVzdWx0cyB3aXRoIGEgYmktZnVuY3Rpb24gYW5kIHJldHVybiBhIG5ldyByZXN1bHQuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZsYXRNYXAyPFQxLCBUMiwgTywgRT4oXG4gICAgICAgIGZpcnN0OiBSZXN1bHQ8VDEsIEU+LFxuICAgICAgICBzZWNvbmQ6IFJlc3VsdDxUMiwgRT4sXG4gICAgICAgIGY6IChhOiBUMSwgYjogVDIpID0+IFJlc3VsdDxPLCBFPlxuICAgICk6IFJlc3VsdDxPLCBFPiB7XG4gICAgICAgIGlmIChmaXJzdC5zdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kLnN1Y2Nlc3NmdWwpIHJldHVybiBmKGZpcnN0LnZhbHVlLCBzZWNvbmQudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFpbHVyZShzZWNvbmQuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmUoZmlyc3QuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEpvaW4gdHdvIHJlc3VsdHMgd2l0aCBhIGJpLWZ1bmN0aW9uIGFuZCByZXR1cm4gYSBuZXcgcmVzdWx0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBtYXAyPFQxLCBUMiwgTywgRT4oXG4gICAgICAgIGZpcnN0OiBSZXN1bHQ8VDEsIEU+LFxuICAgICAgICBzZWNvbmQ6IFJlc3VsdDxUMiwgRT4sXG4gICAgICAgIGY6IChhOiBUMSwgYjogVDIpID0+IE9cbiAgICApOiBSZXN1bHQ8TywgRT4ge1xuICAgICAgICByZXR1cm4gZmxhdE1hcDIoZmlyc3QsIHNlY29uZCwgKGEsIGIpID0+IHN1Y2Nlc3MoZihhLCBiKSkpO1xuICAgIH1cbn1cbiIsICIhZnVuY3Rpb24obix0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlBhcnNpbW1vbj10KCk6bi5QYXJzaW1tb249dCgpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHQ9e307ZnVuY3Rpb24gcihlKXtpZih0W2VdKXJldHVybiB0W2VdLmV4cG9ydHM7dmFyIHU9dFtlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIG5bZV0uY2FsbCh1LmV4cG9ydHMsdSx1LmV4cG9ydHMsciksdS5sPSEwLHUuZXhwb3J0c31yZXR1cm4gci5tPW4sci5jPXQsci5kPWZ1bmN0aW9uKG4sdCxlKXtyLm8obix0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OmV9KX0sci5yPWZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLm49ZnVuY3Rpb24obil7dmFyIHQ9biYmbi5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gbn07cmV0dXJuIHIuZCh0LFwiYVwiLHQpLHR9LHIubz1mdW5jdGlvbihuLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobix0KX0sci5wPVwiXCIscihyLnM9MCl9KFtmdW5jdGlvbihuLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShuKXtpZighKHRoaXMgaW5zdGFuY2VvZiBlKSlyZXR1cm4gbmV3IGUobik7dGhpcy5fPW59dmFyIHU9ZS5wcm90b3R5cGU7ZnVuY3Rpb24gbyhuLHQpe2Zvcih2YXIgcj0wO3I8bjtyKyspdChyKX1mdW5jdGlvbiBpKG4sdCxyKXtyZXR1cm4gZnVuY3Rpb24obix0KXtvKHQubGVuZ3RoLGZ1bmN0aW9uKHIpe24odFtyXSxyLHQpfSl9KGZ1bmN0aW9uKHIsZSx1KXt0PW4odCxyLGUsdSl9LHIpLHR9ZnVuY3Rpb24gYShuLHQpe3JldHVybiBpKGZ1bmN0aW9uKHQscixlLHUpe3JldHVybiB0LmNvbmNhdChbbihyLGUsdSldKX0sW10sdCl9ZnVuY3Rpb24gZihuLHQpe3ZhciByPXt2OjAsYnVmOnR9O3JldHVybiBvKG4sZnVuY3Rpb24oKXt2YXIgbjtyPXt2OnIudjw8MXwobj1yLmJ1ZixuWzBdPj43KSxidWY6ZnVuY3Rpb24obil7dmFyIHQ9aShmdW5jdGlvbihuLHQscixlKXtyZXR1cm4gbi5jb25jYXQocj09PWUubGVuZ3RoLTE/QnVmZmVyLmZyb20oW3QsMF0pLnJlYWRVSW50MTZCRSgwKTplLnJlYWRVSW50MTZCRShyKSl9LFtdLG4pO3JldHVybiBCdWZmZXIuZnJvbShhKGZ1bmN0aW9uKG4pe3JldHVybihuPDwxJjY1NTM1KT4+OH0sdCkpfShyLmJ1Zil9fSkscn1mdW5jdGlvbiBjKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlcn1mdW5jdGlvbiBzKCl7aWYoIWMoKSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgZ2xvYmFsIGRvZXMgbm90IGV4aXN0OyBwbGVhc2UgdXNlIHdlYnBhY2sgaWYgeW91IG5lZWQgdG8gcGFyc2UgQnVmZmVycyBpbiB0aGUgYnJvd3Nlci5cIil9ZnVuY3Rpb24gbChuKXtzKCk7dmFyIHQ9aShmdW5jdGlvbihuLHQpe3JldHVybiBuK3R9LDAsbik7aWYodCU4IT0wKXRocm93IG5ldyBFcnJvcihcIlRoZSBiaXRzIFtcIituLmpvaW4oXCIsIFwiKStcIl0gYWRkIHVwIHRvIFwiK3QrXCIgd2hpY2ggaXMgbm90IGFuIGV2ZW4gbnVtYmVyIG9mIGJ5dGVzOyB0aGUgdG90YWwgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSA4XCIpO3ZhciByLHU9dC84LG89KHI9ZnVuY3Rpb24obil7cmV0dXJuIG4+NDh9LGkoZnVuY3Rpb24obix0KXtyZXR1cm4gbnx8KHIodCk/dDpuKX0sbnVsbCxuKSk7aWYobyl0aHJvdyBuZXcgRXJyb3IobytcIiBiaXQgcmFuZ2UgcmVxdWVzdGVkIGV4Y2VlZHMgNDggYml0ICg2IGJ5dGUpIE51bWJlciBtYXguXCIpO3JldHVybiBuZXcgZShmdW5jdGlvbih0LHIpe3ZhciBlPXUrcjtyZXR1cm4gZT50Lmxlbmd0aD94KHIsdS50b1N0cmluZygpK1wiIGJ5dGVzXCIpOmIoZSxpKGZ1bmN0aW9uKG4sdCl7dmFyIHI9Zih0LG4uYnVmKTtyZXR1cm57Y29sbDpuLmNvbGwuY29uY2F0KHIudiksYnVmOnIuYnVmfX0se2NvbGw6W10sYnVmOnQuc2xpY2UocixlKX0sbikuY29sbCl9KX1mdW5jdGlvbiBoKG4sdCl7cmV0dXJuIG5ldyBlKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHMoKSxlK3Q+ci5sZW5ndGg/eChlLHQrXCIgYnl0ZXMgZm9yIFwiK24pOmIoZSt0LHIuc2xpY2UoZSxlK3QpKX0pfWZ1bmN0aW9uIHAobix0KXtpZihcIm51bWJlclwiIT10eXBlb2Yocj10KXx8TWF0aC5mbG9vcihyKSE9PXJ8fHQ8MHx8dD42KXRocm93IG5ldyBFcnJvcihuK1wiIHJlcXVpcmVzIGludGVnZXIgbGVuZ3RoIGluIHJhbmdlIFswLCA2XS5cIik7dmFyIHJ9ZnVuY3Rpb24gZChuKXtyZXR1cm4gcChcInVpbnRCRVwiLG4pLGgoXCJ1aW50QkUoXCIrbitcIilcIixuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZFVJbnRCRSgwLG4pfSl9ZnVuY3Rpb24gdihuKXtyZXR1cm4gcChcInVpbnRMRVwiLG4pLGgoXCJ1aW50TEUoXCIrbitcIilcIixuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZFVJbnRMRSgwLG4pfSl9ZnVuY3Rpb24gZyhuKXtyZXR1cm4gcChcImludEJFXCIsbiksaChcImludEJFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRJbnRCRSgwLG4pfSl9ZnVuY3Rpb24gbShuKXtyZXR1cm4gcChcImludExFXCIsbiksaChcImludExFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRJbnRMRSgwLG4pfSl9ZnVuY3Rpb24geShuKXtyZXR1cm4gbiBpbnN0YW5jZW9mIGV9ZnVuY3Rpb24gRShuKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT17fS50b1N0cmluZy5jYWxsKG4pfWZ1bmN0aW9uIHcobil7cmV0dXJuIGMoKSYmQnVmZmVyLmlzQnVmZmVyKG4pfWZ1bmN0aW9uIGIobix0KXtyZXR1cm57c3RhdHVzOiEwLGluZGV4Om4sdmFsdWU6dCxmdXJ0aGVzdDotMSxleHBlY3RlZDpbXX19ZnVuY3Rpb24geChuLHQpe3JldHVybiBFKHQpfHwodD1bdF0pLHtzdGF0dXM6ITEsaW5kZXg6LTEsdmFsdWU6bnVsbCxmdXJ0aGVzdDpuLGV4cGVjdGVkOnR9fWZ1bmN0aW9uIEIobix0KXtpZighdClyZXR1cm4gbjtpZihuLmZ1cnRoZXN0PnQuZnVydGhlc3QpcmV0dXJuIG47dmFyIHI9bi5mdXJ0aGVzdD09PXQuZnVydGhlc3Q/ZnVuY3Rpb24obix0KXtpZihmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuX3N1cHBvcnRzU2V0KXJldHVybiBlLl9zdXBwb3J0c1NldDt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU2V0O3JldHVybiBlLl9zdXBwb3J0c1NldD1uLG59KCkmJkFycmF5LmZyb20pe2Zvcih2YXIgcj1uZXcgU2V0KG4pLHU9MDt1PHQubGVuZ3RoO3UrKylyLmFkZCh0W3VdKTt2YXIgbz1BcnJheS5mcm9tKHIpO3JldHVybiBvLnNvcnQoKSxvfWZvcih2YXIgaT17fSxhPTA7YTxuLmxlbmd0aDthKyspaVtuW2FdXT0hMDtmb3IodmFyIGY9MDtmPHQubGVuZ3RoO2YrKylpW3RbZl1dPSEwO3ZhciBjPVtdO2Zvcih2YXIgcyBpbiBpKSh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChpLHMpJiZjLnB1c2gocyk7cmV0dXJuIGMuc29ydCgpLGN9KG4uZXhwZWN0ZWQsdC5leHBlY3RlZCk6dC5leHBlY3RlZDtyZXR1cm57c3RhdHVzOm4uc3RhdHVzLGluZGV4Om4uaW5kZXgsdmFsdWU6bi52YWx1ZSxmdXJ0aGVzdDp0LmZ1cnRoZXN0LGV4cGVjdGVkOnJ9fXZhciBqPXt9O2Z1bmN0aW9uIFMobix0KXtpZih3KG4pKXJldHVybntvZmZzZXQ6dCxsaW5lOi0xLGNvbHVtbjotMX07biBpbiBqfHwoaltuXT17fSk7Zm9yKHZhciByPWpbbl0sZT0wLHU9MCxvPTAsaT10O2k+PTA7KXtpZihpIGluIHIpe2U9cltpXS5saW5lLDA9PT1vJiYobz1yW2ldLmxpbmVTdGFydCk7YnJlYWt9KFwiXFxuXCI9PT1uLmNoYXJBdChpKXx8XCJcXHJcIj09PW4uY2hhckF0KGkpJiZcIlxcblwiIT09bi5jaGFyQXQoaSsxKSkmJih1KyssMD09PW8mJihvPWkrMSkpLGktLX12YXIgYT1lK3UsZj10LW87cmV0dXJuIHJbdF09e2xpbmU6YSxsaW5lU3RhcnQ6b30se29mZnNldDp0LGxpbmU6YSsxLGNvbHVtbjpmKzF9fWZ1bmN0aW9uIF8obil7aWYoIXkobikpdGhyb3cgbmV3IEVycm9yKFwibm90IGEgcGFyc2VyOiBcIituKX1mdW5jdGlvbiBMKG4sdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIG4/bi5jaGFyQXQodCk6blt0XX1mdW5jdGlvbiBPKG4pe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIG51bWJlcjogXCIrbil9ZnVuY3Rpb24gayhuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIGZ1bmN0aW9uOiBcIituKX1mdW5jdGlvbiBQKG4pe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIHN0cmluZzogXCIrbil9dmFyIHE9MixBPTMsST04LEY9NSpJLE09NCpJLHo9XCIgIFwiO2Z1bmN0aW9uIFIobix0KXtyZXR1cm4gbmV3IEFycmF5KHQrMSkuam9pbihuKX1mdW5jdGlvbiBVKG4sdCxyKXt2YXIgZT10LW4ubGVuZ3RoO3JldHVybiBlPD0wP246UihyLGUpK259ZnVuY3Rpb24gVyhuLHQscixlKXtyZXR1cm57ZnJvbTpuLXQ+MD9uLXQ6MCx0bzpuK3I+ZT9lOm4rcn19ZnVuY3Rpb24gRChuLHQpe3ZhciByLGUsdSxvLGYsYz10LmluZGV4LHM9Yy5vZmZzZXQsbD0xO2lmKHM9PT1uLmxlbmd0aClyZXR1cm5cIkdvdCB0aGUgZW5kIG9mIHRoZSBpbnB1dFwiO2lmKHcobikpe3ZhciBoPXMtcyVJLHA9cy1oLGQ9VyhoLEYsTStJLG4ubGVuZ3RoKSx2PWEoZnVuY3Rpb24obil7cmV0dXJuIGEoZnVuY3Rpb24obil7cmV0dXJuIFUobi50b1N0cmluZygxNiksMixcIjBcIil9LG4pfSxmdW5jdGlvbihuLHQpe3ZhciByPW4ubGVuZ3RoLGU9W10sdT0wO2lmKHI8PXQpcmV0dXJuW24uc2xpY2UoKV07Zm9yKHZhciBvPTA7bzxyO28rKyllW3VdfHxlLnB1c2goW10pLGVbdV0ucHVzaChuW29dKSwobysxKSV0PT0wJiZ1Kys7cmV0dXJuIGV9KG4uc2xpY2UoZC5mcm9tLGQudG8pLnRvSlNPTigpLmRhdGEsSSkpO289ZnVuY3Rpb24obil7cmV0dXJuIDA9PT1uLmZyb20mJjE9PT1uLnRvP3tmcm9tOm4uZnJvbSx0bzpuLnRvfTp7ZnJvbTpuLmZyb20vSSx0bzpNYXRoLmZsb29yKG4udG8vSSl9fShkKSxlPWgvSSxyPTMqcCxwPj00JiYocis9MSksbD0yLHU9YShmdW5jdGlvbihuKXtyZXR1cm4gbi5sZW5ndGg8PTQ/bi5qb2luKFwiIFwiKTpuLnNsaWNlKDAsNCkuam9pbihcIiBcIikrXCIgIFwiK24uc2xpY2UoNCkuam9pbihcIiBcIil9LHYpLChmPSg4KihvLnRvPjA/by50by0xOm8udG8pKS50b1N0cmluZygxNikubGVuZ3RoKTwyJiYoZj0yKX1lbHNle3ZhciBnPW4uc3BsaXQoL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLyk7cj1jLmNvbHVtbi0xLGU9Yy5saW5lLTEsbz1XKGUscSxBLGcubGVuZ3RoKSx1PWcuc2xpY2Uoby5mcm9tLG8udG8pLGY9by50by50b1N0cmluZygpLmxlbmd0aH12YXIgbT1lLW8uZnJvbTtyZXR1cm4gdyhuKSYmKGY9KDgqKG8udG8+MD9vLnRvLTE6by50bykpLnRvU3RyaW5nKDE2KS5sZW5ndGgpPDImJihmPTIpLGkoZnVuY3Rpb24odCxlLHUpe3ZhciBpLGE9dT09PW0sYz1hP1wiPiBcIjp6O3JldHVybiBpPXcobik/VSgoOCooby5mcm9tK3UpKS50b1N0cmluZygxNiksZixcIjBcIik6VSgoby5mcm9tK3UrMSkudG9TdHJpbmcoKSxmLFwiIFwiKSxbXS5jb25jYXQodCxbYytpK1wiIHwgXCIrZV0sYT9beitSKFwiIFwiLGYpK1wiIHwgXCIrVShcIlwiLHIsXCIgXCIpK1IoXCJeXCIsbCldOltdKX0sW10sdSkuam9pbihcIlxcblwiKX1mdW5jdGlvbiBOKG4sdCl7cmV0dXJuW1wiXFxuXCIsXCItLSBQQVJTSU5HIEZBSUxFRCBcIitSKFwiLVwiLDUwKSxcIlxcblxcblwiLEQobix0KSxcIlxcblxcblwiLChyPXQuZXhwZWN0ZWQsMT09PXIubGVuZ3RoP1wiRXhwZWN0ZWQ6XFxuXFxuXCIrclswXTpcIkV4cGVjdGVkIG9uZSBvZiB0aGUgZm9sbG93aW5nOiBcXG5cXG5cIityLmpvaW4oXCIsIFwiKSksXCJcXG5cIl0uam9pbihcIlwiKTt2YXIgcn1mdW5jdGlvbiBHKG4pe3JldHVybiB2b2lkIDAhPT1uLmZsYWdzP24uZmxhZ3M6W24uZ2xvYmFsP1wiZ1wiOlwiXCIsbi5pZ25vcmVDYXNlP1wiaVwiOlwiXCIsbi5tdWx0aWxpbmU/XCJtXCI6XCJcIixuLnVuaWNvZGU/XCJ1XCI6XCJcIixuLnN0aWNreT9cInlcIjpcIlwiXS5qb2luKFwiXCIpfWZ1bmN0aW9uIEMoKXtmb3IodmFyIG49W10uc2xpY2UuY2FsbChhcmd1bWVudHMpLHQ9bi5sZW5ndGgscj0wO3I8dDtyKz0xKV8obltyXSk7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXtmb3IodmFyIHUsbz1uZXcgQXJyYXkodCksaT0wO2k8dDtpKz0xKXtpZighKHU9QihuW2ldLl8ocixlKSx1KSkuc3RhdHVzKXJldHVybiB1O29baV09dS52YWx1ZSxlPXUuaW5kZXh9cmV0dXJuIEIoYihlLG8pLHUpfSl9ZnVuY3Rpb24gSigpe3ZhciBuPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZigwPT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2VxTWFwIG5lZWRzIGF0IGxlYXN0IG9uZSBhcmd1bWVudFwiKTt2YXIgdD1uLnBvcCgpO3JldHVybiBrKHQpLEMuYXBwbHkobnVsbCxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIHQuYXBwbHkobnVsbCxuKX0pfWZ1bmN0aW9uIFQoKXt2YXIgbj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksdD1uLmxlbmd0aDtpZigwPT09dClyZXR1cm4gWShcInplcm8gYWx0ZXJuYXRlc1wiKTtmb3IodmFyIHI9MDtyPHQ7cis9MSlfKG5bcl0pO3JldHVybiBlKGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlLHU9MDt1PG4ubGVuZ3RoO3UrPTEpaWYoKGU9QihuW3VdLl8odCxyKSxlKSkuc3RhdHVzKXJldHVybiBlO3JldHVybiBlfSl9ZnVuY3Rpb24gVihuLHQpe3JldHVybiBIKG4sdCkub3IoWChbXSkpfWZ1bmN0aW9uIEgobix0KXtyZXR1cm4gXyhuKSxfKHQpLEoobix0LnRoZW4obikubWFueSgpLGZ1bmN0aW9uKG4sdCl7cmV0dXJuW25dLmNvbmNhdCh0KX0pfWZ1bmN0aW9uIEsobil7UChuKTt2YXIgdD1cIidcIituK1wiJ1wiO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9ZStuLmxlbmd0aCxvPXIuc2xpY2UoZSx1KTtyZXR1cm4gbz09PW4/Yih1LG8pOngoZSx0KX0pfWZ1bmN0aW9uIFEobix0KXshZnVuY3Rpb24obil7aWYoIShuIGluc3RhbmNlb2YgUmVnRXhwKSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSByZWdleHA6IFwiK24pO2Zvcih2YXIgdD1HKG4pLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGU9dC5jaGFyQXQocik7aWYoXCJpXCIhPT1lJiZcIm1cIiE9PWUmJlwidVwiIT09ZSYmXCJzXCIhPT1lKXRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgcmVnZXhwIGZsYWcgXCInK2UrJ1wiOiAnK24pfX0obiksYXJndW1lbnRzLmxlbmd0aD49Mj9PKHQpOnQ9MDt2YXIgcj1mdW5jdGlvbihuKXtyZXR1cm4gUmVnRXhwKFwiXig/OlwiK24uc291cmNlK1wiKVwiLEcobikpfShuKSx1PVwiXCIrbjtyZXR1cm4gZShmdW5jdGlvbihuLGUpe3ZhciBvPXIuZXhlYyhuLnNsaWNlKGUpKTtpZihvKXtpZigwPD10JiZ0PD1vLmxlbmd0aCl7dmFyIGk9b1swXSxhPW9bdF07cmV0dXJuIGIoZStpLmxlbmd0aCxhKX1yZXR1cm4geChlLFwidmFsaWQgbWF0Y2ggZ3JvdXAgKDAgdG8gXCIrby5sZW5ndGgrXCIpIGluIFwiK3UpfXJldHVybiB4KGUsdSl9KX1mdW5jdGlvbiBYKG4pe3JldHVybiBlKGZ1bmN0aW9uKHQscil7cmV0dXJuIGIocixuKX0pfWZ1bmN0aW9uIFkobil7cmV0dXJuIGUoZnVuY3Rpb24odCxyKXtyZXR1cm4geChyLG4pfSl9ZnVuY3Rpb24gWihuKXtpZih5KG4pKXJldHVybiBlKGZ1bmN0aW9uKHQscil7dmFyIGU9bi5fKHQscik7cmV0dXJuIGUuaW5kZXg9cixlLnZhbHVlPVwiXCIsZX0pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXJldHVybiBaKEsobikpO2lmKG4gaW5zdGFuY2VvZiBSZWdFeHApcmV0dXJuIFooUShuKSk7dGhyb3cgbmV3IEVycm9yKFwibm90IGEgc3RyaW5nLCByZWdleHAsIG9yIHBhcnNlcjogXCIrbil9ZnVuY3Rpb24gJChuKXtyZXR1cm4gXyhuKSxlKGZ1bmN0aW9uKHQscil7dmFyIGU9bi5fKHQsciksdT10LnNsaWNlKHIsZS5pbmRleCk7cmV0dXJuIGUuc3RhdHVzP3gociwnbm90IFwiJyt1KydcIicpOmIocixudWxsKX0pfWZ1bmN0aW9uIG5uKG4pe3JldHVybiBrKG4pLGUoZnVuY3Rpb24odCxyKXt2YXIgZT1MKHQscik7cmV0dXJuIHI8dC5sZW5ndGgmJm4oZSk/YihyKzEsZSk6eChyLFwiYSBjaGFyYWN0ZXIvYnl0ZSBtYXRjaGluZyBcIituKX0pfWZ1bmN0aW9uIHRuKG4sdCl7YXJndW1lbnRzLmxlbmd0aDwyJiYodD1uLG49dm9pZCAwKTt2YXIgcj1lKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIHIuXz10KCkuXyxyLl8obixlKX0pO3JldHVybiBuP3IuZGVzYyhuKTpyfWZ1bmN0aW9uIHJuKCl7cmV0dXJuIFkoXCJmYW50YXN5LWxhbmQvZW1wdHlcIil9dS5wYXJzZT1mdW5jdGlvbihuKXtpZihcInN0cmluZ1wiIT10eXBlb2YgbiYmIXcobikpdGhyb3cgbmV3IEVycm9yKFwiLnBhcnNlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBzdHJpbmcgb3IgQnVmZmVyIGFzIGl0cyBhcmd1bWVudFwiKTt2YXIgdCxyPXRoaXMuc2tpcChhbikuXyhuLDApO3JldHVybiB0PXIuc3RhdHVzP3tzdGF0dXM6ITAsdmFsdWU6ci52YWx1ZX06e3N0YXR1czohMSxpbmRleDpTKG4sci5mdXJ0aGVzdCksZXhwZWN0ZWQ6ci5leHBlY3RlZH0sZGVsZXRlIGpbbl0sdH0sdS50cnlQYXJzZT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLnBhcnNlKG4pO2lmKHQuc3RhdHVzKXJldHVybiB0LnZhbHVlO3ZhciByPU4obix0KSxlPW5ldyBFcnJvcihyKTt0aHJvdyBlLnR5cGU9XCJQYXJzaW1tb25FcnJvclwiLGUucmVzdWx0PXQsZX0sdS5hc3NlcnQ9ZnVuY3Rpb24obix0KXtyZXR1cm4gdGhpcy5jaGFpbihmdW5jdGlvbihyKXtyZXR1cm4gbihyKT9YKHIpOlkodCl9KX0sdS5vcj1mdW5jdGlvbihuKXtyZXR1cm4gVCh0aGlzLG4pfSx1LnRyaW09ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMud3JhcChuLG4pfSx1LndyYXA9ZnVuY3Rpb24obix0KXtyZXR1cm4gSihuLHRoaXMsdCxmdW5jdGlvbihuLHQpe3JldHVybiB0fSl9LHUudGhydT1mdW5jdGlvbihuKXtyZXR1cm4gbih0aGlzKX0sdS50aGVuPWZ1bmN0aW9uKG4pe3JldHVybiBfKG4pLEModGhpcyxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG5bMV19KX0sdS5tYW55PWZ1bmN0aW9uKCl7dmFyIG49dGhpcztyZXR1cm4gZShmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT1bXSx1PXZvaWQgMDs7KXtpZighKHU9QihuLl8odCxyKSx1KSkuc3RhdHVzKXJldHVybiBCKGIocixlKSx1KTtpZihyPT09dS5pbmRleCl0aHJvdyBuZXcgRXJyb3IoXCJpbmZpbml0ZSBsb29wIGRldGVjdGVkIGluIC5tYW55KCkgcGFyc2VyIC0tLSBjYWxsaW5nIC5tYW55KCkgb24gYSBwYXJzZXIgd2hpY2ggY2FuIGFjY2VwdCB6ZXJvIGNoYXJhY3RlcnMgaXMgdXN1YWxseSB0aGUgY2F1c2VcIik7cj11LmluZGV4LGUucHVzaCh1LnZhbHVlKX19KX0sdS50aWVXaXRoPWZ1bmN0aW9uKG4pe3JldHVybiBQKG4pLHRoaXMubWFwKGZ1bmN0aW9uKHQpe2lmKGZ1bmN0aW9uKG4pe2lmKCFFKG4pKXRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheTogXCIrbil9KHQpLHQubGVuZ3RoKXtQKHRbMF0pO2Zvcih2YXIgcj10WzBdLGU9MTtlPHQubGVuZ3RoO2UrKylQKHRbZV0pLHIrPW4rdFtlXTtyZXR1cm4gcn1yZXR1cm5cIlwifSl9LHUudGllPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGllV2l0aChcIlwiKX0sdS50aW1lcz1mdW5jdGlvbihuLHQpe3ZhciByPXRoaXM7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8MiYmKHQ9biksTyhuKSxPKHQpLGUoZnVuY3Rpb24oZSx1KXtmb3IodmFyIG89W10saT12b2lkIDAsYT12b2lkIDAsZj0wO2Y8bjtmKz0xKXtpZihhPUIoaT1yLl8oZSx1KSxhKSwhaS5zdGF0dXMpcmV0dXJuIGE7dT1pLmluZGV4LG8ucHVzaChpLnZhbHVlKX1mb3IoO2Y8dCYmKGE9QihpPXIuXyhlLHUpLGEpLGkuc3RhdHVzKTtmKz0xKXU9aS5pbmRleCxvLnB1c2goaS52YWx1ZSk7cmV0dXJuIEIoYih1LG8pLGEpfSl9LHUucmVzdWx0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBufSl9LHUuYXRNb3N0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnRpbWVzKDAsbil9LHUuYXRMZWFzdD1mdW5jdGlvbihuKXtyZXR1cm4gSih0aGlzLnRpbWVzKG4pLHRoaXMubWFueSgpLGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4uY29uY2F0KHQpfSl9LHUubWFwPWZ1bmN0aW9uKG4pe2sobik7dmFyIHQ9dGhpcztyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PXQuXyhyLGUpO3JldHVybiB1LnN0YXR1cz9CKGIodS5pbmRleCxuKHUudmFsdWUpKSx1KTp1fSl9LHUuY29udHJhbWFwPWZ1bmN0aW9uKG4pe2sobik7dmFyIHQ9dGhpcztyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PXQucGFyc2UobihyLnNsaWNlKGUpKSk7cmV0dXJuIHUuc3RhdHVzP2IoZStyLmxlbmd0aCx1LnZhbHVlKTp1fSl9LHUucHJvbWFwPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIGsobiksayh0KSx0aGlzLmNvbnRyYW1hcChuKS5tYXAodCl9LHUuc2tpcD1mdW5jdGlvbihuKXtyZXR1cm4gQyh0aGlzLG4pLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gblswXX0pfSx1Lm1hcms9ZnVuY3Rpb24oKXtyZXR1cm4gSihlbix0aGlzLGVuLGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm57c3RhcnQ6bix2YWx1ZTp0LGVuZDpyfX0pfSx1Lm5vZGU9ZnVuY3Rpb24obil7cmV0dXJuIEooZW4sdGhpcyxlbixmdW5jdGlvbih0LHIsZSl7cmV0dXJue25hbWU6bix2YWx1ZTpyLHN0YXJ0OnQsZW5kOmV9fSl9LHUuc2VwQnk9ZnVuY3Rpb24obil7cmV0dXJuIFYodGhpcyxuKX0sdS5zZXBCeTE9ZnVuY3Rpb24obil7cmV0dXJuIEgodGhpcyxuKX0sdS5sb29rYWhlYWQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuc2tpcChaKG4pKX0sdS5ub3RGb2xsb3dlZEJ5PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNraXAoJChuKSl9LHUuZGVzYz1mdW5jdGlvbihuKXtFKG4pfHwobj1bbl0pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXN8fCh1LmV4cGVjdGVkPW4pLHV9KX0sdS5mYWxsYmFjaz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5vcihYKG4pKX0sdS5hcD1mdW5jdGlvbihuKXtyZXR1cm4gSihuLHRoaXMsZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX0pfSx1LmNoYWluPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXM/QihuKHUudmFsdWUpLl8ocix1LmluZGV4KSx1KTp1fSl9LHUuY29uY2F0PXUub3IsdS5lbXB0eT1ybix1Lm9mPVgsdVtcImZhbnRhc3ktbGFuZC9hcFwiXT11LmFwLHVbXCJmYW50YXN5LWxhbmQvY2hhaW5cIl09dS5jaGFpbix1W1wiZmFudGFzeS1sYW5kL2NvbmNhdFwiXT11LmNvbmNhdCx1W1wiZmFudGFzeS1sYW5kL2VtcHR5XCJdPXUuZW1wdHksdVtcImZhbnRhc3ktbGFuZC9vZlwiXT11Lm9mLHVbXCJmYW50YXN5LWxhbmQvbWFwXCJdPXUubWFwO3ZhciBlbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGIodCxTKG4sdCkpfSksdW49ZShmdW5jdGlvbihuLHQpe3JldHVybiB0Pj1uLmxlbmd0aD94KHQsXCJhbnkgY2hhcmFjdGVyL2J5dGVcIik6Yih0KzEsTChuLHQpKX0pLG9uPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gYihuLmxlbmd0aCxuLnNsaWNlKHQpKX0pLGFuPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gdDxuLmxlbmd0aD94KHQsXCJFT0ZcIik6Yih0LG51bGwpfSksZm49USgvWzAtOV0vKS5kZXNjKFwiYSBkaWdpdFwiKSxjbj1RKC9bMC05XSovKS5kZXNjKFwib3B0aW9uYWwgZGlnaXRzXCIpLHNuPVEoL1thLXpdL2kpLmRlc2MoXCJhIGxldHRlclwiKSxsbj1RKC9bYS16XSovaSkuZGVzYyhcIm9wdGlvbmFsIGxldHRlcnNcIiksaG49USgvXFxzKi8pLmRlc2MoXCJvcHRpb25hbCB3aGl0ZXNwYWNlXCIpLHBuPVEoL1xccysvKS5kZXNjKFwid2hpdGVzcGFjZVwiKSxkbj1LKFwiXFxyXCIpLHZuPUsoXCJcXG5cIiksZ249SyhcIlxcclxcblwiKSxtbj1UKGduLHZuLGRuKS5kZXNjKFwibmV3bGluZVwiKSx5bj1UKG1uLGFuKTtlLmFsbD1vbixlLmFsdD1ULGUuYW55PXVuLGUuY3I9ZG4sZS5jcmVhdGVMYW5ndWFnZT1mdW5jdGlvbihuKXt2YXIgdD17fTtmb3IodmFyIHIgaW4gbikoe30pLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmZnVuY3Rpb24ocil7dFtyXT10bihmdW5jdGlvbigpe3JldHVybiBuW3JdKHQpfSl9KHIpO3JldHVybiB0fSxlLmNybGY9Z24sZS5jdXN0b209ZnVuY3Rpb24obil7cmV0dXJuIGUobihiLHgpKX0sZS5kaWdpdD1mbixlLmRpZ2l0cz1jbixlLmVtcHR5PXJuLGUuZW5kPXluLGUuZW9mPWFuLGUuZmFpbD1ZLGUuZm9ybWF0RXJyb3I9TixlLmluZGV4PWVuLGUuaXNQYXJzZXI9eSxlLmxhenk9dG4sZS5sZXR0ZXI9c24sZS5sZXR0ZXJzPWxuLGUubGY9dm4sZS5sb29rYWhlYWQ9WixlLm1ha2VGYWlsdXJlPXgsZS5tYWtlU3VjY2Vzcz1iLGUubmV3bGluZT1tbixlLm5vbmVPZj1mdW5jdGlvbihuKXtyZXR1cm4gbm4oZnVuY3Rpb24odCl7cmV0dXJuIG4uaW5kZXhPZih0KTwwfSkuZGVzYyhcIm5vbmUgb2YgJ1wiK24rXCInXCIpfSxlLm5vdEZvbGxvd2VkQnk9JCxlLm9mPVgsZS5vbmVPZj1mdW5jdGlvbihuKXtmb3IodmFyIHQ9bi5zcGxpdChcIlwiKSxyPTA7cjx0Lmxlbmd0aDtyKyspdFtyXT1cIidcIit0W3JdK1wiJ1wiO3JldHVybiBubihmdW5jdGlvbih0KXtyZXR1cm4gbi5pbmRleE9mKHQpPj0wfSkuZGVzYyh0KX0sZS5vcHRXaGl0ZXNwYWNlPWhuLGUuUGFyc2VyPWUsZS5yYW5nZT1mdW5jdGlvbihuLHQpe3JldHVybiBubihmdW5jdGlvbihyKXtyZXR1cm4gbjw9ciYmcjw9dH0pLmRlc2MobitcIi1cIit0KX0sZS5yZWdleD1RLGUucmVnZXhwPVEsZS5zZXBCeT1WLGUuc2VwQnkxPUgsZS5zZXE9QyxlLnNlcU1hcD1KLGUuc2VxT2JqPWZ1bmN0aW9uKCl7Zm9yKHZhciBuLHQ9e30scj0wLHU9KG49YXJndW1lbnRzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pKSxvPXUubGVuZ3RoLGk9MDtpPG87aSs9MSl7dmFyIGE9dVtpXTtpZigheShhKSl7aWYoRShhKSYmMj09PWEubGVuZ3RoJiZcInN0cmluZ1wiPT10eXBlb2YgYVswXSYmeShhWzFdKSl7dmFyIGY9YVswXTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxmKSl0aHJvdyBuZXcgRXJyb3IoXCJzZXFPYmo6IGR1cGxpY2F0ZSBrZXkgXCIrZik7dFtmXT0hMCxyKys7Y29udGludWV9dGhyb3cgbmV3IEVycm9yKFwic2VxT2JqIGFyZ3VtZW50cyBtdXN0IGJlIHBhcnNlcnMgb3IgW3N0cmluZywgcGFyc2VyXSBhcnJheSBwYWlycy5cIil9fWlmKDA9PT1yKXRocm93IG5ldyBFcnJvcihcInNlcU9iaiBleHBlY3RzIGF0IGxlYXN0IG9uZSBuYW1lZCBwYXJzZXIsIGZvdW5kIHplcm9cIik7cmV0dXJuIGUoZnVuY3Rpb24obix0KXtmb3IodmFyIHIsZT17fSxpPTA7aTxvO2krPTEpe3ZhciBhLGY7aWYoRSh1W2ldKT8oYT11W2ldWzBdLGY9dVtpXVsxXSk6KGE9bnVsbCxmPXVbaV0pLCEocj1CKGYuXyhuLHQpLHIpKS5zdGF0dXMpcmV0dXJuIHI7YSYmKGVbYV09ci52YWx1ZSksdD1yLmluZGV4fXJldHVybiBCKGIodCxlKSxyKX0pfSxlLnN0cmluZz1LLGUuc3VjY2VlZD1YLGUudGFrZVdoaWxlPWZ1bmN0aW9uKG4pe3JldHVybiBrKG4pLGUoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9cjtlPHQubGVuZ3RoJiZuKEwodCxlKSk7KWUrKztyZXR1cm4gYihlLHQuc2xpY2UocixlKSl9KX0sZS50ZXN0PW5uLGUud2hpdGVzcGFjZT1wbixlW1wiZmFudGFzeS1sYW5kL2VtcHR5XCJdPXJuLGVbXCJmYW50YXN5LWxhbmQvb2ZcIl09WCxlLkJpbmFyeT17Yml0U2VxOmwsYml0U2VxT2JqOmZ1bmN0aW9uKG4pe3MoKTt2YXIgdD17fSxyPTAsZT1hKGZ1bmN0aW9uKG4pe2lmKEUobikpe3ZhciBlPW47aWYoMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIltcIitlLmpvaW4oXCIsIFwiKStcIl0gc2hvdWxkIGJlIGxlbmd0aCAyLCBnb3QgbGVuZ3RoIFwiK2UubGVuZ3RoKTtpZihQKGVbMF0pLE8oZVsxXSksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZVswXSkpdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGtleSBpbiBiaXRTZXFPYmo6IFwiK2VbMF0pO3JldHVybiB0W2VbMF1dPSEwLHIrKyxlfXJldHVybiBPKG4pLFtudWxsLG5dfSxuKTtpZihyPDEpdGhyb3cgbmV3IEVycm9yKFwiYml0U2VxT2JqIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG5hbWVkIHBhaXIsIGdvdCBbXCIrbi5qb2luKFwiLCBcIikrXCJdXCIpO3ZhciB1PWEoZnVuY3Rpb24obil7cmV0dXJuIG5bMF19LGUpO3JldHVybiBsKGEoZnVuY3Rpb24obil7cmV0dXJuIG5bMV19LGUpKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIGkoZnVuY3Rpb24obix0KXtyZXR1cm4gbnVsbCE9PXRbMF0mJihuW3RbMF1dPXRbMV0pLG59LHt9LGEoZnVuY3Rpb24odCxyKXtyZXR1cm5bdCxuW3JdXX0sdSkpfSl9LGJ5dGU6ZnVuY3Rpb24obil7aWYocygpLE8obiksbj4yNTUpdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgc3BlY2lmaWVkIHRvIGJ5dGUgY29uc3RydWN0b3IgKFwiK24rXCI9MHhcIituLnRvU3RyaW5nKDE2KStcIikgaXMgbGFyZ2VyIGluIHZhbHVlIHRoYW4gYSBzaW5nbGUgYnl0ZS5cIik7dmFyIHQ9KG4+MTU/XCIweFwiOlwiMHgwXCIpK24udG9TdHJpbmcoMTYpO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9TChyLGUpO3JldHVybiB1PT09bj9iKGUrMSx1KTp4KGUsdCl9KX0sYnVmZmVyOmZ1bmN0aW9uKG4pe3JldHVybiBoKFwiYnVmZmVyXCIsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBCdWZmZXIuZnJvbShuKX0pfSxlbmNvZGVkU3RyaW5nOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIGgoXCJzdHJpbmdcIix0KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9TdHJpbmcobil9KX0sdWludEJFOmQsdWludDhCRTpkKDEpLHVpbnQxNkJFOmQoMiksdWludDMyQkU6ZCg0KSx1aW50TEU6dix1aW50OExFOnYoMSksdWludDE2TEU6digyKSx1aW50MzJMRTp2KDQpLGludEJFOmcsaW50OEJFOmcoMSksaW50MTZCRTpnKDIpLGludDMyQkU6Zyg0KSxpbnRMRTptLGludDhMRTptKDEpLGludDE2TEU6bSgyKSxpbnQzMkxFOm0oNCksZmxvYXRCRTpoKFwiZmxvYXRCRVwiLDQpLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbi5yZWFkRmxvYXRCRSgwKX0pLGZsb2F0TEU6aChcImZsb2F0TEVcIiw0KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZEZsb2F0TEUoMCl9KSxkb3VibGVCRTpoKFwiZG91YmxlQkVcIiw4KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZERvdWJsZUJFKDApfSksZG91YmxlTEU6aChcImRvdWJsZUxFXCIsOCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWREb3VibGVMRSgwKX0pfSxuLmV4cG9ydHM9ZX1dKX0pOyIsICJtb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcblx0Ly8gaHR0cHM6Ly9tdGhzLmJlL2Vtb2ppXG5cdHJldHVybiAvKD86WyMqMC05XVxcdUZFMEY/XFx1MjBFM3xbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0VELVxcdTIzRUZcXHUyM0YxXFx1MjNGMlxcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQlxcdTI1RkNcXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2N0ZcXHUyNjkyXFx1MjY5NC1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTdcXHUyNkFBXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM4XFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZFOVxcdTI2RjAtXFx1MjZGNVxcdTI2RjdcXHUyNkY4XFx1MjZGQVxcdTI3MDJcXHUyNzA4XFx1MjcwOVxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzU3XFx1Mjc2M1xcdTI3QTFcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldXFx1RkUwRj98W1xcdTI2MURcXHUyNzBDXFx1MjcwRF0oPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHUyNzBBXFx1MjcwQl0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjY5M1xcdTI2QTFcXHUyNkFCXFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RkRcXHUyNzA1XFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjUwXXxcXHUyNkY5KD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xcXHUyNzY0XFx1RkUwRj8oPzpcXHUyMDBEKD86XFx1RDgzRFxcdUREMjV8XFx1RDgzRVxcdURFNzkpKT98XFx1RDgzQyg/OltcXHVEQzA0XFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdURFMDJcXHVERTM3XFx1REYyMVxcdURGMjQtXFx1REYyQ1xcdURGMzZcXHVERjdEXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFXFx1REY5RlxcdURGQ0RcXHVERkNFXFx1REZENC1cXHVERkRGXFx1REZGNVxcdURGRjddXFx1RkUwRj98W1xcdURGODVcXHVERkMyXFx1REZDN10oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1REZDM1xcdURGQzRcXHVERkNBXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFtcXHVERkNCXFx1REZDQ10oPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFtcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjg0XFx1REY4Ni1cXHVERjkzXFx1REZBMC1cXHVERkMxXFx1REZDNVxcdURGQzZcXHVERkM4XFx1REZDOVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjgtXFx1REZGRl18XFx1RERFNlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl18XFx1RERFN1xcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUZcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkVcXHVEREZGXXxcXHVEREU4XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXXxcXHVEREU5XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXXxcXHVEREVBXFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV18XFx1RERFQlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XXxcXHVEREVDXFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRVxcdURERjEtXFx1RERGM1xcdURERjUtXFx1RERGQVxcdURERkNcXHVEREZFXXxcXHVEREVEXFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdfFxcdURERUVcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV18XFx1RERFRlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV18XFx1RERGMFxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdfFxcdURERjFcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV18XFx1RERGMlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl18XFx1RERGM1xcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXXxcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RERGNVxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXXxcXHVEREY2XFx1RDgzQ1xcdURERTZ8XFx1RERGN1xcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdfFxcdURERjhcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdfFxcdURERjlcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXXxcXHVEREZBXFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXXxcXHVEREZCXFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXXxcXHVEREZDXFx1RDgzQ1tcXHVEREVCXFx1RERGOF18XFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdURERkVcXHVEODNDW1xcdURERUFcXHVEREY5XXxcXHVEREZGXFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdfFxcdURGRjNcXHVGRTBGPyg/OlxcdTIwMEQoPzpcXHUyNkE3XFx1RkUwRj98XFx1RDgzQ1xcdURGMDgpKT98XFx1REZGNCg/OlxcdTIwMERcXHUyNjIwXFx1RkUwRj98XFx1REI0MFxcdURDNjdcXHVEQjQwXFx1REM2MlxcdURCNDAoPzpcXHVEQzY1XFx1REI0MFxcdURDNkVcXHVEQjQwXFx1REM2N3xcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3MylcXHVEQjQwXFx1REM3Rik/KXxcXHVEODNEKD86W1xcdURDM0ZcXHVEQ0ZEXFx1REQ0OVxcdURENEFcXHVERDZGXFx1REQ3MFxcdURENzNcXHVERDc2LVxcdURENzlcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkFcXHVERUNCXFx1REVDRC1cXHVERUNGXFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRjBcXHVERUYzXVxcdUZFMEY/fFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM2Qi1cXHVEQzZEXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQzhGXFx1REM5MVxcdURDQUFcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFtcXHVERDc0XFx1REQ5MF0oPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVEQzAwLVxcdURDMDdcXHVEQzA5LVxcdURDMTRcXHVEQzE2LVxcdURDM0FcXHVEQzNDLVxcdURDM0VcXHVEQzQwXFx1REM0NFxcdURDNDVcXHVEQzUxLVxcdURDNjVcXHVEQzZBXFx1REM3OS1cXHVEQzdCXFx1REM3RC1cXHVEQzgwXFx1REM4NFxcdURDODgtXFx1REM4RVxcdURDOTBcXHVEQzkyLVxcdURDQTlcXHVEQ0FCLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVEREE0XFx1RERGQi1cXHVERTJEXFx1REUyRi1cXHVERTM0XFx1REUzNy1cXHVERTQ0XFx1REU0OC1cXHVERTRBXFx1REU4MC1cXHVERUEyXFx1REVBNC1cXHVERUIzXFx1REVCNy1cXHVERUJGXFx1REVDMS1cXHVERUM1XFx1REVEMC1cXHVERUQyXFx1REVENS1cXHVERUQ3XFx1REVERC1cXHVERURGXFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRkNcXHVERkUwLVxcdURGRUJcXHVERkYwXXxcXHVEQzA4KD86XFx1MjAwRFxcdTJCMUIpP3xcXHVEQzE1KD86XFx1MjAwRFxcdUQ4M0VcXHVEREJBKT98XFx1REMzQig/OlxcdTIwMERcXHUyNzQ0XFx1RkUwRj8pP3xcXHVEQzQxXFx1RkUwRj8oPzpcXHUyMDBEXFx1RDgzRFxcdURERThcXHVGRTBGPyk/fFxcdURDNjgoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OHxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XVxcdTIwMERcXHVEODNEKD86XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pPyl8W1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pPyl8XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pKSk/fFxcdURGRkMoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pKSk/fFxcdURGRkQoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pKSk/fFxcdURGRkYoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSkpKT8pKT98XFx1REM2OSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9bXFx1REM2OFxcdURDNjldfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0QoPzpbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/fFxcdURDNjlcXHUyMDBEXFx1RDgzRCg/OlxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pKXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkMtXFx1REZGRl0pKSk/fFxcdURGRkMoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSkpKT98XFx1REZGRSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pKSk/fFxcdURGRkYoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkItXFx1REZGRV0pKSk/KSk/fFxcdURDNkYoPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98XFx1REQ3NSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98XFx1REUyRSg/OlxcdTIwMERcXHVEODNEXFx1RENBOCk/fFxcdURFMzUoPzpcXHUyMDBEXFx1RDgzRFxcdURDQUIpP3xcXHVERTM2KD86XFx1MjAwRFxcdUQ4M0NcXHVERjJCXFx1RkUwRj8pPyl8XFx1RDgzRSg/OltcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxRlxcdUREMzAtXFx1REQzNFxcdUREMzZcXHVERDc3XFx1RERCNVxcdUREQjZcXHVEREJCXFx1REREMlxcdURERDNcXHVEREQ1XFx1REVDMy1cXHVERUM1XFx1REVGMFxcdURFRjItXFx1REVGNl0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1REQyNlxcdUREMzVcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENFxcdURERDYtXFx1RERERF0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1RERERVxcdUREREZdKD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFtcXHVERDBEXFx1REQwRVxcdUREMTAtXFx1REQxN1xcdUREMjAtXFx1REQyNVxcdUREMjctXFx1REQyRlxcdUREM0FcXHVERDNGLVxcdURENDVcXHVERDQ3LVxcdURENzZcXHVERDc4LVxcdUREQjRcXHVEREI3XFx1RERCQVxcdUREQkMtXFx1RERDQ1xcdURERDBcXHVEREUwLVxcdURERkZcXHVERTcwLVxcdURFNzRcXHVERTc4LVxcdURFN0NcXHVERTgwLVxcdURFODZcXHVERTkwLVxcdURFQUNcXHVERUIwLVxcdURFQkFcXHVERUMwLVxcdURFQzJcXHVERUQwLVxcdURFRDlcXHVERUUwLVxcdURFRTddfFxcdUREM0MoPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/fFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFxcdURERDEoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDEpKXxcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkQoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZFKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT8pKT98XFx1REVGMSg/OlxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKT98XFx1REZGQyg/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pP3xcXHVERkZEKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSk/fFxcdURGRkUoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKT98XFx1REZGRig/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSk/KSk/KSkvZztcbn07XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQgZW1vamlSZWdleCBmcm9tIFwiZW1vamktcmVnZXhcIjtcbmltcG9ydCB7IFF1ZXJ5U2V0dGluZ3MgfSBmcm9tIFwic2V0dGluZ3NcIjtcblxuLyoqIE5vcm1hbGl6ZSBhIGR1cmF0aW9uIHRvIGFsbCBvZiB0aGUgcHJvcGVyIHVuaXRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cjogRHVyYXRpb24pIHtcbiAgICBpZiAoZHVyID09PSB1bmRlZmluZWQgfHwgZHVyID09PSBudWxsKSByZXR1cm4gZHVyO1xuXG4gICAgcmV0dXJuIGR1ci5zaGlmdFRvQWxsKCkubm9ybWFsaXplKCk7XG59XG5cbi8qKiBTdHJpcCB0aGUgdGltZSBjb21wb25lbnRzIG9mIGEgZGF0ZSB0aW1lIG9iamVjdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRpbWUoZHQ6IERhdGVUaW1lKTogRGF0ZVRpbWUge1xuICAgIGlmIChkdCA9PT0gbnVsbCB8fCBkdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZHQ7XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7XG4gICAgICAgIHllYXI6IGR0LnllYXIsXG4gICAgICAgIG1vbnRoOiBkdC5tb250aCxcbiAgICAgICAgZGF5OiBkdC5kYXksXG4gICAgfSk7XG59XG5cbi8qKiBUcnkgdG8gZXh0cmFjdCBhIFlZWVlNTUREIGRhdGUgZnJvbSBhIHN0cmluZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RGF0ZShzdHI6IHN0cmluZyk6IERhdGVUaW1lIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgZGF0ZU1hdGNoID0gLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pLy5leGVjKHN0cik7XG4gICAgaWYgKCFkYXRlTWF0Y2gpIGRhdGVNYXRjaCA9IC8oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSkvLmV4ZWMoc3RyKTtcbiAgICBpZiAoZGF0ZU1hdGNoKSB7XG4gICAgICAgIGxldCB5ZWFyID0gTnVtYmVyLnBhcnNlSW50KGRhdGVNYXRjaFsxXSk7XG4gICAgICAgIGxldCBtb250aCA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbMl0pO1xuICAgICAgICBsZXQgZGF5ID0gTnVtYmVyLnBhcnNlSW50KGRhdGVNYXRjaFszXSk7XG4gICAgICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhciwgbW9udGgsIGRheSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKiogR2V0IHRoZSBmb2xkZXIgY29udGFpbmluZyB0aGUgZ2l2ZW4gcGF0aCAoaS5lLiwgbGlrZSBjb21wdXRpbmcgJ3BhdGgvLi4nKS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRGb2xkZXIocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xufVxuXG4vKiogR2V0IHRoZSBmaWxlIG5hbWUgZm9yIHRoZSBmaWxlIHJlZmVyZW5jZWQgaW4gdGhlIGdpdmVuIHBhdGgsIGJ5IHN0cmlwcGluZyB0aGUgcGFyZW50IGZvbGRlcnMuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZU5hbWUocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5pbmNsdWRlcyhcIi9cIikgPyBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpIDogcGF0aDtcbn1cblxuLyoqIEdldCB0aGUgXCJ0aXRsZVwiIGZvciBhIGZpbGUsIGJ5IHN0cmlwcGluZyBvdGhlciBwYXJ0cyBvZiB0aGUgcGF0aCBhcyB3ZWxsIGFzIHRoZSBleHRlbnNpb24uICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVRpdGxlKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoXCIvXCIpKSBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICBpZiAocGF0aC5lbmRzV2l0aChcIi5tZFwiKSkgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMyk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKiBHZXQgdGhlIGV4dGVuc2lvbiBvZiBhIGZpbGUgZnJvbSB0aGUgZmlsZSBwYXRoLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbihwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghcGF0aC5pbmNsdWRlcyhcIi5cIikpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xufVxuXG4vKiogUGFyc2UgYWxsIHN1YnRhZ3Mgb3V0IG9mIHRoZSBnaXZlbiB0YWcuIEkuZS4sICNoZWxsby9pL2FtIHdvdWxkIHlpZWxkIFsjaGVsbG8vaS9hbSwgI2hlbGxvL2ksICNoZWxsb10uICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFN1YnRhZ3ModGFnOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHJlc3VsdCA9IFt0YWddO1xuICAgIHdoaWxlICh0YWcuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgICAgIHRhZyA9IHRhZy5zdWJzdHJpbmcoMCwgdGFnLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFRyeSBjYWxsaW5nIHRoZSBnaXZlbiBmdW5jdGlvbjsgb24gZmFpbHVyZSwgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlLiAgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlPclByb3BvZ2F0ZTxUPihmdW5jOiAoKSA9PiBSZXN1bHQ8VCwgc3RyaW5nPik6IFJlc3VsdDxULCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZmFpbHVyZShcIlwiICsgZXJyb3IgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2spO1xuICAgIH1cbn1cblxuLyoqIFRyeSBhc3luY2hyb25vdXNseSBjYWxsaW5nIHRoZSBnaXZlbiBmdW5jdGlvbjsgb24gZmFpbHVyZSwgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jVHJ5T3JQcm9wb2dhdGU8VD4oZnVuYzogKCkgPT4gUHJvbWlzZTxSZXN1bHQ8VCwgc3RyaW5nPj4pOiBQcm9taXNlPFJlc3VsdDxULCBzdHJpbmc+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZ1bmMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqIEEgcGFyc2ltbW9uIHBhcnNlciB3aGljaCBjYW5vbmljYWxpemVzIHZhcmlhYmxlIG5hbWVzIHdoaWxlIHByb3Blcmx5IHJlc3BlY3RpbmcgZW1vamkuICovXG5jb25zdCBWQVJfTkFNRV9DQU5PTklDQUxJWkVSOiBQLlBhcnNlcjxzdHJpbmc+ID0gUC5hbHQoXG4gICAgUC5yZWdleChuZXcgUmVnRXhwKGVtb2ppUmVnZXgoKSwgXCJcIikpLFxuICAgIFAucmVnZXgoL1swLTlcXHB7TGV0dGVyfV8tXSsvdSkubWFwKHN0ciA9PiBzdHIudG9Mb2NhbGVMb3dlckNhc2UoKSksXG4gICAgUC53aGl0ZXNwYWNlLm1hcChfID0+IFwiLVwiKSxcbiAgICBQLmFueS5tYXAoXyA9PiBcIlwiKVxuKVxuICAgIC5tYW55KClcbiAgICAubWFwKHJlc3VsdCA9PiByZXN1bHQuam9pbihcIlwiKSk7XG5cbi8qKiBDb252ZXJ0IGFuIGFyYml0cmFyeSB2YXJpYWJsZSBuYW1lIGludG8gc29tZXRoaW5nIEpTL3F1ZXJ5IGZyaWVuZGx5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVZhck5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gVkFSX05BTUVfQ0FOT05JQ0FMSVpFUi50cnlQYXJzZShuYW1lKTtcbn1cblxuY29uc3QgSEVBREVSX0NBTk9OSUNBTElaRVI6IFAuUGFyc2VyPHN0cmluZz4gPSBQLmFsdChcbiAgICBQLnJlZ2V4KG5ldyBSZWdFeHAoZW1vamlSZWdleCgpLCBcIlwiKSksXG4gICAgUC5yZWdleCgvWzAtOVxccHtMZXR0ZXJ9Xy1dKy91KSxcbiAgICBQLndoaXRlc3BhY2UubWFwKF8gPT4gXCIgXCIpLFxuICAgIFAuYW55Lm1hcChfID0+IFwiIFwiKVxuKVxuICAgIC5tYW55KClcbiAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpLnRyaW0oKTtcbiAgICB9KTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0ZXh0IGluIGEgaGVhZGVyIHRvIGJlIHNvbWV0aGluZyB0aGF0IGlzIGFjdHVhbGx5IGxpbmthYmxlIHRvLiBUaGlzIG1pbWljc1xuICogaG93IE9ic2lkaWFuIGRvZXMgaXQncyBub3JtYWxpemF0aW9uLCBjb2xsYXBzaW5nIHJlcGVhdGVkIHNwYWNlcyBhbmQgc3RyaXBwaW5nIG91dCBjb250cm9sIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJGb3JMaW5rKGhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSEVBREVSX0NBTk9OSUNBTElaRVIudHJ5UGFyc2UoaGVhZGVyKTtcbn1cblxuLyoqIFJlbmRlciBhIERhdGVUaW1lIGluIGEgbWluaW1hbCBmb3JtYXQgdG8gc2F2ZSBzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNaW5pbWFsRGF0ZSh0aW1lOiBEYXRlVGltZSwgc2V0dGluZ3M6IFF1ZXJ5U2V0dGluZ3MsIGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyByZWxldmFudCB0aW1lIHNwZWNpZmllZCwgZmFsbCBiYWNrIHRvIGp1c3QgcmVuZGVyaW5nIHRoZSBkYXRlLlxuICAgIGlmICh0aW1lLnNlY29uZCA9PSAwICYmIHRpbWUubWludXRlID09IDAgJiYgdGltZS5ob3VyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRpbWUudG9Mb2NhbCgpLnRvRm9ybWF0KHNldHRpbmdzLmRlZmF1bHREYXRlRm9ybWF0LCB7IGxvY2FsZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGltZS50b0xvY2FsKCkudG9Gb3JtYXQoc2V0dGluZ3MuZGVmYXVsdERhdGVUaW1lRm9ybWF0LCB7IGxvY2FsZSB9KTtcbn1cblxuLyoqIFJlbmRlciBhIGR1cmF0aW9uIGluIGEgbWluaW1hbCBmb3JtYXQgdG8gc2F2ZSBzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNaW5pbWFsRHVyYXRpb24oZHVyOiBEdXJhdGlvbik6IHN0cmluZyB7XG4gICAgZHVyID0gbm9ybWFsaXplRHVyYXRpb24oZHVyKTtcblxuICAgIC8vIHRvSHVtYW4gb3V0cHV0cyB6ZXJvIHF1YW50aXRpZXMgZS5nLiBcIjAgc2Vjb25kc1wiXG4gICAgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdChcbiAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGR1ci50b09iamVjdCgpKS5maWx0ZXIoKFssIHF1YW50aXR5XSkgPT4gcXVhbnRpdHkgPiAwKSlcbiAgICApO1xuXG4gICAgcmV0dXJuIGR1ci50b0h1bWFuKCk7XG59XG5cbi8qKiBEZXRlcm1pbmUgaWYgdHdvIHNldHMgYXJlIGVxdWFsIGluIGNvbnRlbnRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHNFcXVhbDxUPihmaXJzdDogU2V0PFQ+LCBzZWNvbmQ6IFNldDxUPik6IGJvb2xlYW4ge1xuICAgIGlmIChmaXJzdC5zaXplICE9IHNlY29uZC5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZWxlbSBvZiBmaXJzdCkgaWYgKCFzZWNvbmQuaGFzKGVsZW0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsICJpbXBvcnQgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjtcbmltcG9ydCB7IERFRkFVTFRfUVVFUllfU0VUVElOR1MsIFF1ZXJ5U2V0dGluZ3MgfSBmcm9tIFwic2V0dGluZ3NcIjtcbmltcG9ydCB7IGdldEZpbGVUaXRsZSwgbm9ybWFsaXplSGVhZGVyRm9yTGluaywgcmVuZGVyTWluaW1hbER1cmF0aW9uIH0gZnJvbSBcInV0aWwvbm9ybWFsaXplXCI7XG5cbi8qKiBTaG9ydGhhbmQgZm9yIGEgbWFwcGluZyBmcm9tIGtleXMgdG8gdmFsdWVzLiAqL1xuZXhwb3J0IHR5cGUgRGF0YU9iamVjdCA9IHsgW2tleTogc3RyaW5nXTogTGl0ZXJhbCB9O1xuLyoqIFRoZSBsaXRlcmFsIHR5cGVzIHN1cHBvcnRlZCBieSB0aGUgcXVlcnkgZW5naW5lLiAqL1xuZXhwb3J0IHR5cGUgTGl0ZXJhbFR5cGUgPVxuICAgIHwgXCJib29sZWFuXCJcbiAgICB8IFwibnVtYmVyXCJcbiAgICB8IFwic3RyaW5nXCJcbiAgICB8IFwiZGF0ZVwiXG4gICAgfCBcImR1cmF0aW9uXCJcbiAgICB8IFwibGlua1wiXG4gICAgfCBcImFycmF5XCJcbiAgICB8IFwib2JqZWN0XCJcbiAgICB8IFwiZnVuY3Rpb25cIlxuICAgIHwgXCJudWxsXCJcbiAgICB8IFwiaHRtbFwiXG4gICAgfCBcIndpZGdldFwiO1xuLyoqIFRoZSByYXcgdmFsdWVzIHRoYXQgYSBsaXRlcmFsIGNhbiB0YWtlIG9uLiAqL1xuZXhwb3J0IHR5cGUgTGl0ZXJhbCA9XG4gICAgfCBib29sZWFuXG4gICAgfCBudW1iZXJcbiAgICB8IHN0cmluZ1xuICAgIHwgRGF0ZVRpbWVcbiAgICB8IER1cmF0aW9uXG4gICAgfCBMaW5rXG4gICAgfCBBcnJheTxMaXRlcmFsPlxuICAgIHwgRGF0YU9iamVjdFxuICAgIHwgRnVuY3Rpb25cbiAgICB8IG51bGxcbiAgICB8IEhUTUxFbGVtZW50XG4gICAgfCBXaWRnZXQ7XG5cbi8qKiBBIGdyb3VwaW5nIG9uIGEgdHlwZSB3aGljaCBzdXBwb3J0cyByZWN1cnNpdmVseS1uZXN0ZWQgZ3JvdXBzLiAqL1xuZXhwb3J0IHR5cGUgR3JvdXBFbGVtZW50PFQ+ID0geyBrZXk6IExpdGVyYWw7IHJvd3M6IEdyb3VwaW5nPFQ+IH07XG5leHBvcnQgdHlwZSBHcm91cGluZzxUPiA9IFRbXSB8IEdyb3VwRWxlbWVudDxUPltdO1xuXG4vKiogTWFwcyB0aGUgc3RyaW5nIHR5cGUgdG8gaXQncyBleHRlcm5hbCwgQVBJLWZhY2luZyByZXByZXNlbnRhdGlvbi4gKi9cbmV4cG9ydCB0eXBlIExpdGVyYWxSZXByPFQgZXh0ZW5kcyBMaXRlcmFsVHlwZT4gPSBUIGV4dGVuZHMgXCJib29sZWFuXCJcbiAgICA/IGJvb2xlYW5cbiAgICA6IFQgZXh0ZW5kcyBcIm51bWJlclwiXG4gICAgPyBudW1iZXJcbiAgICA6IFQgZXh0ZW5kcyBcInN0cmluZ1wiXG4gICAgPyBzdHJpbmdcbiAgICA6IFQgZXh0ZW5kcyBcImR1cmF0aW9uXCJcbiAgICA/IER1cmF0aW9uXG4gICAgOiBUIGV4dGVuZHMgXCJkYXRlXCJcbiAgICA/IERhdGVUaW1lXG4gICAgOiBUIGV4dGVuZHMgXCJudWxsXCJcbiAgICA/IG51bGxcbiAgICA6IFQgZXh0ZW5kcyBcImxpbmtcIlxuICAgID8gTGlua1xuICAgIDogVCBleHRlbmRzIFwiYXJyYXlcIlxuICAgID8gQXJyYXk8TGl0ZXJhbD5cbiAgICA6IFQgZXh0ZW5kcyBcIm9iamVjdFwiXG4gICAgPyBSZWNvcmQ8c3RyaW5nLCBMaXRlcmFsPlxuICAgIDogVCBleHRlbmRzIFwiZnVuY3Rpb25cIlxuICAgID8gRnVuY3Rpb25cbiAgICA6IFQgZXh0ZW5kcyBcImh0bWxcIlxuICAgID8gSFRNTEVsZW1lbnRcbiAgICA6IFQgZXh0ZW5kcyBcIndpZGdldFwiXG4gICAgPyBXaWRnZXRcbiAgICA6IGFueTtcblxuLyoqIEEgd3JhcHBlZCBsaXRlcmFsIHZhbHVlIHdoaWNoIGNhbiBiZSBzd2l0Y2hlZCBvbi4gKi9cbmV4cG9ydCB0eXBlIFdyYXBwZWRMaXRlcmFsID1cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwic3RyaW5nXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIm51bWJlclwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJib29sZWFuXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImRhdGVcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiZHVyYXRpb25cIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwibGlua1wiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJhcnJheVwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJvYmplY3RcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiaHRtbFwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJ3aWRnZXRcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiZnVuY3Rpb25cIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwibnVsbFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBMaXRlcmFsV3JhcHBlcjxUIGV4dGVuZHMgTGl0ZXJhbFR5cGU+IHtcbiAgICB0eXBlOiBUO1xuICAgIHZhbHVlOiBMaXRlcmFsUmVwcjxUPjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWYWx1ZXMge1xuICAgIC8qKiBDb252ZXJ0IGFuIGFyYml0cmFyeSB2YWx1ZSBpbnRvIGEgcmVhc29uYWJsZSwgTWFya2Rvd24tZnJpZW5kbHkgc3RyaW5nIGlmIHBvc3NpYmxlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhcbiAgICAgICAgZmllbGQ6IGFueSxcbiAgICAgICAgc2V0dGluZzogUXVlcnlTZXR0aW5ncyA9IERFRkFVTFRfUVVFUllfU0VUVElOR1MsXG4gICAgICAgIHJlY3Vyc2l2ZTogYm9vbGVhbiA9IGZhbHNlXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHdyYXBwZWQgPSB3cmFwVmFsdWUoZmllbGQpO1xuICAgICAgICBpZiAoIXdyYXBwZWQpIHJldHVybiBzZXR0aW5nLnJlbmRlck51bGxBcztcblxuICAgICAgICBzd2l0Y2ggKHdyYXBwZWQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZy5yZW5kZXJOdWxsQXM7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiICsgd3JhcHBlZC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUub3V0ZXJIVE1MO1xuICAgICAgICAgICAgY2FzZSBcIndpZGdldFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLm1hcmtkb3duKCk7XG4gICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLm1hcmtkb3duKCk7XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8ZnVuY3Rpb24+XCI7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVjdXJzaXZlKSByZXN1bHQgKz0gXCJbXCI7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdyYXBwZWQudmFsdWUubWFwKGYgPT4gdG9TdHJpbmcoZiwgc2V0dGluZywgdHJ1ZSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdXJzaXZlKSByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBcInsgXCIgK1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh3cmFwcGVkLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlID0+IGVbMF0gKyBcIjogXCIgKyB0b1N0cmluZyhlWzFdLCBzZXR0aW5nLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIiB9XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICBpZiAod3JhcHBlZC52YWx1ZS5zZWNvbmQgPT0gMCAmJiB3cmFwcGVkLnZhbHVlLmhvdXIgPT0gMCAmJiB3cmFwcGVkLnZhbHVlLm1pbnV0ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLnRvRm9ybWF0KHNldHRpbmcuZGVmYXVsdERhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLnRvRm9ybWF0KHNldHRpbmcuZGVmYXVsdERhdGVUaW1lRm9ybWF0KTtcbiAgICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJNaW5pbWFsRHVyYXRpb24od3JhcHBlZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogV3JhcCBhIGxpdGVyYWwgdmFsdWUgc28geW91IGNhbiBzd2l0Y2ggb24gaXQgZWFzaWx5LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiB3cmFwVmFsdWUodmFsOiBMaXRlcmFsKTogV3JhcHBlZExpdGVyYWwgfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoaXNOdWxsKHZhbCkpIHJldHVybiB7IHR5cGU6IFwibnVsbFwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHZhbCkpIHJldHVybiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4odmFsKSkgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNEdXJhdGlvbih2YWwpKSByZXR1cm4geyB0eXBlOiBcImR1cmF0aW9uXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiZGF0ZVwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzV2lkZ2V0KHZhbCkpIHJldHVybiB7IHR5cGU6IFwid2lkZ2V0XCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheSh2YWwpKSByZXR1cm4geyB0eXBlOiBcImFycmF5XCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNMaW5rKHZhbCkpIHJldHVybiB7IHR5cGU6IFwibGlua1wiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsKSkgcmV0dXJuIHsgdHlwZTogXCJmdW5jdGlvblwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzSHRtbCh2YWwpKSByZXR1cm4geyB0eXBlOiBcImh0bWxcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpKSByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiogUmVjdXJzaXZlbHkgbWFwIGNvbXBsZXggb2JqZWN0cyBhdCB0aGUgbGVhdmVzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBtYXBMZWF2ZXModmFsOiBMaXRlcmFsLCBmdW5jOiAodDogTGl0ZXJhbCkgPT4gTGl0ZXJhbCk6IExpdGVyYWwge1xuICAgICAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDogRGF0YU9iamVjdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHJlc3VsdFtrZXldID0gbWFwTGVhdmVzKHZhbHVlLCBmdW5jKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBMaXRlcmFsW10gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbCkgcmVzdWx0LnB1c2gobWFwTGVhdmVzKHZhbHVlLCBmdW5jKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmModmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDb21wYXJlIHR3byBhcmJpdHJhcnkgSmF2YVNjcmlwdCB2YWx1ZXMuIFByb2R1Y2VzIGEgdG90YWwgb3JkZXJpbmcgb3ZlciBBTlkgcG9zc2libGUgZGF0YXZpZXcgdmFsdWUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWYWx1ZSh2YWwxOiBMaXRlcmFsLCB2YWwyOiBMaXRlcmFsLCBsaW5rTm9ybWFsaXplcj86IChsaW5rOiBzdHJpbmcpID0+IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIC8vIEhhbmRsZSB1bmRlZmluZWQvbnVsbHMgZmlyc3QuXG4gICAgICAgIGlmICh2YWwxID09PSB1bmRlZmluZWQpIHZhbDEgPSBudWxsO1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB2YWwyID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbDEgPT09IG51bGwgJiYgdmFsMiA9PT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgICAgIGVsc2UgaWYgKHZhbDEgPT09IG51bGwpIHJldHVybiAtMTtcbiAgICAgICAgZWxzZSBpZiAodmFsMiA9PT0gbnVsbCkgcmV0dXJuIDE7XG5cbiAgICAgICAgLy8gQSBub24tbnVsbCB2YWx1ZSBub3cgd2hpY2ggd2UgY2FuIHdyYXAgJiBjb21wYXJlIG9uLlxuICAgICAgICBsZXQgd3JhcDEgPSB3cmFwVmFsdWUodmFsMSk7XG4gICAgICAgIGxldCB3cmFwMiA9IHdyYXBWYWx1ZSh2YWwyKTtcblxuICAgICAgICBpZiAod3JhcDEgPT09IHVuZGVmaW5lZCAmJiB3cmFwMiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgICAgICAgZWxzZSBpZiAod3JhcDEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgICAgICBlbHNlIGlmICh3cmFwMiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcblxuICAgICAgICAvLyBTaG9ydC1jaXJjdWl0IG9uIGRpZmZlcmVudCB0eXBlcyBvciBvbiByZWZlcmVuY2UgZXF1YWxpdHkuXG4gICAgICAgIGlmICh3cmFwMS50eXBlICE9IHdyYXAyLnR5cGUpIHJldHVybiB3cmFwMS50eXBlLmxvY2FsZUNvbXBhcmUod3JhcDIudHlwZSk7XG4gICAgICAgIGlmICh3cmFwMS52YWx1ZSA9PT0gd3JhcDIudmFsdWUpIHJldHVybiAwO1xuXG4gICAgICAgIHN3aXRjaCAod3JhcDEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwMS52YWx1ZS5sb2NhbGVDb21wYXJlKHdyYXAyLnZhbHVlIGFzIHN0cmluZyk7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAxLnZhbHVlIDwgKHdyYXAyLnZhbHVlIGFzIG51bWJlcikpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3cmFwMS52YWx1ZSA9PSAod3JhcDIudmFsdWUgYXMgbnVtYmVyKSkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBpZiAod3JhcDEudmFsdWUgPT0gd3JhcDIudmFsdWUpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHdyYXAxLnZhbHVlID8gMSA6IC0xO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICBsZXQgbGluazEgPSB3cmFwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGluazIgPSB3cmFwMi52YWx1ZSBhcyBMaW5rO1xuICAgICAgICAgICAgICAgIGxldCBub3JtYWxpemUgPSBsaW5rTm9ybWFsaXplciA/PyAoKHg6IHN0cmluZykgPT4geCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBjb21wYXJlIGJ5IGZpbGUgbmFtZSBvciBkaXNwbGF5LCBzaW5jZSB0aGF0IHdvdWxkIGJyZWFrIGxpbmsgZXF1YWxpdHkuIENvbXBhcmUgYnkgcGF0aC5cbiAgICAgICAgICAgICAgICBsZXQgcGF0aENvbXBhcmUgPSBub3JtYWxpemUobGluazEucGF0aCkubG9jYWxlQ29tcGFyZShub3JtYWxpemUobGluazIucGF0aCkpO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29tcGFyZSAhPSAwKSByZXR1cm4gcGF0aENvbXBhcmU7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGNvbXBhcmUgYnkgdHlwZS5cbiAgICAgICAgICAgICAgICBsZXQgdHlwZUNvbXBhcmUgPSBsaW5rMS50eXBlLmxvY2FsZUNvbXBhcmUobGluazIudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVDb21wYXJlICE9IDApIHJldHVybiB0eXBlQ29tcGFyZTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gY29tcGFyZSBieSBzdWJwYXRoIGV4aXN0ZW5jZS5cbiAgICAgICAgICAgICAgICBpZiAobGluazEuc3VicGF0aCAmJiAhbGluazIuc3VicGF0aCkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rMS5zdWJwYXRoICYmIGxpbmsyLnN1YnBhdGgpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmsxLnN1YnBhdGggJiYgIWxpbmsyLnN1YnBhdGgpIHJldHVybiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgYm90aCBoYXZlIGEgc3VicGF0aCwgY29tcGFyZSBieSBzdWJwYXRoLlxuICAgICAgICAgICAgICAgIHJldHVybiAobGluazEuc3VicGF0aCA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGxpbmsyLnN1YnBhdGggPz8gXCJcIik7XG4gICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwMS52YWx1ZSA8ICh3cmFwMi52YWx1ZSBhcyBEYXRlVGltZSlcbiAgICAgICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgICAgICA6IHdyYXAxLnZhbHVlLmVxdWFscyh3cmFwMi52YWx1ZSBhcyBEYXRlVGltZSlcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwMS52YWx1ZSA8ICh3cmFwMi52YWx1ZSBhcyBEdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgICAgICA6IHdyYXAxLnZhbHVlLmVxdWFscyh3cmFwMi52YWx1ZSBhcyBEdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGxldCBmMSA9IHdyYXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBmMiA9IHdyYXAyLnZhbHVlIGFzIGFueVtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBNYXRoLm1pbihmMS5sZW5ndGgsIGYyLmxlbmd0aCk7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbXAgPSBjb21wYXJlVmFsdWUoZjFbaW5kZXhdLCBmMltpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAhPSAwKSByZXR1cm4gY29tcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYxLmxlbmd0aCAtIGYyLmxlbmd0aDtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBsZXQgbzEgPSB3cmFwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgbzIgPSB3cmFwMi52YWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgICAgICAgICAgICAgIGxldCBrMSA9IEFycmF5LmZyb20oT2JqZWN0LmtleXMobzEpKTtcbiAgICAgICAgICAgICAgICBsZXQgazIgPSBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG8yKSk7XG4gICAgICAgICAgICAgICAgazEuc29ydCgpO1xuICAgICAgICAgICAgICAgIGsyLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgIGxldCBrZXlDb21wYXJlID0gY29tcGFyZVZhbHVlKGsxLCBrMik7XG4gICAgICAgICAgICAgICAgaWYgKGtleUNvbXBhcmUgIT0gMCkgcmV0dXJuIGtleUNvbXBhcmU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgazEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbXAgPSBjb21wYXJlVmFsdWUobzFba2V5XSwgbzJba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICE9IDApIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSBcIndpZGdldFwiOlxuICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgRGF0YXZlaXcgdHlwZSBmb3IgYW4gYXJiaXRyYXJ5IHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiB0eXBlT2YodmFsOiBhbnkpOiBMaXRlcmFsVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB3cmFwVmFsdWUodmFsKT8udHlwZTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcInRydXRoeVwiIChpLmUuLCBpcyBub24tbnVsbCBhbmQgaGFzIGRhdGEgaW4gaXQpLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc1RydXRoeShmaWVsZDogTGl0ZXJhbCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgd3JhcHBlZCA9IHdyYXBWYWx1ZShmaWVsZCk7XG4gICAgICAgIGlmICghd3JhcHBlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAod3JhcHBlZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUgIT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhd3JhcHBlZC52YWx1ZS5wYXRoO1xuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS50b01pbGxpcygpICE9IDA7XG4gICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5hcyhcInNlY29uZHNcIikgIT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMod3JhcHBlZC52YWx1ZSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICBjYXNlIFwid2lkZ2V0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBEZWVwIGNvcHkgYSBmaWVsZC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZGVlcENvcHk8VCBleHRlbmRzIExpdGVyYWw+KGZpZWxkOiBUKTogVCB7XG4gICAgICAgIGlmIChmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmllbGQ7XG5cbiAgICAgICAgaWYgKFZhbHVlcy5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIChbXSBhcyBMaXRlcmFsW10pLmNvbmNhdChmaWVsZC5tYXAodiA9PiBkZWVwQ29weSh2KSkpIGFzIFQ7XG4gICAgICAgIH0gZWxzZSBpZiAoVmFsdWVzLmlzT2JqZWN0KGZpZWxkKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgTGl0ZXJhbD4gPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZCkpIHJlc3VsdFtrZXldID0gZGVlcENvcHkodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyBUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbDogYW55KTogdmFsIGlzIHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbDogYW55KTogdmFsIGlzIG51bWJlciB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZSh2YWw6IGFueSk6IHZhbCBpcyBEYXRlVGltZSB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBEYXRlVGltZTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNEdXJhdGlvbih2YWw6IGFueSk6IHZhbCBpcyBEdXJhdGlvbiB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNOdWxsKHZhbDogYW55KTogdmFsIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbDogYW55KTogdmFsIGlzIGFueVtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKHZhbDogYW55KTogdmFsIGlzIGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzTGluayh2YWw6IGFueSk6IHZhbCBpcyBMaW5rIHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIExpbms7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzV2lkZ2V0KHZhbDogYW55KTogdmFsIGlzIFdpZGdldCB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBXaWRnZXQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzSHRtbCh2YWw6IGFueSk6IHZhbCBpcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCAoYW5kIG5vdCBhbnkgb3RoZXIgZGF0YXZpZXctcmVjb2duaXplZCBvYmplY3QtbGlrZSB0eXBlKS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsOiBhbnkpOiB2YWwgaXMgUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICFpc0h0bWwodmFsKSAmJlxuICAgICAgICAgICAgIWlzV2lkZ2V0KHZhbCkgJiZcbiAgICAgICAgICAgICFpc0FycmF5KHZhbCkgJiZcbiAgICAgICAgICAgICFpc0R1cmF0aW9uKHZhbCkgJiZcbiAgICAgICAgICAgICFpc0RhdGUodmFsKSAmJlxuICAgICAgICAgICAgIWlzTGluayh2YWwpICYmXG4gICAgICAgICAgICB2YWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIWlzTnVsbCh2YWwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsOiBhbnkpOiB2YWwgaXMgRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy9cbi8vIEdyb3VwaW5ncyAvL1xuLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBuYW1lc3BhY2UgR3JvdXBpbmdzIHtcbiAgICAvKiogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gZ3JvdXAgZW50cnkgaXMgYSBzdGFuZGFsb25lIHZhbHVlLCBvciBhIGdyb3VwaW5nIG9mIHN1Yi1lbnRyaWVzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRHcm91cDxUPihlbnRyeTogVCB8IEdyb3VwRWxlbWVudDxUPik6IGVudHJ5IGlzIEdyb3VwRWxlbWVudDxUPiB7XG4gICAgICAgIHJldHVybiBWYWx1ZXMuaXNPYmplY3QoZW50cnkpICYmIE9iamVjdC5rZXlzKGVudHJ5KS5sZW5ndGggPT0gMiAmJiBcImtleVwiIGluIGVudHJ5ICYmIFwicm93c1wiIGluIGVudHJ5O1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBhcnJheSBpcyBhIGdyb3VwaW5nIGFycmF5LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0dyb3VwaW5nPFQ+KGVudHJ5OiBHcm91cGluZzxUPik6IGVudHJ5IGlzIEdyb3VwRWxlbWVudDxUPltdIHtcbiAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbnRyeSkgaWYgKCFpc0VsZW1lbnRHcm91cChlbGVtZW50KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKiBDb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgcmVjdXJzaXZlIGdyb3VwaW5nLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBjb3VudDxUPihlbGVtZW50czogR3JvdXBpbmc8VD4pOiBudW1iZXIge1xuICAgICAgICBpZiAoaXNHcm91cGluZyhlbGVtZW50cykpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgc3ViZ3JvdXAgb2YgZWxlbWVudHMpIHJlc3VsdCArPSBjb3VudChzdWJncm91cC5yb3dzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vXG4vLyBMSU5LIC8vXG4vLy8vLy8vLy8vXG5cbi8qKiBUaGUgT2JzaWRpYW4gJ2xpbmsnLCB1c2VkIGZvciB1bmlxdWVseSBkZXNjcmliaW5nIGEgZmlsZSwgaGVhZGVyLCBvciBibG9jay4gKi9cbmV4cG9ydCBjbGFzcyBMaW5rIHtcbiAgICAvKiogVGhlIGZpbGUgcGF0aCB0aGlzIGxpbmsgcG9pbnRzIHRvLiAqL1xuICAgIHB1YmxpYyBwYXRoOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBkaXNwbGF5IG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBsaW5rLiAqL1xuICAgIHB1YmxpYyBkaXNwbGF5Pzogc3RyaW5nO1xuICAgIC8qKiBUaGUgYmxvY2sgSUQgb3IgaGVhZGVyIHRoaXMgbGluayBwb2ludHMgdG8gd2l0aGluIGEgZmlsZSwgaWYgcmVsZXZhbnQuICovXG4gICAgcHVibGljIHN1YnBhdGg/OiBzdHJpbmc7XG4gICAgLyoqIElzIHRoaXMgbGluayBhbiBlbWJlZGRlZCBsaW5rICghKT8gKi9cbiAgICBwdWJsaWMgZW1iZWQ6IGJvb2xlYW47XG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgbGluaywgd2hpY2ggZGV0ZXJtaW5lcyB3aGF0ICdzdWJwYXRoJyByZWZlcnMgdG8sIGlmIGFueXRoaW5nLiAqL1xuICAgIHB1YmxpYyB0eXBlOiBcImZpbGVcIiB8IFwiaGVhZGVyXCIgfCBcImJsb2NrXCI7XG5cbiAgICAvKiogQ3JlYXRlIGEgbGluayB0byBhIHNwZWNpZmljIGZpbGUuICovXG4gICAgcHVibGljIHN0YXRpYyBmaWxlKHBhdGg6IHN0cmluZywgZW1iZWQ6IGJvb2xlYW4gPSBmYWxzZSwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGVtYmVkLFxuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgICAgIHN1YnBhdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGluZmVyKGxpbmtwYXRoOiBzdHJpbmcsIGVtYmVkOiBib29sZWFuID0gZmFsc2UsIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGxpbmtwYXRoLmluY2x1ZGVzKFwiI15cIikpIHtcbiAgICAgICAgICAgIGxldCBzcGxpdCA9IGxpbmtwYXRoLnNwbGl0KFwiI15cIik7XG4gICAgICAgICAgICByZXR1cm4gTGluay5ibG9jayhzcGxpdFswXSwgc3BsaXRbMV0sIGVtYmVkLCBkaXNwbGF5KTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5rcGF0aC5pbmNsdWRlcyhcIiNcIikpIHtcbiAgICAgICAgICAgIGxldCBzcGxpdCA9IGxpbmtwYXRoLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgIHJldHVybiBMaW5rLmhlYWRlcihzcGxpdFswXSwgc3BsaXRbMV0sIGVtYmVkLCBkaXNwbGF5KTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBMaW5rLmZpbGUobGlua3BhdGgsIGVtYmVkLCBkaXNwbGF5KTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgbGluayB0byBhIHNwZWNpZmljIGZpbGUgYW5kIGhlYWRlciBpbiB0aGF0IGZpbGUuICovXG4gICAgcHVibGljIHN0YXRpYyBoZWFkZXIocGF0aDogc3RyaW5nLCBoZWFkZXI6IHN0cmluZywgZW1iZWQ/OiBib29sZWFuLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIC8vIEhlYWRlcnMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIGFscGhhLW51bWVyaWMgJiB3aXRoIGV4dHJhIHNwYWNpbmcgcmVtb3ZlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBlbWJlZCxcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgICAgICBzdWJwYXRoOiBub3JtYWxpemVIZWFkZXJGb3JMaW5rKGhlYWRlciksXG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlclwiLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgbGluayB0byBhIHNwZWNpZmljIGZpbGUgYW5kIGJsb2NrIGluIHRoYXQgZmlsZS4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGJsb2NrKHBhdGg6IHN0cmluZywgYmxvY2tJZDogc3RyaW5nLCBlbWJlZD86IGJvb2xlYW4sIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBlbWJlZCxcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgICAgICBzdWJwYXRoOiBibG9ja0lkLFxuICAgICAgICAgICAgdHlwZTogXCJibG9ja1wiLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZyb21PYmplY3Qob2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayhvYmplY3QpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoZmllbGRzOiBQYXJ0aWFsPExpbms+KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZmllbGRzKTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIGZvciBsaW5rIGVxdWFsaXR5IChpLmUuLCB0aGF0IHRoZSBsaW5rcyBhcmUgcG9pbnRpbmcgdG8gdGhlIHNhbWUgZXhhY3QgbG9jYXRpb24pLiAqL1xuICAgIHB1YmxpYyBlcXVhbHMob3RoZXI6IExpbmspOiBib29sZWFuIHtcbiAgICAgICAgaWYgKG90aGVyID09IHVuZGVmaW5lZCB8fCBvdGhlciA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aCA9PSBvdGhlci5wYXRoICYmIHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIHRoaXMuc3VicGF0aCA9PSBvdGhlci5zdWJwYXRoO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoaXMgbGluayB0byBpdCdzIG1hcmtkb3duIHJlcHJlc2VudGF0aW9uLiAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZG93bigpO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoaXMgbGluayB0byBhIHJhdyBvYmplY3Qgd2hpY2ggaXMgc2VyaWFsaXphdGlvbi1mcmllbmRseS4gKi9cbiAgICBwdWJsaWMgdG9PYmplY3QoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHRoaXMucGF0aCwgdHlwZTogdGhpcy50eXBlLCBzdWJwYXRoOiB0aGlzLnN1YnBhdGgsIGRpc3BsYXk6IHRoaXMuZGlzcGxheSwgZW1iZWQ6IHRoaXMuZW1iZWQgfTtcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIHRoaXMgbGluayB3aXRoIGEgbmV3IHBhdGguICovXG4gICAgLy9AdHMtaWdub3JlOyBlcnJvciBhcHBlYXJlZCBhZnRlciB1cGRhdGluZyBPYnNpZGlhbiB0byAwLjE1LjQ7IGl0IGFsc28gdXBkYXRlZCBvdGhlciBwYWNrYWdlcyBidXQgZGlkbid0IHNheSB3aGljaFxuICAgIHB1YmxpYyB3aXRoUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgcGF0aCB9KSk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybiBhIG5ldyBsaW5rIHdoaWNoIHBvaW50cyB0byB0aGUgc2FtZSBsb2NhdGlvbiBidXQgd2l0aCBhIG5ldyBkaXNwbGF5IHZhbHVlLiAqL1xuICAgIHB1YmxpYyB3aXRoRGlzcGxheShkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayhPYmplY3QuYXNzaWduKHt9LCB0aGlzLCB7IGRpc3BsYXkgfSkpO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IGEgZmlsZSBsaW5rIGludG8gYSBsaW5rIHRvIGEgc3BlY2lmaWMgaGVhZGVyLiAqL1xuICAgIHB1YmxpYyB3aXRoSGVhZGVyKGhlYWRlcjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBMaW5rLmhlYWRlcih0aGlzLnBhdGgsIGhlYWRlciwgdGhpcy5lbWJlZCwgdGhpcy5kaXNwbGF5KTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCBhbnkgbGluayBpbnRvIGEgbGluayB0byBpdHMgZmlsZS4gKi9cbiAgICBwdWJsaWMgdG9GaWxlKCkge1xuICAgICAgICByZXR1cm4gTGluay5maWxlKHRoaXMucGF0aCwgdGhpcy5lbWJlZCwgdGhpcy5kaXNwbGF5KTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgaW50byBhbiBlbWJlZGRlZCBsaW5rLiAqL1xuICAgIHB1YmxpYyB0b0VtYmVkKCk6IExpbmsge1xuICAgICAgICBpZiAodGhpcy5lbWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGluayA9IG5ldyBMaW5rKHRoaXMpO1xuICAgICAgICAgICAgbGluay5lbWJlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbGluaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoaXMgbGluayBpbnRvIGEgbm9uLWVtYmVkZGVkIGxpbmsuICovXG4gICAgcHVibGljIGZyb21FbWJlZCgpOiBMaW5rIHtcbiAgICAgICAgaWYgKCF0aGlzLmVtYmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gbmV3IExpbmsodGhpcyk7XG4gICAgICAgICAgICBsaW5rLmVtYmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbGluaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoaXMgbGluayB0byBtYXJrZG93biBzbyBpdCBjYW4gYmUgcmVuZGVyZWQuICovXG4gICAgcHVibGljIG1hcmtkb3duKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXN1bHQgPSAodGhpcy5lbWJlZCA/IFwiIVwiIDogXCJcIikgKyBcIltbXCIgKyB0aGlzLm9ic2lkaWFuTGluaygpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcInxcIiArIHRoaXMuZGlzcGxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcInxcIiArIGdldEZpbGVUaXRsZSh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcImhlYWRlclwiIHx8IHRoaXMudHlwZSA9PSBcImJsb2NrXCIpIHJlc3VsdCArPSBcIiA+IFwiICsgdGhpcy5zdWJwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IFwiXV1cIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGUgaW5uZXIgcGFydCBvZiB0aGUgbGluayB0byBzb21ldGhpbmcgdGhhdCBPYnNpZGlhbiBjYW4gb3BlbiAvIHVuZGVyc3RhbmQuICovXG4gICAgcHVibGljIG9ic2lkaWFuTGluaygpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBlc2NhcGVkID0gdGhpcy5wYXRoLnJlcGxhY2UoXCJ8XCIsIFwiXFxcXHxcIik7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJoZWFkZXJcIikgcmV0dXJuIGVzY2FwZWQgKyBcIiNcIiArIHRoaXMuc3VicGF0aD8ucmVwbGFjZShcInxcIiwgXCJcXFxcfFwiKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcImJsb2NrXCIpIHJldHVybiBlc2NhcGVkICsgXCIjXlwiICsgdGhpcy5zdWJwYXRoPy5yZXBsYWNlKFwifFwiLCBcIlxcXFx8XCIpO1xuICAgICAgICBlbHNlIHJldHVybiBlc2NhcGVkO1xuICAgIH1cblxuICAgIC8qKiBUaGUgc3RyaXBwZWQgbmFtZSBvZiB0aGUgZmlsZSB0aGlzIGxpbmsgcG9pbnRzIHRvLiAqL1xuICAgIHB1YmxpYyBmaWxlTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gZ2V0RmlsZVRpdGxlKHRoaXMucGF0aCkucmVwbGFjZShcIi5tZFwiLCBcIlwiKTtcbiAgICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXSURHRVQgQkFTRSAvL1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIHRyaXZpYWwgYmFzZSBjbGFzcyB3aGljaCBqdXN0IGRlZmluZXMgdGhlICckd2lkZ2V0JyBpZGVudGlmaWVyIHR5cGUuIFN1YnR5cGVzIG9mXG4gKiB3aWRnZXQgYXJlIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgd2hhdGV2ZXIgbWV0YWRhdGEgaXMgcmVsZXZhbnQuIElmIHlvdSB3YW50IHlvdXIgd2lkZ2V0XG4gKiB0byBoYXZlIHJlbmRlcmluZyBmdW5jdGlvbmFsaXR5ICh3aGljaCB5b3UgcHJvYmFibHkgZG8pLCB5b3Ugc2hvdWxkIGV4dGVuZCBgUmVuZGVyV2lkZ2V0YC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFdpZGdldCB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyAkd2lkZ2V0OiBzdHJpbmcpIHt9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIHJlbmRlciB0aGlzIHdpZGdldCBpbiBtYXJrZG93biwgaWYgcG9zc2libGU7IGlmIG1hcmtkb3duIGlzIG5vdCBwb3NzaWJsZSxcbiAgICAgKiB0aGVuIHRoaXMgd2lsbCBhdHRlbXB0IHRvIHJlbmRlciBhcyBIVE1MLiBOb3RlIHRoYXQgbWFueSB3aWRnZXRzIGhhdmUgaW50ZXJhY3RpdmVcbiAgICAgKiBjb21wb25lbnRzIG9yIGRpZmZpY3VsdCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYW5kIHRoZSBgbWFya2Rvd25gIGZ1bmN0aW9uIGNhbiBzaW1wbHlcbiAgICAgKiByZXR1cm4gYSBwbGFjZWhvbGRlciBpbiB0aGlzIGNhc2UgKHN1Y2ggYXMgYDxmdW5jdGlvbj5gIG9yIGA8dGFzay1saXN0PmApLlxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBtYXJrZG93bigpOiBzdHJpbmc7XG59XG5cbi8qKiBBIHRyaXZpYWwgd2lkZ2V0IHdoaWNoIHJlbmRlcnMgYSAoa2V5LCB2YWx1ZSkgcGFpciwgYW5kIGFsbG93cyBhY2Nlc3NpbmcgdGhlIGtleSBhbmQgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgTGlzdFBhaXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXQge1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMga2V5OiBMaXRlcmFsLCBwdWJsaWMgdmFsdWU6IExpdGVyYWwpIHtcbiAgICAgICAgc3VwZXIoXCJkYXRhdmlldzpsaXN0LXBhaXJcIik7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG1hcmtkb3duKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtWYWx1ZXMudG9TdHJpbmcodGhpcy5rZXkpfTogJHtWYWx1ZXMudG9TdHJpbmcodGhpcy52YWx1ZSl9YDtcbiAgICB9XG59XG5cbi8qKiBBIHNpbXBsZSB3aWRnZXQgd2hpY2ggcmVuZGVycyBhbiBleHRlcm5hbCBsaW5rLiAqL1xuZXhwb3J0IGNsYXNzIEV4dGVybmFsTGlua1dpZGdldCBleHRlbmRzIFdpZGdldCB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyB1cmw6IHN0cmluZywgcHVibGljIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoXCJkYXRhdmlldzpleHRlcm5hbC1saW5rXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBtYXJrZG93bigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuZGlzcGxheSA/PyB0aGlzLnVybH1dKCR7dGhpcy51cmx9KWA7XG4gICAgfVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIFdpZGdldHMge1xuICAgIC8qKiBDcmVhdGUgYSBsaXN0IHBhaXIgd2lkZ2V0IG1hdGNoaW5nIHRoZSBnaXZlbiBrZXkgYW5kIHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBsaXN0UGFpcihrZXk6IExpdGVyYWwsIHZhbHVlOiBMaXRlcmFsKTogTGlzdFBhaXJXaWRnZXQge1xuICAgICAgICByZXR1cm4gbmV3IExpc3RQYWlyV2lkZ2V0KGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gZXh0ZXJuYWwgbGluayB3aWRnZXQgd2hpY2ggcmVuZGVycyBhbiBleHRlcm5hbCBPYnNpZGlhbiBsaW5rLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBleHRlcm5hbExpbmsodXJsOiBzdHJpbmcsIGRpc3BsYXk/OiBzdHJpbmcpOiBFeHRlcm5hbExpbmtXaWRnZXQge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVybmFsTGlua1dpZGdldCh1cmwsIGRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDaGVja3MgaWYgdGhlIGdpdmVuIHdpZGdldCBpcyBhIGxpc3QgcGFpciB3aWRnZXQuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzTGlzdFBhaXIod2lkZ2V0OiBXaWRnZXQpOiB3aWRnZXQgaXMgTGlzdFBhaXJXaWRnZXQge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LiR3aWRnZXQgPT09IFwiZGF0YXZpZXc6bGlzdC1wYWlyXCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxMaW5rKHdpZGdldDogV2lkZ2V0KTogd2lkZ2V0IGlzIEV4dGVybmFsTGlua1dpZGdldCB7XG4gICAgICAgIHJldHVybiB3aWRnZXQuJHdpZGdldCA9PT0gXCJkYXRhdmlldzpleHRlcm5hbC1saW5rXCI7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHdpZGdldCBpcyBhbnkga2luZCBvZiBidWlsdC1pbiB3aWRnZXQgd2l0aCBzcGVjaWFsIHJlbmRlcmluZyBoYW5kbGluZy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNCdWlsdGluKHdpZGdldDogV2lkZ2V0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc0xpc3RQYWlyKHdpZGdldCkgfHwgaXNFeHRlcm5hbExpbmsod2lkZ2V0KTtcbiAgICB9XG59XG4iLCAiLyoqIERlZmluZXMgdGhlIEFTVCBmb3IgYSBmaWVsZCB3aGljaCBjYW4gYmUgZXZhbHVhdGVkLiAqL1xuaW1wb3J0IHsgTGl0ZXJhbCB9IGZyb20gXCJkYXRhLW1vZGVsL3ZhbHVlXCI7XG5cbi8qKiBDb21wYXJpc29uIG9wZXJhdG9ycyB3aGljaCB5aWVsZCB0cnVlL2ZhbHNlLiAqL1xuZXhwb3J0IHR5cGUgQ29tcGFyZU9wID0gXCI+XCIgfCBcIj49XCIgfCBcIjw9XCIgfCBcIjxcIiB8IFwiPVwiIHwgXCIhPVwiO1xuLyoqIEFyaXRobWV0aWMgb3BlcmF0b3JzIHdoaWNoIHlpZWxkIG51bWJlcnMgYW5kIG90aGVyIHZhbHVlcy4gKi9cbmV4cG9ydCB0eXBlIEFyaXRobWV0aWNPcCA9IFwiK1wiIHwgXCItXCIgfCBcIipcIiB8IFwiL1wiIHwgXCIlXCIgfCBcIiZcIiB8IFwifFwiO1xuLyoqIEFsbCB2YWxpZCBiaW5hcnkgb3BlcmF0b3JzLiAqL1xuZXhwb3J0IHR5cGUgQmluYXJ5T3AgPSBDb21wYXJlT3AgfCBBcml0aG1ldGljT3A7XG4vKiogQSAocG90ZW50aWFsbHkgY29tcHV0ZWQpIGZpZWxkIHRvIHNlbGVjdCBvciBjb21wYXJlIGFnYWluc3QuICovXG5leHBvcnQgdHlwZSBGaWVsZCA9XG4gICAgfCBCaW5hcnlPcEZpZWxkXG4gICAgfCBWYXJpYWJsZUZpZWxkXG4gICAgfCBMaXRlcmFsRmllbGRcbiAgICB8IEZ1bmN0aW9uRmllbGRcbiAgICB8IEluZGV4RmllbGRcbiAgICB8IE5lZ2F0ZWRGaWVsZFxuICAgIHwgTGFtYmRhRmllbGRcbiAgICB8IE9iamVjdEZpZWxkXG4gICAgfCBMaXN0RmllbGQ7XG5cbi8qKiBMaXRlcmFsIHJlcHJlc2VudGF0aW9uIG9mIHNvbWUgZmllbGQgdHlwZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGl0ZXJhbEZpZWxkIHtcbiAgICB0eXBlOiBcImxpdGVyYWxcIjtcbiAgICB2YWx1ZTogTGl0ZXJhbDtcbn1cblxuLyoqIEEgdmFyaWFibGUgZmllbGQgZm9yIGEgdmFyaWFibGUgd2l0aCBhIGdpdmVuIG5hbWUuICovXG5leHBvcnQgaW50ZXJmYWNlIFZhcmlhYmxlRmllbGQge1xuICAgIHR5cGU6IFwidmFyaWFibGVcIjtcbiAgICBuYW1lOiBzdHJpbmc7XG59XG5cbi8qKiBBIGxpc3QsIHdoaWNoIGlzIGFuIG9yZGVyZWQgY29sbGVjdGlvbiBvZiBmaWVsZHMuICovXG5leHBvcnQgaW50ZXJmYWNlIExpc3RGaWVsZCB7XG4gICAgdHlwZTogXCJsaXN0XCI7XG4gICAgdmFsdWVzOiBGaWVsZFtdO1xufVxuXG4vKiogQW4gb2JqZWN0LCB3aGljaCBpcyBhIG1hcHBpbmcgb2YgbmFtZSB0byBmaWVsZC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0RmllbGQge1xuICAgIHR5cGU6IFwib2JqZWN0XCI7XG4gICAgdmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBGaWVsZD47XG59XG5cbi8qKiBBIGJpbmFyeSBvcGVyYXRvciBmaWVsZCB3aGljaCBjb21iaW5lcyB0d28gc3Vibm9kZXMgc29tZWhvdy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmluYXJ5T3BGaWVsZCB7XG4gICAgdHlwZTogXCJiaW5hcnlvcFwiO1xuICAgIGxlZnQ6IEZpZWxkO1xuICAgIHJpZ2h0OiBGaWVsZDtcbiAgICBvcDogQmluYXJ5T3A7XG59XG5cbi8qKiBBIGZ1bmN0aW9uIGZpZWxkIHdoaWNoIGNhbGxzIGEgZnVuY3Rpb24gb24gMCBvciBtb3JlIGFyZ3VtZW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25GaWVsZCB7XG4gICAgdHlwZTogXCJmdW5jdGlvblwiO1xuICAgIC8qKiBFaXRoZXIgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCwgb3IgYSBGdW5jdGlvbiBvYmplY3QuICovXG4gICAgZnVuYzogRmllbGQ7XG4gICAgLyoqIFRoZSBhcmd1bWVudHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gKi9cbiAgICBhcmd1bWVudHM6IEZpZWxkW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGFtYmRhRmllbGQge1xuICAgIHR5cGU6IFwibGFtYmRhXCI7XG4gICAgLyoqIEFuIG9yZGVyZWQgbGlzdCBvZiBuYW1lZCBhcmd1bWVudHMuICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmdbXTtcbiAgICAvKiogVGhlIGZpZWxkIHdoaWNoIHNob3VsZCBiZSBldmFsdWF0ZWQgd2l0aCB0aGUgYXJndW1lbnRzIGluIGNvbnRleHQuICovXG4gICAgdmFsdWU6IEZpZWxkO1xufVxuXG4vKiogQSBmaWVsZCB3aGljaCBpbmRleGVzIGEgdmFyaWFibGUgaW50byBhbm90aGVyIHZhcmlhYmxlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmRleEZpZWxkIHtcbiAgICB0eXBlOiBcImluZGV4XCI7XG4gICAgLyoqIFRoZSBmaWVsZCB0byBpbmRleCBpbnRvLiAqL1xuICAgIG9iamVjdDogRmllbGQ7XG4gICAgLyoqIFRoZSBpbmRleC4gKi9cbiAgICBpbmRleDogRmllbGQ7XG59XG5cbi8qKiBBIGZpZWxkIHdoaWNoIG5lZ2F0ZXMgdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBmaWVsZC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmVnYXRlZEZpZWxkIHtcbiAgICB0eXBlOiBcIm5lZ2F0ZWRcIjtcbiAgICAvKiogVGhlIGNoaWxkIGZpZWxkIHRvIG5lZ2F0ZWQuICovXG4gICAgY2hpbGQ6IEZpZWxkO1xufVxuXG4vKiogVXRpbGl0eSBtZXRob2RzIGZvciBjcmVhdGluZyAmIGNvbXBhcmluZyBmaWVsZHMuICovXG5leHBvcnQgbmFtZXNwYWNlIEZpZWxkcyB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWU6IHN0cmluZyk6IFZhcmlhYmxlRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInZhcmlhYmxlXCIsIG5hbWUgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZTogTGl0ZXJhbCk6IExpdGVyYWxGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZSB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBiaW5hcnlPcChsZWZ0OiBGaWVsZCwgb3A6IEJpbmFyeU9wLCByaWdodDogRmllbGQpOiBGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYmluYXJ5b3BcIiwgbGVmdCwgb3AsIHJpZ2h0IH0gYXMgQmluYXJ5T3BGaWVsZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaW5kZXgob2JqOiBGaWVsZCwgaW5kZXg6IEZpZWxkKTogSW5kZXhGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW5kZXhcIiwgb2JqZWN0OiBvYmosIGluZGV4IH07XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnRzIGEgc3RyaW5nIGluIGRvdC1ub3RhdGlvbi1mb3JtYXQgaW50byBhIHZhcmlhYmxlIHdoaWNoIGluZGV4ZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGluZGV4VmFyaWFibGUobmFtZTogc3RyaW5nKTogRmllbGQge1xuICAgICAgICBsZXQgcGFydHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgbGV0IHJlc3VsdDogRmllbGQgPSBGaWVsZHMudmFyaWFibGUocGFydHNbMF0pO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgcGFydHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBGaWVsZHMuaW5kZXgocmVzdWx0LCBGaWVsZHMubGl0ZXJhbChwYXJ0c1tpbmRleF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxhbWJkYShhcmdzOiBzdHJpbmdbXSwgdmFsdWU6IEZpZWxkKTogTGFtYmRhRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImxhbWJkYVwiLCBhcmd1bWVudHM6IGFyZ3MsIHZhbHVlIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZ1bmMoZnVuYzogRmllbGQsIGFyZ3M6IEZpZWxkW10pOiBGdW5jdGlvbkZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJmdW5jdGlvblwiLCBmdW5jLCBhcmd1bWVudHM6IGFyZ3MgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gbGlzdCh2YWx1ZXM6IEZpZWxkW10pOiBMaXN0RmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpc3RcIiwgdmFsdWVzIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIG9iamVjdCh2YWx1ZXM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPik6IE9iamVjdEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgdmFsdWVzIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShjaGlsZDogRmllbGQpOiBOZWdhdGVkRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5lZ2F0ZWRcIiwgY2hpbGQgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNDb21wYXJlT3Aob3A6IEJpbmFyeU9wKTogb3AgaXMgQ29tcGFyZU9wIHtcbiAgICAgICAgcmV0dXJuIG9wID09IFwiPD1cIiB8fCBvcCA9PSBcIjxcIiB8fCBvcCA9PSBcIj5cIiB8fCBvcCA9PSBcIj49XCIgfHwgb3AgPT0gXCIhPVwiIHx8IG9wID09IFwiPVwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBjb25zdCBOVUxMID0gRmllbGRzLmxpdGVyYWwobnVsbCk7XG59XG4iLCAiLyoqIEFTVCBpbXBsZW1lbnRhdGlvbiBmb3IgcXVlcmllcyBvdmVyIGRhdGEgc291cmNlcy4gKi9cblxuLyoqIFRoZSBzb3VyY2Ugb2YgZmlsZXMgZm9yIGEgcXVlcnkuICovXG5leHBvcnQgdHlwZSBTb3VyY2UgPSBUYWdTb3VyY2UgfCBDc3ZTb3VyY2UgfCBGb2xkZXJTb3VyY2UgfCBMaW5rU291cmNlIHwgRW1wdHlTb3VyY2UgfCBOZWdhdGVkU291cmNlIHwgQmluYXJ5T3BTb3VyY2U7XG4vKiogVmFsaWQgb3BlcmF0aW9ucyBmb3IgY29tYmluaW5nIHNvdXJjZXMuICovXG5leHBvcnQgdHlwZSBTb3VyY2VPcCA9IFwiJlwiIHwgXCJ8XCI7XG5cbi8qKiBBIHRhZyBhcyBhIHNvdXJjZSBvZiBkYXRhLiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYWdTb3VyY2Uge1xuICAgIHR5cGU6IFwidGFnXCI7XG4gICAgLyoqIFRoZSB0YWcgdG8gc291cmNlIGZyb20uICovXG4gICAgdGFnOiBzdHJpbmc7XG59XG5cbi8qKiBBIGNzdiBhcyBhIHNvdXJjZSBvZiBkYXRhLiAqL1xuZXhwb3J0IGludGVyZmFjZSBDc3ZTb3VyY2Uge1xuICAgIHR5cGU6IFwiY3N2XCI7XG4gICAgLyoqIFRoZSBwYXRoIHRvIHRoZSBDU1YgZmlsZS4gKi9cbiAgICBwYXRoOiBzdHJpbmc7XG59XG5cbi8qKiBBIGZvbGRlciBwcmVmaXggYXMgYSBzb3VyY2Ugb2YgZGF0YS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRm9sZGVyU291cmNlIHtcbiAgICB0eXBlOiBcImZvbGRlclwiO1xuICAgIC8qKiBUaGUgZm9sZGVyIHByZWZpeCB0byBzb3VyY2UgZnJvbS4gKi9cbiAgICBmb2xkZXI6IHN0cmluZztcbn1cblxuLyoqIEVpdGhlciBpbmNvbWluZyBvciBvdXRnb2luZyBsaW5rcyB0byBhIGdpdmVuIGZpbGUuICovXG5leHBvcnQgaW50ZXJmYWNlIExpbmtTb3VyY2Uge1xuICAgIHR5cGU6IFwibGlua1wiO1xuICAgIC8qKiBUaGUgZmlsZSB0byBsb29rIGZvciBsaW5rcyB0by9mcm9tLiAgKi9cbiAgICBmaWxlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGRpcmVjdGlvbiB0byBsb29rIC0gaWYgaW5jb21pbmcsIHRoZW4gYWxsIGZpbGVzIGxpbmtpbmcgdG8gdGhlIHRhcmdldCBmaWxlLiBJZiBvdXRnb2luZywgdGhlbiBhbGwgZmlsZXNcbiAgICAgKiB3aGljaCB0aGUgZmlsZSBsaW5rcyB0by5cbiAgICAgKi9cbiAgICBkaXJlY3Rpb246IFwiaW5jb21pbmdcIiB8IFwib3V0Z29pbmdcIjtcbn1cblxuLyoqIEEgc291cmNlIHdoaWNoIGlzIGV2ZXJ5dGhpbmcgRVhDRVBUIHRoZSBmaWxlcyByZXR1cm5lZCBieSB0aGUgZ2l2ZW4gc291cmNlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZWdhdGVkU291cmNlIHtcbiAgICB0eXBlOiBcIm5lZ2F0ZVwiO1xuICAgIC8qKiBUaGUgc291cmNlIHRvIG5lZ2F0ZS4gKi9cbiAgICBjaGlsZDogU291cmNlO1xufVxuXG4vKiogQSBzb3VyY2Ugd2hpY2ggeWllbGRzIG5vdGhpbmcuICovXG5leHBvcnQgaW50ZXJmYWNlIEVtcHR5U291cmNlIHtcbiAgICB0eXBlOiBcImVtcHR5XCI7XG59XG5cbi8qKiBBIHNvdXJjZSBtYWRlIGJ5IGNvbWJpbmluZyBzdWJzb3VyY2VzIHdpdGggYSBsb2dpY2FsIG9wZXJhdG9ycy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmluYXJ5T3BTb3VyY2Uge1xuICAgIHR5cGU6IFwiYmluYXJ5b3BcIjtcbiAgICBvcDogU291cmNlT3A7XG4gICAgbGVmdDogU291cmNlO1xuICAgIHJpZ2h0OiBTb3VyY2U7XG59XG5cbi8qKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBzb3VyY2VzLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBTb3VyY2VzIHtcbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHNlYXJjaGVzIGZyb20gYSB0YWcuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHRhZyh0YWc6IHN0cmluZyk6IFRhZ1NvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidGFnXCIsIHRhZyB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggZmV0Y2hlcyBmcm9tIGEgQ1NWIGZpbGUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGNzdihwYXRoOiBzdHJpbmcpOiBDc3ZTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImNzdlwiLCBwYXRoIH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBzZWFyY2hlcyBmb3IgZmlsZXMgdW5kZXIgYSBmb2xkZXIgcHJlZml4LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBmb2xkZXIocHJlZml4OiBzdHJpbmcpOiBGb2xkZXJTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImZvbGRlclwiLCBmb2xkZXI6IHByZWZpeCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggc2VhcmNoZXMgZm9yIGZpbGVzIHdoaWNoIGxpbmsgdG8vZnJvbSBhIGdpdmVuIGZpbGUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpbmsoZmlsZTogc3RyaW5nLCBpbmNvbWluZzogYm9vbGVhbik6IExpbmtTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpbmtcIiwgZmlsZSwgZGlyZWN0aW9uOiBpbmNvbWluZyA/IFwiaW5jb21pbmdcIiA6IFwib3V0Z29pbmdcIiB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggam9pbnMgdHdvIHNvdXJjZXMgYnkgYSBsb2dpY2FsIG9wZXJhdG9yIChhbmQvb3IpLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBiaW5hcnlPcChsZWZ0OiBTb3VyY2UsIG9wOiBTb3VyY2VPcCwgcmlnaHQ6IFNvdXJjZSk6IFNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYmluYXJ5b3BcIiwgbGVmdCwgb3AsIHJpZ2h0IH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCB0YWtlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBzb3VyY2VzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBhbmQobGVmdDogU291cmNlLCByaWdodDogU291cmNlKTogU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcDogXCImXCIsIHJpZ2h0IH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCB0YWtlcyB0aGUgdW5pb24gb2YgdHdvIHNvdXJjZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIG9yKGxlZnQ6IFNvdXJjZSwgcmlnaHQ6IFNvdXJjZSk6IFNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYmluYXJ5b3BcIiwgbGVmdCwgb3A6IFwifFwiLCByaWdodCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggbmVnYXRlcyB0aGUgdW5kZXJseWluZyBzb3VyY2UuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShjaGlsZDogU291cmNlKTogTmVnYXRlZFNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibmVnYXRlXCIsIGNoaWxkIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KCk6IEVtcHR5U291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbXB0eVwiIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuaW1wb3J0IHsgTGl0ZXJhbCwgTGluayB9IGZyb20gXCJkYXRhLW1vZGVsL3ZhbHVlXCI7XG5pbXBvcnQgKiBhcyBQIGZyb20gXCJwYXJzaW1tb25cIjtcbmltcG9ydCB7IEJpbmFyeU9wLCBGaWVsZCwgRmllbGRzLCBMYW1iZGFGaWVsZCwgTGlzdEZpZWxkLCBMaXRlcmFsRmllbGQsIE9iamVjdEZpZWxkLCBWYXJpYWJsZUZpZWxkIH0gZnJvbSBcIi4vZmllbGRcIjtcbmltcG9ydCB7IEZvbGRlclNvdXJjZSwgTmVnYXRlZFNvdXJjZSwgU291cmNlLCBTb3VyY2VPcCwgU291cmNlcywgVGFnU291cmNlLCBDc3ZTb3VyY2UgfSBmcm9tIFwiZGF0YS1pbmRleC9zb3VyY2VcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUR1cmF0aW9uIH0gZnJvbSBcInV0aWwvbm9ybWFsaXplXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuaW1wb3J0IGVtb2ppUmVnZXggZnJvbSBcImVtb2ppLXJlZ2V4XCI7XG5cbi8qKiBFbW9qaSByZWdleCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGZsYWdzLiAqL1xuY29uc3QgRU1PSklfUkVHRVggPSBuZXcgUmVnRXhwKGVtb2ppUmVnZXgoKSwgXCJcIik7XG5cbi8qKiBQcm92aWRlcyBhIGxvb2t1cCB0YWJsZSBmb3IgdW5pdCBkdXJhdGlvbnMgb2YgdGhlIGdpdmVuIHR5cGUuICovXG5leHBvcnQgY29uc3QgRFVSQVRJT05fVFlQRVMgPSB7XG4gICAgeWVhcjogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuICAgIHllYXJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG4gICAgeXI6IER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSB9KSxcbiAgICB5cnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSB9KSxcblxuICAgIG1vbnRoOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuICAgIG1vbnRoczogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSB9KSxcbiAgICBtbzogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSB9KSxcbiAgICBtb3M6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG5cbiAgICB3ZWVrOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgd2Vla3M6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3azogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuICAgIHdrczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuICAgIHc6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcblxuICAgIGRheTogRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSksXG4gICAgZGF5czogRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSksXG4gICAgZDogRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSksXG5cbiAgICBob3VyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaG91cnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBocjogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuICAgIGhyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuICAgIGg6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcblxuICAgIG1pbnV0ZTogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG4gICAgbWludXRlczogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG4gICAgbWluOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcbiAgICBtaW5zOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcbiAgICBtOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcblxuICAgIHNlY29uZDogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG4gICAgc2Vjb25kczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG4gICAgc2VjOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbiAgICBzZWNzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbiAgICBzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbn07XG5cbi8qKiBTaG9ydGhhbmQgZm9yIGNvbW1vbiBkYXRlcyAocmVsYXRpdmUgdG8gcmlnaHQgbm93KS4gKi9cbmV4cG9ydCBjb25zdCBEQVRFX1NIT1JUSEFORFMgPSB7XG4gICAgbm93OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLFxuICAgIHRvZGF5OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJkYXlcIiksXG4gICAgeWVzdGVyZGF5OiAoKSA9PlxuICAgICAgICBEYXRlVGltZS5sb2NhbCgpXG4gICAgICAgICAgICAuc3RhcnRPZihcImRheVwiKVxuICAgICAgICAgICAgLm1pbnVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pKSxcbiAgICB0b21vcnJvdzogKCkgPT5cbiAgICAgICAgRGF0ZVRpbWUubG9jYWwoKVxuICAgICAgICAgICAgLnN0YXJ0T2YoXCJkYXlcIilcbiAgICAgICAgICAgIC5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pKSxcbiAgICBzb3c6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcIndlZWtcIiksXG4gICAgXCJzdGFydC1vZi13ZWVrXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcIndlZWtcIiksXG4gICAgZW93OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwid2Vla1wiKSxcbiAgICBcImVuZC1vZi13ZWVrXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJ3ZWVrXCIpLFxuICAgIHNveTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwieWVhclwiKSxcbiAgICBcInN0YXJ0LW9mLXllYXJcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwieWVhclwiKSxcbiAgICBlb3k6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJ5ZWFyXCIpLFxuICAgIFwiZW5kLW9mLXllYXJcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcInllYXJcIiksXG4gICAgc29tOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJtb250aFwiKSxcbiAgICBcInN0YXJ0LW9mLW1vbnRoXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcIm1vbnRoXCIpLFxuICAgIGVvbTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIm1vbnRoXCIpLFxuICAgIFwiZW5kLW9mLW1vbnRoXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJtb250aFwiKSxcbn07XG5cbi8qKlxuICogS2V5d29yZHMgd2hpY2ggY2Fubm90IGJlIHVzZWQgYXMgdmFyaWFibGVzIGRpcmVjdGx5LiBVc2UgYHJvdy48dGhpbmc+YCBpZiBpdCBpcyBhIHZhcmlhYmxlIHlvdSBoYXZlIGRlZmluZWQgYW5kIHdhbnRcbiAqIHRvIGFjY2Vzcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEtFWVdPUkRTID0gW1wiRlJPTVwiLCBcIldIRVJFXCIsIFwiTElNSVRcIiwgXCJHUk9VUFwiLCBcIkZMQVRURU5cIl07XG5cbi8vLy8vLy8vLy8vLy8vL1xuLy8gVXRpbGl0aWVzIC8vXG4vLy8vLy8vLy8vLy8vLy9cblxuLyoqIFNwbGl0IG9uIHVuZXNjYXBlZCBwaXBlcyBpbiBhbiBpbm5lciBsaW5rLiAqL1xuZnVuY3Rpb24gc3BsaXRPblVuZXNjYXBlZFBpcGUobGluazogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkXSB7XG4gICAgbGV0IHBpcGUgPSAtMTtcbiAgICB3aGlsZSAoKHBpcGUgPSBsaW5rLmluZGV4T2YoXCJ8XCIsIHBpcGUgKyAxKSkgPj0gMCkge1xuICAgICAgICBpZiAocGlwZSA+IDAgJiYgbGlua1twaXBlIC0gMV0gPT0gXCJcXFxcXCIpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gW2xpbmsuc3Vic3RyaW5nKDAsIHBpcGUpLnJlcGxhY2UoL1xcXFxcXHwvZywgXCJ8XCIpLCBsaW5rLnN1YnN0cmluZyhwaXBlICsgMSldO1xuICAgIH1cblxuICAgIHJldHVybiBbbGluay5yZXBsYWNlKC9cXFxcXFx8L2csIFwifFwiKSwgdW5kZWZpbmVkXTtcbn1cblxuLyoqIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGluc2lkZSBvZiBhIGxpbmsgdG8gcHVsbCBvdXQgZGlzcGxheSBuYW1lLCBzdWJwYXRoLCBldGMuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbm5lckxpbmsocmF3bGluazogc3RyaW5nKTogTGluayB7XG4gICAgbGV0IFtsaW5rLCBkaXNwbGF5XSA9IHNwbGl0T25VbmVzY2FwZWRQaXBlKHJhd2xpbmspO1xuICAgIHJldHVybiBMaW5rLmluZmVyKGxpbmssIGZhbHNlLCBkaXNwbGF5KTtcbn1cblxuLyoqIENyZWF0ZSBhIGxlZnQtYXNzb2NpYXRpdmUgYmluYXJ5IHBhcnNlciB3aGljaCBwYXJzZXMgdGhlIGdpdmVuIHN1Yi1lbGVtZW50IGFuZCBzZXBhcmF0b3IuIEhhbmRsZXMgd2hpdGVzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCaW5hcnlQYXJzZXI8VCwgVT4oXG4gICAgY2hpbGQ6IFAuUGFyc2VyPFQ+LFxuICAgIHNlcDogUC5QYXJzZXI8VT4sXG4gICAgY29tYmluZTogKGE6IFQsIGI6IFUsIGM6IFQpID0+IFRcbik6IFAuUGFyc2VyPFQ+IHtcbiAgICByZXR1cm4gUC5zZXFNYXAoY2hpbGQsIFAuc2VxKFAub3B0V2hpdGVzcGFjZSwgc2VwLCBQLm9wdFdoaXRlc3BhY2UsIGNoaWxkKS5tYW55KCksIChmaXJzdCwgcmVzdCkgPT4ge1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT0gMCkgcmV0dXJuIGZpcnN0O1xuXG4gICAgICAgIGxldCBub2RlID0gY29tYmluZShmaXJzdCwgcmVzdFswXVsxXSwgcmVzdFswXVszXSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCByZXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgbm9kZSA9IGNvbWJpbmUobm9kZSwgcmVzdFtpbmRleF1bMV0sIHJlc3RbaW5kZXhdWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoYWluT3B0PFQ+KGJhc2U6IFAuUGFyc2VyPFQ+LCAuLi5mdW5jczogKChyOiBUKSA9PiBQLlBhcnNlcjxUPilbXSk6IFAuUGFyc2VyPFQ+IHtcbiAgICByZXR1cm4gUC5jdXN0b20oKHN1Y2Nlc3MsIGZhaWx1cmUpID0+IHtcbiAgICAgICAgcmV0dXJuIChpbnB1dCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IChiYXNlIGFzIGFueSkuXyhpbnB1dCwgaSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGF0dXMpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGZ1bmMgb2YgZnVuY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IChmdW5jKHJlc3VsdC52YWx1ZSBhcyBUKSBhcyBhbnkpLl8oaW5wdXQsIHJlc3VsdC5pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0LnN0YXR1cykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXhwcmVzc2lvbiBQYXJzaW5nIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IHR5cGUgUG9zdGZpeEZyYWdtZW50ID1cbiAgICB8IHsgdHlwZTogXCJkb3RcIjsgZmllbGQ6IHN0cmluZyB9XG4gICAgfCB7IHR5cGU6IFwiaW5kZXhcIjsgZmllbGQ6IEZpZWxkIH1cbiAgICB8IHsgdHlwZTogXCJmdW5jdGlvblwiOyBmaWVsZHM6IEZpZWxkW10gfTtcblxuZXhwb3J0IGludGVyZmFjZSBFeHByZXNzaW9uTGFuZ3VhZ2Uge1xuICAgIG51bWJlcjogbnVtYmVyO1xuICAgIHN0cmluZzogc3RyaW5nO1xuICAgIGVzY2FwZUNoYXJhY3Rlcjogc3RyaW5nO1xuICAgIGJvb2w6IGJvb2xlYW47XG4gICAgdGFnOiBzdHJpbmc7XG4gICAgaWRlbnRpZmllcjogc3RyaW5nO1xuICAgIGxpbms6IExpbms7XG4gICAgZW1iZWRMaW5rOiBMaW5rO1xuICAgIHJvb3REYXRlOiBEYXRlVGltZTtcbiAgICBkYXRlU2hvcnRoYW5kOiBrZXlvZiB0eXBlb2YgREFURV9TSE9SVEhBTkRTO1xuICAgIGRhdGU6IERhdGVUaW1lO1xuICAgIGRhdGVQbHVzOiBEYXRlVGltZTtcbiAgICBkdXJhdGlvblR5cGU6IGtleW9mIHR5cGVvZiBEVVJBVElPTl9UWVBFUztcbiAgICBkdXJhdGlvbjogRHVyYXRpb247XG4gICAgcmF3TnVsbDogc3RyaW5nO1xuXG4gICAgYmluYXJ5UGx1c01pbnVzOiBCaW5hcnlPcDtcbiAgICBiaW5hcnlNdWxEaXY6IEJpbmFyeU9wO1xuICAgIGJpbmFyeUNvbXBhcmVPcDogQmluYXJ5T3A7XG4gICAgYmluYXJ5Qm9vbGVhbk9wOiBCaW5hcnlPcDtcblxuICAgIC8vIFNvdXJjZS1yZWxhdGVkIHBhcnNlcnMuXG4gICAgdGFnU291cmNlOiBUYWdTb3VyY2U7XG4gICAgY3N2U291cmNlOiBDc3ZTb3VyY2U7XG4gICAgZm9sZGVyU291cmNlOiBGb2xkZXJTb3VyY2U7XG4gICAgcGFyZW5zU291cmNlOiBTb3VyY2U7XG4gICAgYXRvbVNvdXJjZTogU291cmNlO1xuICAgIGxpbmtJbmNvbWluZ1NvdXJjZTogU291cmNlO1xuICAgIGxpbmtPdXRnb2luZ1NvdXJjZTogU291cmNlO1xuICAgIG5lZ2F0ZVNvdXJjZTogTmVnYXRlZFNvdXJjZTtcbiAgICBiaW5hcnlPcFNvdXJjZTogU291cmNlO1xuICAgIHNvdXJjZTogU291cmNlO1xuXG4gICAgLy8gRmllbGQtcmVsYXRlZCBwYXJzZXJzLlxuICAgIHZhcmlhYmxlRmllbGQ6IFZhcmlhYmxlRmllbGQ7XG4gICAgbnVtYmVyRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBib29sRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBzdHJpbmdGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIGRhdGVGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIGR1cmF0aW9uRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBsaW5rRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBudWxsRmllbGQ6IExpdGVyYWxGaWVsZDtcblxuICAgIGxpc3RGaWVsZDogTGlzdEZpZWxkO1xuICAgIG9iamVjdEZpZWxkOiBPYmplY3RGaWVsZDtcblxuICAgIGF0b21JbmxpbmVGaWVsZDogTGl0ZXJhbDtcbiAgICBpbmxpbmVGaWVsZExpc3Q6IExpdGVyYWxbXTtcbiAgICBpbmxpbmVGaWVsZDogTGl0ZXJhbDtcblxuICAgIG5lZ2F0ZWRGaWVsZDogRmllbGQ7XG4gICAgYXRvbUZpZWxkOiBGaWVsZDtcbiAgICBpbmRleEZpZWxkOiBGaWVsZDtcbiAgICBsYW1iZGFGaWVsZDogTGFtYmRhRmllbGQ7XG5cbiAgICAvLyBQb3N0Zml4IHBhcnNlcnMgZm9yIGZ1bmN0aW9uIGNhbGxzICYgdGhlIGxpa2UuXG4gICAgZG90UG9zdGZpeDogUG9zdGZpeEZyYWdtZW50O1xuICAgIGluZGV4UG9zdGZpeDogUG9zdGZpeEZyYWdtZW50O1xuICAgIGZ1bmN0aW9uUG9zdGZpeDogUG9zdGZpeEZyYWdtZW50O1xuXG4gICAgLy8gQmluYXJ5IG9wIHBhcnNlcnMuXG4gICAgYmluYXJ5TXVsRGl2RmllbGQ6IEZpZWxkO1xuICAgIGJpbmFyeVBsdXNNaW51c0ZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlDb21wYXJlRmllbGQ6IEZpZWxkO1xuICAgIGJpbmFyeUJvb2xlYW5GaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5T3BGaWVsZDogRmllbGQ7XG4gICAgcGFyZW5zRmllbGQ6IEZpZWxkO1xuICAgIGZpZWxkOiBGaWVsZDtcbn1cblxuZXhwb3J0IGNvbnN0IEVYUFJFU1NJT04gPSBQLmNyZWF0ZUxhbmd1YWdlPEV4cHJlc3Npb25MYW5ndWFnZT4oe1xuICAgIC8vIEEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyOyB0aGUgZGVjaW1hbCBwb2ludCBpcyBvcHRpb25hbC5cbiAgICBudW1iZXI6IHEgPT5cbiAgICAgICAgUC5yZWdleHAoLy0/WzAtOV0rKFxcLlswLTldKyk/LylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IE51bWJlci5wYXJzZUZsb2F0KHN0cikpXG4gICAgICAgICAgICAuZGVzYyhcIm51bWJlclwiKSxcblxuICAgIC8vIEEgcXVvdGUtc3Vycm91bmRlZCBzdHJpbmcgd2hpY2ggc3VwcG9ydHMgZXNjYXBlIGNoYXJhY3RlcnMgKCdcXCcpLlxuICAgIHN0cmluZzogcSA9PlxuICAgICAgICBQLnN0cmluZygnXCInKVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgUC5hbHQocS5lc2NhcGVDaGFyYWN0ZXIsIFAubm9uZU9mKCdcIlxcXFwnKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0TGVhc3QoMClcbiAgICAgICAgICAgICAgICAgICAgLm1hcChjaGFycyA9PiBjaGFycy5qb2luKFwiXCIpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnNraXAoUC5zdHJpbmcoJ1wiJykpXG4gICAgICAgICAgICAuZGVzYyhcInN0cmluZ1wiKSxcblxuICAgIGVzY2FwZUNoYXJhY3RlcjogXyA9PlxuICAgICAgICBQLnN0cmluZyhcIlxcXFxcIilcbiAgICAgICAgICAgIC50aGVuKFAuYW55KVxuICAgICAgICAgICAgLm1hcChlc2NhcGVkID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZXNjYXBpbmcgYSBiYWNrc2xhc2ggb3IgYSBxdW90ZSwgcGFzcyBpbiBvbiBpbiBlc2NhcGVkIGZvcm1cbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZCA9PT0gJ1wiJykgcmV0dXJuICdcIic7XG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWQgPT09IFwiXFxcXFwiKSByZXR1cm4gXCJcXFxcXCI7XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gXCJcXFxcXCIgKyBlc2NhcGVkO1xuICAgICAgICAgICAgfSksXG5cbiAgICAvLyBBIGJvb2xlYW4gdHJ1ZS9mYWxzZSB2YWx1ZS5cbiAgICBib29sOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC90cnVlfGZhbHNlfFRydWV8RmFsc2UvKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyLnRvTG93ZXJDYXNlKCkgPT0gXCJ0cnVlXCIpXG4gICAgICAgICAgICAuZGVzYyhcImJvb2xlYW4gKCd0cnVlJyBvciAnZmFsc2UnKVwiKSxcblxuICAgIC8vIEEgdGFnIG9mIHRoZSBmb3JtICcjc3R1ZmYvaGVsbG8tdGhlcmUnLlxuICAgIHRhZzogXyA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiI1wiKSxcbiAgICAgICAgICAgIFAuYWx0KFAucmVnZXhwKC9bXlxcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RichXCIjJCUmKCkqKywuOjs8PT4/QF5ge3x9flxcW1xcXVxcXFxcXHNdLykuZGVzYyhcInRleHRcIikpLm1hbnkoKSxcbiAgICAgICAgICAgIChzdGFydCwgcmVzdCkgPT4gc3RhcnQgKyByZXN0LmpvaW4oXCJcIilcbiAgICAgICAgKS5kZXNjKFwidGFnICgnI2hlbGxvL3N0dWZmJylcIiksXG5cbiAgICAvLyBBIHZhcmlhYmxlIGlkZW50aWZpZXIsIHdoaWNoIGlzIGFscGhhbnVtZXJpYyBhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIG9yLi4uIGVtb2ppLlxuICAgIGlkZW50aWZpZXI6IF8gPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLmFsdChQLnJlZ2V4cCgvXFxwe0xldHRlcn0vdSksIFAucmVnZXhwKEVNT0pJX1JFR0VYKS5kZXNjKFwidGV4dFwiKSksXG4gICAgICAgICAgICBQLmFsdChQLnJlZ2V4cCgvWzAtOVxccHtMZXR0ZXJ9Xy1dL3UpLCBQLnJlZ2V4cChFTU9KSV9SRUdFWCkuZGVzYyhcInRleHRcIikpLm1hbnkoKSxcbiAgICAgICAgICAgIChmaXJzdCwgcmVzdCkgPT4gZmlyc3QgKyByZXN0LmpvaW4oXCJcIilcbiAgICAgICAgKS5kZXNjKFwidmFyaWFibGUgaWRlbnRpZmllclwiKSxcblxuICAgIC8vIEFuIE9ic2lkaWFuIGxpbmsgb2YgdGhlIGZvcm0gW1s8bGluaz5dXS5cbiAgICBsaW5rOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC9cXFtcXFsoW15cXFtcXF1dKj8pXFxdXFxdL3UsIDEpXG4gICAgICAgICAgICAubWFwKGxpbmtJbm5lciA9PiBwYXJzZUlubmVyTGluayhsaW5rSW5uZXIpKVxuICAgICAgICAgICAgLmRlc2MoXCJmaWxlIGxpbmtcIiksXG5cbiAgICAvLyBBbiBlbWJlZGRhYmxlIGxpbmsgd2hpY2ggY2FuIHN0YXJ0IHdpdGggJyEnLiBUaGlzIG92ZXJsYXBzIHdpdGggdGhlIG5vcm1hbCBuZWdhdGlvbiBvcGVyYXRvciwgc28gaXQgaXMgb25seVxuICAgIC8vIHByb3ZpZGVkIGZvciBtZXRhZGF0YSBwYXJzaW5nLlxuICAgIGVtYmVkTGluazogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIiFcIikuYXRNb3N0KDEpLCBxLmxpbmssIChwLCBsKSA9PiB7XG4gICAgICAgICAgICBpZiAocC5sZW5ndGggPiAwKSBsLmVtYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9KS5kZXNjKFwiZmlsZSBsaW5rXCIpLFxuXG4gICAgLy8gQmluYXJ5IHBsdXMgb3IgbWludXMgb3BlcmF0b3IuXG4gICAgYmluYXJ5UGx1c01pbnVzOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC9cXCt8LS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIgYXMgQmluYXJ5T3ApXG4gICAgICAgICAgICAuZGVzYyhcIicrJyBvciAnLSdcIiksXG5cbiAgICAvLyBCaW5hcnkgdGltZXMgb3IgZGl2aWRlIG9wZXJhdG9yLlxuICAgIGJpbmFyeU11bERpdjogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvXFwqfFxcL3wlLylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ciBhcyBCaW5hcnlPcClcbiAgICAgICAgICAgIC5kZXNjKFwiJyonIG9yICcvJyBvciAnJSdcIiksXG5cbiAgICAvLyBCaW5hcnkgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICBiaW5hcnlDb21wYXJlT3A6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoLz49fDw9fCE9fD58PHw9LylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ciBhcyBCaW5hcnlPcClcbiAgICAgICAgICAgIC5kZXNjKFwiJz49JyBvciAnPD0nIG9yICchPScgb3IgJz0nIG9yICc+JyBvciAnPCdcIiksXG5cbiAgICAvLyBCaW5hcnkgYm9vbGVhbiBjb21iaW5hdGlvbiBvcGVyYXRvci5cbiAgICBiaW5hcnlCb29sZWFuT3A6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL2FuZHxvcnwmfFxcfC9pKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHIudG9Mb3dlckNhc2UoKSA9PSBcImFuZFwiKSByZXR1cm4gXCImXCI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyLnRvTG93ZXJDYXNlKCkgPT0gXCJvclwiKSByZXR1cm4gXCJ8XCI7XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gc3RyIGFzIEJpbmFyeU9wO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZXNjKFwiJ2FuZCcgb3IgJ29yJ1wiKSxcblxuICAgIC8vIEEgZGF0ZSB3aGljaCBjYW4gYmUgWVlZWS1NTVstRERUSEg6bW06c3NdLlxuICAgIHJvb3REYXRlOiBfID0+XG4gICAgICAgIFAuc2VxTWFwKFAucmVnZXhwKC9cXGR7NH0vKSwgUC5zdHJpbmcoXCItXCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksICh5ZWFyLCBfLCBtb250aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiBOdW1iZXIucGFyc2VJbnQoeWVhciksIG1vbnRoOiBOdW1iZXIucGFyc2VJbnQobW9udGgpIH0pO1xuICAgICAgICB9KS5kZXNjKFwiZGF0ZSBpbiBmb3JtYXQgWVlZWS1NTVstRERUSEgtTU0tU1MuTVNdXCIpLFxuICAgIGRhdGVTaG9ydGhhbmQ6IF8gPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhEQVRFX1NIT1JUSEFORFMpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgLm1hcChQLnN0cmluZylcbiAgICAgICAgKSBhcyBQLlBhcnNlcjxrZXlvZiB0eXBlb2YgREFURV9TSE9SVEhBTkRTPixcbiAgICBkYXRlOiBxID0+XG4gICAgICAgIGNoYWluT3B0PERhdGVUaW1lPihcbiAgICAgICAgICAgIHEucm9vdERhdGUsXG4gICAgICAgICAgICAoeW06IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiLVwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoXywgZGF5KSA9PiB5bS5zZXQoeyBkYXk6IE51bWJlci5wYXJzZUludChkYXkpIH0pKSxcbiAgICAgICAgICAgICh5bWQ6IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiVFwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoXywgaG91cikgPT4geW1kLnNldCh7IGhvdXI6IE51bWJlci5wYXJzZUludChob3VyKSB9KSksXG4gICAgICAgICAgICAoeW1kaDogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCI6XCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBtaW51dGUpID0+XG4gICAgICAgICAgICAgICAgICAgIHltZGguc2V0KHsgbWludXRlOiBOdW1iZXIucGFyc2VJbnQobWludXRlKSB9KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoeW1kaG06IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiOlwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoXywgc2Vjb25kKSA9PlxuICAgICAgICAgICAgICAgICAgICB5bWRobS5zZXQoeyBzZWNvbmQ6IE51bWJlci5wYXJzZUludChzZWNvbmQpIH0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh5bWRobXM6IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIi5cIiksIFAucmVnZXhwKC9cXGR7M30vKSwgKF8sIG1pbGxpc2Vjb25kKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgeW1kaG1zLnNldCh7IG1pbGxpc2Vjb25kOiBOdW1iZXIucGFyc2VJbnQobWlsbGlzZWNvbmQpIH0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFAuc3VjY2VlZCh5bWRobXMpIC8vIHBhc3NcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGR0OiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLmFsdChcbiAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIrXCIpLm9yKFAuc3RyaW5nKFwiLVwiKSksIFAucmVnZXhwKC9cXGR7MSwyfSg6XFxkezJ9KT8vKSwgKHBtLCBocikgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGR0LnNldFpvbmUoXCJVVENcIiArIHBtICsgaHIsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIlpcIiksICgpID0+IGR0LnNldFpvbmUoXCJ1dGNcIiwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJbXCIpLCBQLnJlZ2V4cCgvWzAtOUEtWmEteistXFwvXSsvdSksIFAuc3RyaW5nKFwiXVwiKSwgKF9hLCB6b25lLCBfYikgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGR0LnNldFpvbmUoem9uZSwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICAgIC5hc3NlcnQoKGR0OiBEYXRlVGltZSkgPT4gZHQuaXNWYWxpZCwgXCJ2YWxpZCBkYXRlXCIpXG4gICAgICAgICAgICAuZGVzYyhcImRhdGUgaW4gZm9ybWF0IFlZWVktTU1bLUREVEhILU1NLVNTLk1TXVwiKSxcblxuICAgIC8vIEEgZGF0ZSwgcGx1cyB2YXJpb3VzIHNob3J0aGFuZCB0aW1lcyBvZiBkYXkgaXQgY291bGQgYmUuXG4gICAgZGF0ZVBsdXM6IHEgPT5cbiAgICAgICAgUC5hbHQ8RGF0ZVRpbWU+KFxuICAgICAgICAgICAgcS5kYXRlU2hvcnRoYW5kLm1hcChkID0+IERBVEVfU0hPUlRIQU5EU1tkXSgpKSxcbiAgICAgICAgICAgIHEuZGF0ZVxuICAgICAgICApLmRlc2MoXCJkYXRlIGluIGZvcm1hdCBZWVlZLU1NWy1ERFRISC1NTS1TUy5NU10gb3IgaW4gc2hvcnRoYW5kXCIpLFxuXG4gICAgLy8gQSBkdXJhdGlvbiBvZiB0aW1lLlxuICAgIGR1cmF0aW9uVHlwZTogXyA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKERVUkFUSU9OX1RZUEVTKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5tYXAoUC5zdHJpbmcpXG4gICAgICAgICkgYXMgUC5QYXJzZXI8a2V5b2YgdHlwZW9mIERVUkFUSU9OX1RZUEVTPixcbiAgICBkdXJhdGlvbjogcSA9PlxuICAgICAgICBQLnNlcU1hcChxLm51bWJlciwgUC5vcHRXaGl0ZXNwYWNlLCBxLmR1cmF0aW9uVHlwZSwgKGNvdW50LCBfLCB0KSA9PiBEVVJBVElPTl9UWVBFU1t0XS5tYXBVbml0cyh4ID0+IHggKiBjb3VudCkpXG4gICAgICAgICAgICAuc2VwQnkxKFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkub3IoUC5vcHRXaGl0ZXNwYWNlKSlcbiAgICAgICAgICAgIC5tYXAoZHVyYXRpb25zID0+IGR1cmF0aW9ucy5yZWR1Y2UoKHAsIGMpID0+IHAucGx1cyhjKSkpXG4gICAgICAgICAgICAuZGVzYyhcImR1cmF0aW9uIGxpa2UgNGhyMm1pblwiKSxcblxuICAgIC8vIEEgcmF3IG51bGwgdmFsdWUuXG4gICAgcmF3TnVsbDogXyA9PiBQLnN0cmluZyhcIm51bGxcIiksXG5cbiAgICAvLyBTb3VyY2UgcGFyc2luZy5cbiAgICB0YWdTb3VyY2U6IHEgPT4gcS50YWcubWFwKHRhZyA9PiBTb3VyY2VzLnRhZyh0YWcpKSxcbiAgICBjc3ZTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJjc3YoXCIpLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSwgcS5zdHJpbmcsIFAuc3RyaW5nKFwiKVwiKSwgKF8xLCBwYXRoLCBfMikgPT4gU291cmNlcy5jc3YocGF0aCkpLFxuICAgIGxpbmtJbmNvbWluZ1NvdXJjZTogcSA9PiBxLmxpbmsubWFwKGxpbmsgPT4gU291cmNlcy5saW5rKGxpbmsucGF0aCwgdHJ1ZSkpLFxuICAgIGxpbmtPdXRnb2luZ1NvdXJjZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIm91dGdvaW5nKFwiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIHEubGluaywgUC5zdHJpbmcoXCIpXCIpLCAoXzEsIGxpbmssIF8yKSA9PlxuICAgICAgICAgICAgU291cmNlcy5saW5rKGxpbmsucGF0aCwgZmFsc2UpXG4gICAgICAgICksXG4gICAgZm9sZGVyU291cmNlOiBxID0+IHEuc3RyaW5nLm1hcChzdHIgPT4gU291cmNlcy5mb2xkZXIoc3RyKSksXG4gICAgcGFyZW5zU291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5zb3VyY2UsXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAoXzEsIF8yLCBmaWVsZCwgXzMsIF80KSA9PiBmaWVsZFxuICAgICAgICApLFxuICAgIG5lZ2F0ZVNvdXJjZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLmFsdChQLnN0cmluZyhcIi1cIiksIFAuc3RyaW5nKFwiIVwiKSksIHEuYXRvbVNvdXJjZSwgKF8sIHNvdXJjZSkgPT4gU291cmNlcy5uZWdhdGUoc291cmNlKSksXG4gICAgYXRvbVNvdXJjZTogcSA9PlxuICAgICAgICBQLmFsdDxTb3VyY2U+KFxuICAgICAgICAgICAgcS5wYXJlbnNTb3VyY2UsXG4gICAgICAgICAgICBxLm5lZ2F0ZVNvdXJjZSxcbiAgICAgICAgICAgIHEubGlua091dGdvaW5nU291cmNlLFxuICAgICAgICAgICAgcS5saW5rSW5jb21pbmdTb3VyY2UsXG4gICAgICAgICAgICBxLmZvbGRlclNvdXJjZSxcbiAgICAgICAgICAgIHEudGFnU291cmNlLFxuICAgICAgICAgICAgcS5jc3ZTb3VyY2VcbiAgICAgICAgKSxcbiAgICBiaW5hcnlPcFNvdXJjZTogcSA9PlxuICAgICAgICBjcmVhdGVCaW5hcnlQYXJzZXIoXG4gICAgICAgICAgICBxLmF0b21Tb3VyY2UsXG4gICAgICAgICAgICBxLmJpbmFyeUJvb2xlYW5PcC5tYXAocyA9PiBzIGFzIFNvdXJjZU9wKSxcbiAgICAgICAgICAgIFNvdXJjZXMuYmluYXJ5T3BcbiAgICAgICAgKSxcbiAgICBzb3VyY2U6IHEgPT4gcS5iaW5hcnlPcFNvdXJjZSxcblxuICAgIC8vIEZpZWxkIHBhcnNpbmcuXG4gICAgdmFyaWFibGVGaWVsZDogcSA9PlxuICAgICAgICBxLmlkZW50aWZpZXJcbiAgICAgICAgICAgIC5jaGFpbihyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoS0VZV09SRFMuaW5jbHVkZXMoci50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5mYWlsKFwiVmFyaWFibGUgZmllbGRzIGNhbm5vdCBiZSBhIGtleXdvcmQgKFwiICsgS0VZV09SRFMuam9pbihcIiBvciBcIikgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuc3VjY2VlZChGaWVsZHMudmFyaWFibGUocikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcInZhcmlhYmxlXCIpLFxuICAgIG51bWJlckZpZWxkOiBxID0+IHEubnVtYmVyLm1hcCh2YWwgPT4gRmllbGRzLmxpdGVyYWwodmFsKSkuZGVzYyhcIm51bWJlclwiKSxcbiAgICBzdHJpbmdGaWVsZDogcSA9PiBxLnN0cmluZy5tYXAodmFsID0+IEZpZWxkcy5saXRlcmFsKHZhbCkpLmRlc2MoXCJzdHJpbmdcIiksXG4gICAgYm9vbEZpZWxkOiBxID0+IHEuYm9vbC5tYXAodmFsID0+IEZpZWxkcy5saXRlcmFsKHZhbCkpLmRlc2MoXCJib29sZWFuXCIpLFxuICAgIGRhdGVGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiZGF0ZShcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLmRhdGVQbHVzLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKHByZWZpeCwgXzEsIGRhdGUsIF8yLCBwb3N0Zml4KSA9PiBGaWVsZHMubGl0ZXJhbChkYXRlKVxuICAgICAgICApLmRlc2MoXCJkYXRlXCIpLFxuICAgIGR1cmF0aW9uRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcImR1cihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLmR1cmF0aW9uLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKHByZWZpeCwgXzEsIGR1ciwgXzIsIHBvc3RmaXgpID0+IEZpZWxkcy5saXRlcmFsKGR1cilcbiAgICAgICAgKS5kZXNjKFwiZHVyYXRpb25cIiksXG4gICAgbnVsbEZpZWxkOiBxID0+IHEucmF3TnVsbC5tYXAoXyA9PiBGaWVsZHMuTlVMTCksXG4gICAgbGlua0ZpZWxkOiBxID0+IHEubGluay5tYXAoZiA9PiBGaWVsZHMubGl0ZXJhbChmKSksXG4gICAgbGlzdEZpZWxkOiBxID0+XG4gICAgICAgIHEuZmllbGRcbiAgICAgICAgICAgIC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKVxuICAgICAgICAgICAgLndyYXAoUC5zdHJpbmcoXCJbXCIpLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSwgUC5vcHRXaGl0ZXNwYWNlLnRoZW4oUC5zdHJpbmcoXCJdXCIpKSlcbiAgICAgICAgICAgIC5tYXAobCA9PiBGaWVsZHMubGlzdChsKSlcbiAgICAgICAgICAgIC5kZXNjKFwibGlzdCAoJ1sxLCAyLCAzXScpXCIpLFxuICAgIG9iamVjdEZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKHEuaWRlbnRpZmllci5vcihxLnN0cmluZyksIFAuc3RyaW5nKFwiOlwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksIHEuZmllbGQsIChuYW1lLCBfc2VwLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKVxuICAgICAgICAgICAgLndyYXAoUC5zdHJpbmcoXCJ7XCIpLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSwgUC5vcHRXaGl0ZXNwYWNlLnRoZW4oUC5zdHJpbmcoXCJ9XCIpKSlcbiAgICAgICAgICAgIC5tYXAodmFscyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlczogUmVjb3JkPHN0cmluZywgRmllbGQ+ID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgdmFscykgcmVzW2VudHJ5Lm5hbWVdID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkcy5vYmplY3QocmVzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcIm9iamVjdCAoJ3sgYTogMSwgYjogMiB9JylcIiksXG5cbiAgICBhdG9tSW5saW5lRmllbGQ6IHEgPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICBxLmRhdGUsXG4gICAgICAgICAgICBxLmR1cmF0aW9uLm1hcChkID0+IG5vcm1hbGl6ZUR1cmF0aW9uKGQpKSxcbiAgICAgICAgICAgIHEuc3RyaW5nLFxuICAgICAgICAgICAgcS50YWcsXG4gICAgICAgICAgICBxLmVtYmVkTGluayxcbiAgICAgICAgICAgIHEuYm9vbCxcbiAgICAgICAgICAgIHEubnVtYmVyLFxuICAgICAgICAgICAgcS5yYXdOdWxsXG4gICAgICAgICksXG4gICAgaW5saW5lRmllbGRMaXN0OiBxID0+IHEuYXRvbUlubGluZUZpZWxkLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkubG9va2FoZWFkKHEuYXRvbUlubGluZUZpZWxkKSksXG4gICAgaW5saW5lRmllbGQ6IHEgPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICBQLnNlcU1hcChxLmF0b21JbmxpbmVGaWVsZCwgUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSwgcS5pbmxpbmVGaWVsZExpc3QsIChmLCBfcywgbCkgPT5cbiAgICAgICAgICAgICAgICBbZl0uY29uY2F0KGwpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcS5hdG9tSW5saW5lRmllbGRcbiAgICAgICAgKSxcblxuICAgIGF0b21GaWVsZDogcSA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIC8vIFBsYWNlIGVtYmVkIGxpbmtzIGFib3ZlIG5lZ2F0ZWQgZmllbGRzIGFzIHRoZXkgYXJlIHRoZSBzcGVjaWFsIHBhcnNlciBjYXNlICchW1t0aGluZ11dJyBhbmQgYXJlIGdlbmVyYWxseSB1bmFtYmlnaW91cy5cbiAgICAgICAgICAgIHEuZW1iZWRMaW5rLm1hcChsID0+IEZpZWxkcy5saXRlcmFsKGwpKSxcbiAgICAgICAgICAgIHEubmVnYXRlZEZpZWxkLFxuICAgICAgICAgICAgcS5saW5rRmllbGQsXG4gICAgICAgICAgICBxLmxpc3RGaWVsZCxcbiAgICAgICAgICAgIHEub2JqZWN0RmllbGQsXG4gICAgICAgICAgICBxLmxhbWJkYUZpZWxkLFxuICAgICAgICAgICAgcS5wYXJlbnNGaWVsZCxcbiAgICAgICAgICAgIHEuYm9vbEZpZWxkLFxuICAgICAgICAgICAgcS5udW1iZXJGaWVsZCxcbiAgICAgICAgICAgIHEuc3RyaW5nRmllbGQsXG4gICAgICAgICAgICBxLmRhdGVGaWVsZCxcbiAgICAgICAgICAgIHEuZHVyYXRpb25GaWVsZCxcbiAgICAgICAgICAgIHEubnVsbEZpZWxkLFxuICAgICAgICAgICAgcS52YXJpYWJsZUZpZWxkXG4gICAgICAgICksXG4gICAgaW5kZXhGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChxLmF0b21GaWVsZCwgUC5hbHQocS5kb3RQb3N0Zml4LCBxLmluZGV4UG9zdGZpeCwgcS5mdW5jdGlvblBvc3RmaXgpLm1hbnkoKSwgKG9iaiwgcG9zdGZpeGVzKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gb2JqO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zdCBvZiBwb3N0Zml4ZXMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBvc3QudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZG90XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBGaWVsZHMuaW5kZXgocmVzdWx0LCBGaWVsZHMubGl0ZXJhbChwb3N0LmZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBGaWVsZHMuaW5kZXgocmVzdWx0LCBwb3N0LmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5mdW5jKHJlc3VsdCwgcG9zdC5maWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSxcbiAgICBuZWdhdGVkRmllbGQ6IHEgPT4gUC5zZXFNYXAoUC5zdHJpbmcoXCIhXCIpLCBxLmluZGV4RmllbGQsIChfLCBmaWVsZCkgPT4gRmllbGRzLm5lZ2F0ZShmaWVsZCkpLmRlc2MoXCJuZWdhdGVkIGZpZWxkXCIpLFxuICAgIHBhcmVuc0ZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5maWVsZCxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChfMSwgXzIsIGZpZWxkLCBfMywgXzQpID0+IGZpZWxkXG4gICAgICAgICksXG4gICAgbGFtYmRhRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBxLmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSlcbiAgICAgICAgICAgICAgICAud3JhcChQLnN0cmluZyhcIihcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLCBQLnN0cmluZyhcIilcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiPT5cIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLFxuICAgICAgICAgICAgcS5maWVsZCxcbiAgICAgICAgICAgIChpZGVudCwgX2lnbm9yZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImxhbWJkYVwiLCBhcmd1bWVudHM6IGlkZW50LCB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgZG90UG9zdGZpeDogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIi5cIiksIHEuaWRlbnRpZmllciwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImRvdFwiLCBmaWVsZDogZmllbGQgfTtcbiAgICAgICAgfSksXG4gICAgaW5kZXhQb3N0Zml4OiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiW1wiKSwgUC5vcHRXaGl0ZXNwYWNlLCBxLmZpZWxkLCBQLm9wdFdoaXRlc3BhY2UsIFAuc3RyaW5nKFwiXVwiKSwgKF8sIF8yLCBmaWVsZCwgXzMsIF80KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImluZGV4XCIsIGZpZWxkIH07XG4gICAgICAgIH0pLFxuICAgIGZ1bmN0aW9uUG9zdGZpeDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZmllbGQuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAoXywgXzEsIGZpZWxkcywgXzIsIF8zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJmdW5jdGlvblwiLCBmaWVsZHMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgIC8vIFRoZSBwcmVjZWRlbmNlIGhpZXJhcmNoeSBvZiBvcGVyYXRvcnMgLSBtdWx0aXBseS9kaXZpZGUsIGFkZC9zdWJ0cmFjdCwgY29tcGFyZSwgYW5kIHRoZW4gYm9vbGVhbiBvcGVyYXRpb25zLlxuICAgIGJpbmFyeU11bERpdkZpZWxkOiBxID0+IGNyZWF0ZUJpbmFyeVBhcnNlcihxLmluZGV4RmllbGQsIHEuYmluYXJ5TXVsRGl2LCBGaWVsZHMuYmluYXJ5T3ApLFxuICAgIGJpbmFyeVBsdXNNaW51c0ZpZWxkOiBxID0+IGNyZWF0ZUJpbmFyeVBhcnNlcihxLmJpbmFyeU11bERpdkZpZWxkLCBxLmJpbmFyeVBsdXNNaW51cywgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlDb21wYXJlRmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuYmluYXJ5UGx1c01pbnVzRmllbGQsIHEuYmluYXJ5Q29tcGFyZU9wLCBGaWVsZHMuYmluYXJ5T3ApLFxuICAgIGJpbmFyeUJvb2xlYW5GaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5iaW5hcnlDb21wYXJlRmllbGQsIHEuYmluYXJ5Qm9vbGVhbk9wLCBGaWVsZHMuYmluYXJ5T3ApLFxuICAgIGJpbmFyeU9wRmllbGQ6IHEgPT4gcS5iaW5hcnlCb29sZWFuRmllbGQsXG5cbiAgICBmaWVsZDogcSA9PiBxLmJpbmFyeU9wRmllbGQsXG59KTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHBhcnNlIGEgZmllbGQgZnJvbSB0aGUgZ2l2ZW4gdGV4dCwgcmV0dXJuaW5nIGEgc3RyaW5nIGVycm9yIGlmIHRoZVxuICogcGFyc2UgZmFpbGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGaWVsZCh0ZXh0OiBzdHJpbmcpOiBSZXN1bHQ8RmllbGQsIHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuc3VjY2VzcyhFWFBSRVNTSU9OLmZpZWxkLnRyeVBhcnNlKHRleHQpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yKTtcbiAgICB9XG59XG4iLCAiLyoqIFByb3ZpZGVzIGFuIEFTVCBmb3IgY29tcGxleCBxdWVyaWVzLiAqL1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSBcImRhdGEtaW5kZXgvc291cmNlXCI7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gXCJleHByZXNzaW9uL2ZpZWxkXCI7XG5cbi8qKiBUaGUgc3VwcG9ydGVkIHF1ZXJ5IHR5cGVzIChjb3JyZXNwb25kaW5nIHRvIHZpZXcgdHlwZXMpLiAqL1xuZXhwb3J0IHR5cGUgUXVlcnlUeXBlID0gXCJsaXN0XCIgfCBcInRhYmxlXCIgfCBcInRhc2tcIiB8IFwiY2FsZW5kYXJcIjtcblxuLyoqIEZpZWxkcyB1c2VkIGluIHRoZSBxdWVyeSBwb3J0aW9uLiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYW1lZEZpZWxkIHtcbiAgICAvKiogVGhlIGVmZmVjdGl2ZSBuYW1lIG9mIHRoaXMgZmllbGQuICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKiBUaGUgdmFsdWUgb2YgdGhpcyBmaWVsZC4gKi9cbiAgICBmaWVsZDogRmllbGQ7XG59XG5cbi8qKiBBIHF1ZXJ5IHNvcnQgYnkgZmllbGQsIGZvciBkZXRlcm1pbmluZyBzb3J0IG9yZGVyLiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeVNvcnRCeSB7XG4gICAgLyoqIFRoZSBmaWVsZCB0byBzb3J0IG9uLiAqL1xuICAgIGZpZWxkOiBGaWVsZDtcbiAgICAvKiogVGhlIGRpcmVjdGlvbiB0byBzb3J0IGluLiAqL1xuICAgIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiO1xufVxuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHF1aWNrbHkgY3JlYXRpbmcgZmllbGRzLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBRdWVyeUZpZWxkcyB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIG5hbWVkKG5hbWU6IHN0cmluZywgZmllbGQ6IEZpZWxkKTogTmFtZWRGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIGZpZWxkIH0gYXMgTmFtZWRGaWVsZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc29ydEJ5KGZpZWxkOiBGaWVsZCwgZGlyOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIpOiBRdWVyeVNvcnRCeSB7XG4gICAgICAgIHJldHVybiB7IGZpZWxkLCBkaXJlY3Rpb246IGRpciB9O1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgRGVmaW5pdGlvbiAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQSBxdWVyeSB3aGljaCBzaG91bGQgcmVuZGVyIGEgbGlzdCBvZiBlbGVtZW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFF1ZXJ5IHtcbiAgICB0eXBlOiBcImxpc3RcIjtcbiAgICAvKiogV2hhdCBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIGxpc3QuICovXG4gICAgZm9ybWF0PzogRmllbGQ7XG4gICAgLyoqIElmIHRydWUsIHNob3cgdGhlIGRlZmF1bHQgREkgZmllbGQ7IG90aGVyd2lzZSwgZG9uJ3QuICovXG4gICAgc2hvd0lkOiBib29sZWFuO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgdGFibGUgb2YgZWxlbWVudHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUXVlcnkge1xuICAgIHR5cGU6IFwidGFibGVcIjtcbiAgICAvKiogVGhlIGZpZWxkcyAoY29tcHV0ZWQgb3Igb3RoZXJ3aXNlKSB0byBzZWxlY3QuICovXG4gICAgZmllbGRzOiBOYW1lZEZpZWxkW107XG4gICAgLyoqIElmIHRydWUsIHNob3cgdGhlIGRlZmF1bHQgSUQgZmllbGQ7IG90aGVyd2lzZSwgZG9uJ3QuICovXG4gICAgc2hvd0lkOiBib29sZWFuO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgY29sbGVjdGlvbiBvZiB0YXNrcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFza1F1ZXJ5IHtcbiAgICB0eXBlOiBcInRhc2tcIjtcbn1cblxuLyoqIEEgcXVlcnkgd2hpY2ggcmVuZGVycyBhIGNvbGxlY3Rpb24gb2Ygbm90ZXMgaW4gYSBjYWxlbmRhciB2aWV3LiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhclF1ZXJ5IHtcbiAgICB0eXBlOiBcImNhbGVuZGFyXCI7XG4gICAgLyoqIFRoZSBkYXRlIGZpZWxkIHRoYXQgd2UnbGwgYmUgZ3JvdXBpbmcgbm90ZXMgYnkgZm9yIHRoZSBjYWxlbmRhciB2aWV3ICovXG4gICAgZmllbGQ6IE5hbWVkRmllbGQ7XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5SGVhZGVyID0gTGlzdFF1ZXJ5IHwgVGFibGVRdWVyeSB8IFRhc2tRdWVyeSB8IENhbGVuZGFyUXVlcnk7XG5cbi8qKiBBIHN0ZXAgd2hpY2ggb25seSByZXRhaW5zIHJvd3Mgd2hvc2UgJ2NsYXVzZScgZmllbGQgaXMgdHJ1dGh5LiAqL1xuZXhwb3J0IGludGVyZmFjZSBXaGVyZVN0ZXAge1xuICAgIHR5cGU6IFwid2hlcmVcIjtcbiAgICBjbGF1c2U6IEZpZWxkO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIHNvcnRzIGFsbCBjdXJyZW50IHJvd3MgYnkgdGhlIGdpdmVuIGxpc3Qgb2Ygc29ydHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFNvcnRCeVN0ZXAge1xuICAgIHR5cGU6IFwic29ydFwiO1xuICAgIGZpZWxkczogUXVlcnlTb3J0QnlbXTtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCB0cnVuY2F0ZXMgdGhlIG51bWJlciBvZiByb3dzIHRvIHRoZSBnaXZlbiBhbW91bnQuICovXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0U3RlcCB7XG4gICAgdHlwZTogXCJsaW1pdFwiO1xuICAgIGFtb3VudDogRmllbGQ7XG59XG5cbi8qKiBBIHN0ZXAgd2hpY2ggZmxhdHRlbnMgcm93cyBpbnRvIG11bHRpcGxlIGNoaWxkIHJvd3MuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsYXR0ZW5TdGVwIHtcbiAgICB0eXBlOiBcImZsYXR0ZW5cIjtcbiAgICBmaWVsZDogTmFtZWRGaWVsZDtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCBncm91cHMgcm93cyBpbnRvIGdyb3VwcyBieSB0aGUgZ2l2ZW4gZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwU3RlcCB7XG4gICAgdHlwZTogXCJncm91cFwiO1xuICAgIGZpZWxkOiBOYW1lZEZpZWxkO1xufVxuXG4vKiogQSB2aXJ0dWFsIHN0ZXAgd2hpY2ggZXh0cmFjdHMgYW4gYXJyYXkgb2YgdmFsdWVzIGZyb20gZWFjaCByb3cuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RTdGVwIHtcbiAgICB0eXBlOiBcImV4dHJhY3RcIjtcbiAgICBmaWVsZHM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPjtcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlPcGVyYXRpb24gPSBXaGVyZVN0ZXAgfCBTb3J0QnlTdGVwIHwgTGltaXRTdGVwIHwgRmxhdHRlblN0ZXAgfCBHcm91cFN0ZXAgfCBFeHRyYWN0U3RlcDtcblxuLyoqXG4gKiBBIHF1ZXJ5IG92ZXIgdGhlIE9ic2lkaWFuIGRhdGFiYXNlLiBRdWVyaWVzIGhhdmUgYSBzcGVjaWZpYyBhbmQgZGV0ZXJtaW5pc3RpYyBleGVjdXRpb24gb3JkZXI6XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnkge1xuICAgIC8qKiBUaGUgdmlldyB0eXBlIHRvIHJlbmRlciB0aGlzIHF1ZXJ5IGluLiAqL1xuICAgIGhlYWRlcjogUXVlcnlIZWFkZXI7XG4gICAgLyoqIFRoZSBzb3VyY2UgdGhhdCBmaWxlIGNhbmRpZGF0ZXMgd2lsbCBjb21lIGZyb20uICovXG4gICAgc291cmNlOiBTb3VyY2U7XG4gICAgLyoqIFRoZSBvcGVyYXRpb25zIHRvIGFwcGx5IHRvIHRoZSBkYXRhIHRvIHByb2R1Y2UgdGhlIGZpbmFsIHJlc3VsdCB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuICovXG4gICAgb3BlcmF0aW9uczogUXVlcnlPcGVyYXRpb25bXTtcbn1cbiIsICJpbXBvcnQgeyBFWFBSRVNTSU9OIH0gZnJvbSBcImV4cHJlc3Npb24vcGFyc2VcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IHtcbiAgICBGbGF0dGVuU3RlcCxcbiAgICBHcm91cFN0ZXAsXG4gICAgTGltaXRTdGVwLFxuICAgIE5hbWVkRmllbGQsXG4gICAgUXVlcnksXG4gICAgUXVlcnlGaWVsZHMsXG4gICAgUXVlcnlIZWFkZXIsXG4gICAgUXVlcnlPcGVyYXRpb24sXG4gICAgUXVlcnlTb3J0QnksXG4gICAgUXVlcnlUeXBlLFxuICAgIFNvcnRCeVN0ZXAsXG4gICAgV2hlcmVTdGVwLFxufSBmcm9tIFwiLi9xdWVyeVwiO1xuaW1wb3J0IHsgU291cmNlLCBTb3VyY2VzIH0gZnJvbSBcImRhdGEtaW5kZXgvc291cmNlXCI7XG5pbXBvcnQgeyBERUZBVUxUX1FVRVJZX1NFVFRJTkdTIH0gZnJvbSBcInNldHRpbmdzXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBRdWVyeSBQYXJzaW5nIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBUeXBpbmdzIGZvciB0aGUgb3V0cHV0cyBvZiBhbGwgb2YgdGhlIHBhcnNlciBjb21iaW5hdG9ycy4gKi9cbmludGVyZmFjZSBRdWVyeUxhbmd1YWdlVHlwZXMge1xuICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlO1xuXG4gICAgZXhwbGljaXROYW1lZEZpZWxkOiBOYW1lZEZpZWxkO1xuICAgIG5hbWVkRmllbGQ6IE5hbWVkRmllbGQ7XG4gICAgc29ydEZpZWxkOiBRdWVyeVNvcnRCeTtcblxuICAgIC8vIEVudGlyZSBjbGF1c2VzIGluIHF1ZXJpZXMuXG4gICAgaGVhZGVyQ2xhdXNlOiBRdWVyeUhlYWRlcjtcbiAgICBmcm9tQ2xhdXNlOiBTb3VyY2U7XG4gICAgd2hlcmVDbGF1c2U6IFdoZXJlU3RlcDtcbiAgICBzb3J0QnlDbGF1c2U6IFNvcnRCeVN0ZXA7XG4gICAgbGltaXRDbGF1c2U6IExpbWl0U3RlcDtcbiAgICBmbGF0dGVuQ2xhdXNlOiBGbGF0dGVuU3RlcDtcbiAgICBncm91cEJ5Q2xhdXNlOiBHcm91cFN0ZXA7XG4gICAgY2xhdXNlOiBRdWVyeU9wZXJhdGlvbjtcbiAgICBxdWVyeTogUXVlcnk7XG59XG5cbi8qKiBSZXR1cm4gYSBuZXcgcGFyc2VyIHdoaWNoIGV4ZWN1dGVzIHRoZSB1bmRlcmx5aW5nIHBhcnNlciBhbmQgcmV0dXJucyBpdCdzIHJhdyBzdHJpbmcgcmVwcmVzZW50YXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZVJhdzxUPihiYXNlOiBQLlBhcnNlcjxUPik6IFAuUGFyc2VyPFtULCBzdHJpbmddPiB7XG4gICAgcmV0dXJuIFAuY3VzdG9tKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIHJldHVybiAoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAoYmFzZSBhcyBhbnkpLl8oaW5wdXQsIGkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0LCB7IHZhbHVlOiBbcmVzdWx0LnZhbHVlLCBpbnB1dC5zdWJzdHJpbmcoaSwgcmVzdWx0LmluZGV4KV0gfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbi8qKiBTdHJpcCBuZXdsaW5lcyBhbmQgZXhjZXNzIHdoaXRlc3BhY2Ugb3V0IG9mIHRleHQuICovXG5mdW5jdGlvbiBzdHJpcE5ld2xpbmVzKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KC9bXFxyXFxuXSsvKVxuICAgICAgICAubWFwKHQgPT4gdC50cmltKCkpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuXG4vKiogQSBwYXJzaW1tb24tcG93ZXJlZCBwYXJzZXItY29tYmluYXRvciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcXVlcnkgbGFuZ3VhZ2UuICovXG5leHBvcnQgY29uc3QgUVVFUllfTEFOR1VBR0UgPSBQLmNyZWF0ZUxhbmd1YWdlPFF1ZXJ5TGFuZ3VhZ2VUeXBlcz4oe1xuICAgIC8vIFNpbXBsZSBhdG9tIHBhcnNpbmcsIGxpa2Ugd29yZHMsIGlkZW50aWZpZXJzLCBudW1iZXJzLlxuICAgIHF1ZXJ5VHlwZTogcSA9PlxuICAgICAgICBQLmFsdDxzdHJpbmc+KFAucmVnZXhwKC9UQUJMRXxMSVNUfFRBU0t8Q0FMRU5EQVIvaSkpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKSBhcyBRdWVyeVR5cGUpXG4gICAgICAgICAgICAuZGVzYyhcInF1ZXJ5IHR5cGUgKCdUQUJMRScsICdMSVNUJywgJ1RBU0snLCBvciAnQ0FMRU5EQVInKVwiKSxcbiAgICBleHBsaWNpdE5hbWVkRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLnNraXAoUC53aGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIFAucmVnZXhwKC9BUy9pKS5za2lwKFAud2hpdGVzcGFjZSksXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmlkZW50aWZpZXIub3IoRVhQUkVTU0lPTi5zdHJpbmcpLFxuICAgICAgICAgICAgKGZpZWxkLCBfYXMsIGlkZW50KSA9PiBRdWVyeUZpZWxkcy5uYW1lZChpZGVudCwgZmllbGQpXG4gICAgICAgICksXG4gICAgbmFtZWRGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdDxOYW1lZEZpZWxkPihcbiAgICAgICAgICAgIHEuZXhwbGljaXROYW1lZEZpZWxkLFxuICAgICAgICAgICAgY2FwdHVyZVJhdyhFWFBSRVNTSU9OLmZpZWxkKS5tYXAoKFt2YWx1ZSwgdGV4dF0pID0+IFF1ZXJ5RmllbGRzLm5hbWVkKHN0cmlwTmV3bGluZXModGV4dCksIHZhbHVlKSlcbiAgICAgICAgKSxcbiAgICBzb3J0RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIFAucmVnZXhwKC9BU0NFTkRJTkd8REVTQ0VORElOR3xBU0N8REVTQy9pKS5hdE1vc3QoMSksXG4gICAgICAgICAgICAoZmllbGQsIGRpcikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBkaXIubGVuZ3RoID09IDAgPyBcImFzY2VuZGluZ1wiIDogZGlyWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImRlc2NcIikgZGlyZWN0aW9uID0gXCJkZXNjZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImFzY1wiKSBkaXJlY3Rpb24gPSBcImFzY2VuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gYXMgXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICBoZWFkZXJDbGF1c2U6IHEgPT5cbiAgICAgICAgcS5xdWVyeVR5cGVcbiAgICAgICAgICAgIC5za2lwKFAud2hpdGVzcGFjZSlcbiAgICAgICAgICAgIC5jaGFpbihxdHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChxdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnNlcU1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnJlZ2V4cCgvV0lUSE9VVFxccytJRC9pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2tpcChQLm9wdFdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdE1vc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXBCeShxLm5hbWVkRmllbGQsIFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aXRob3V0SWQsIGZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInRhYmxlXCIsIGZpZWxkcywgc2hvd0lkOiB3aXRob3V0SWQubGVuZ3RoID09IDAgfSBhcyBRdWVyeUhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGlzdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuc2VxTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAucmVnZXhwKC9XSVRIT1VUXFxzK0lEL2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5za2lwKFAub3B0V2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2l0aG91dElkLCBmb3JtYXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQubGVuZ3RoID09IDEgPyBmb3JtYXRbMF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SWQ6IHdpdGhvdXRJZC5sZW5ndGggPT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBRdWVyeUhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGFza1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuc3VjY2VlZCh7IHR5cGU6IFwidGFza1wiIH0gYXMgUXVlcnlIZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FsZW5kYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnNlcU1hcChxLm5hbWVkRmllbGQsIGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNhbGVuZGFyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBRdWVyeUhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuZmFpbChgVW5yZWNvZ25pemVkIHF1ZXJ5IHR5cGUgJyR7cXR5cGV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcIlRBQkxFIG9yIExJU1Qgb3IgVEFTSyBvciBDQUxFTkRBUlwiKSxcbiAgICBmcm9tQ2xhdXNlOiBxID0+IFAuc2VxTWFwKFAucmVnZXhwKC9GUk9NL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uc291cmNlLCAoXzEsIF8yLCBzb3VyY2UpID0+IHNvdXJjZSksXG4gICAgd2hlcmVDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL1dIRVJFL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uZmllbGQsICh3aGVyZSwgXywgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwid2hlcmVcIiwgY2xhdXNlOiBmaWVsZCB9IGFzIFdoZXJlU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIldIRVJFIDxleHByZXNzaW9uPlwiKSxcbiAgICBzb3J0QnlDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnJlZ2V4cCgvU09SVC9pKSxcbiAgICAgICAgICAgIFAud2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuc29ydEZpZWxkLnNlcEJ5MShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgIChzb3J0LCBfMSwgZmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzb3J0XCIsIGZpZWxkcyB9IGFzIFNvcnRCeVN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICkuZGVzYyhcIlNPUlQgZmllbGQgW0FTQy9ERVNDXVwiKSxcbiAgICBsaW1pdENsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvTElNSVQvaSksIFAud2hpdGVzcGFjZSwgRVhQUkVTU0lPTi5maWVsZCwgKGxpbWl0LCBfMSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibGltaXRcIiwgYW1vdW50OiBmaWVsZCB9IGFzIExpbWl0U3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkxJTUlUIDx2YWx1ZT5cIiksXG4gICAgZmxhdHRlbkNsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvRkxBVFRFTi9pKS5za2lwKFAud2hpdGVzcGFjZSksIHEubmFtZWRGaWVsZCwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImZsYXR0ZW5cIiwgZmllbGQgfSBhcyBGbGF0dGVuU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkZMQVRURU4gPHZhbHVlPiBbQVMgPG5hbWU+XVwiKSxcbiAgICBncm91cEJ5Q2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAucmVnZXhwKC9HUk9VUCBCWS9pKS5za2lwKFAud2hpdGVzcGFjZSksIHEubmFtZWRGaWVsZCwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImdyb3VwXCIsIGZpZWxkIH0gYXMgR3JvdXBTdGVwO1xuICAgICAgICB9KS5kZXNjKFwiR1JPVVAgQlkgPHZhbHVlPiBbQVMgPG5hbWU+XVwiKSxcbiAgICAvLyBGdWxsIHF1ZXJ5IHBhcnNpbmcuXG4gICAgY2xhdXNlOiBxID0+IFAuYWx0KHEuZnJvbUNsYXVzZSwgcS53aGVyZUNsYXVzZSwgcS5zb3J0QnlDbGF1c2UsIHEubGltaXRDbGF1c2UsIHEuZ3JvdXBCeUNsYXVzZSwgcS5mbGF0dGVuQ2xhdXNlKSxcbiAgICBxdWVyeTogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIHEuaGVhZGVyQ2xhdXNlLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIHEuZnJvbUNsYXVzZS50cmltKFAub3B0V2hpdGVzcGFjZSkuYXRNb3N0KDEpLFxuICAgICAgICAgICAgcS5jbGF1c2UudHJpbShQLm9wdFdoaXRlc3BhY2UpLm1hbnkoKSxcbiAgICAgICAgICAgIChoZWFkZXIsIGZyb20sIGNsYXVzZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZnJvbS5sZW5ndGggPT0gMCA/IFNvdXJjZXMuZm9sZGVyKFwiXCIpIDogZnJvbVswXSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogY2xhdXNlcyxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IERFRkFVTFRfUVVFUllfU0VUVElOR1MsXG4gICAgICAgICAgICAgICAgfSBhcyBRdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbn0pO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYSBxdWVyeSBmcm9tIHRoZSBnaXZlbiBxdWVyeSB0ZXh0LCByZXR1cm5pbmcgYSBzdHJpbmcgZXJyb3JcbiAqIGlmIHRoZSBwYXJzZSBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHRleHQ6IHN0cmluZyk6IFJlc3VsdDxRdWVyeSwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gUVVFUllfTEFOR1VBR0UucXVlcnkudHJ5UGFyc2UodGV4dCk7XG4gICAgICAgIHJldHVybiBSZXN1bHQuc3VjY2VzcyhxdWVyeSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvcik7XG4gICAgfVxufVxuIiwgIi8vIEJhc2ljIEFQSSB0eXBlLlxuZXhwb3J0IHR5cGUgeyBEYXRhdmlld0FwaSB9IGZyb20gXCJhcGkvcGx1Z2luLWFwaVwiO1xuXG4vLyBDb3JlIERhdGF2aWV3IHR5cGVzLlxuZXhwb3J0IHR5cGUgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjtcbmV4cG9ydCB0eXBlIHtcbiAgICBMaW5rLFxuICAgIERhdGFPYmplY3QsXG4gICAgTGl0ZXJhbFR5cGUsXG4gICAgTGl0ZXJhbCxcbiAgICBMaXRlcmFsUmVwcixcbiAgICBXcmFwcGVkTGl0ZXJhbCxcbiAgICBMaXRlcmFsV3JhcHBlcixcbiAgICBXaWRnZXQsXG59IGZyb20gXCJkYXRhLW1vZGVsL3ZhbHVlXCI7XG5cbmV4cG9ydCB0eXBlIHsgUmVzdWx0LCBTdWNjZXNzLCBGYWlsdXJlIH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmV4cG9ydCB0eXBlIHsgRGF0YUFycmF5IH0gZnJvbSBcImFwaS9kYXRhLWFycmF5XCI7XG5cbi8vIERhdGF2aWV3IEluZGV4LlxuZXhwb3J0IHR5cGUgeyBMaXN0SXRlbSwgUGFnZU1ldGFkYXRhIH0gZnJvbSBcImRhdGEtbW9kZWwvbWFya2Rvd25cIjtcbmV4cG9ydCB0eXBlIHsgRnVsbEluZGV4LCBQcmVmaXhJbmRleCwgSW5kZXhNYXAgfSBmcm9tIFwiZGF0YS1pbmRleC9pbmRleFwiO1xuXG4vLyBTZXJpYWxpemVkIHR5cGVzIHdoaWNoIGRlc2NyaWJlIGFsbCBvdXRwdXRzIG9mIHNlcmlhbGl6YXRpb24uXG5leHBvcnQgdHlwZSB7IFNNYXJrZG93blBhZ2UsIFNMaXN0RW50cnksIFNUYXNrIH0gZnJvbSBcImRhdGEtbW9kZWwvc2VyaWFsaXplZC9tYXJrZG93blwiO1xuXG4vLyBVc2VmdWwgdXRpbGl0aWVzIGZvciBkaXJlY3RseSB1c2luZyBkYXRhdmlldyBwYXJzZXJzLlxuZXhwb3J0IHtcbiAgICBEVVJBVElPTl9UWVBFUyxcbiAgICBEQVRFX1NIT1JUSEFORFMsXG4gICAgS0VZV09SRFMsXG4gICAgRXhwcmVzc2lvbkxhbmd1YWdlLFxuICAgIEVYUFJFU1NJT04sXG4gICAgcGFyc2VGaWVsZCxcbn0gZnJvbSBcImV4cHJlc3Npb24vcGFyc2VcIjtcbmV4cG9ydCB7IFFVRVJZX0xBTkdVQUdFIH0gZnJvbSBcInF1ZXJ5L3BhcnNlXCI7XG5leHBvcnQgeyBRdWVyeSB9IGZyb20gXCJxdWVyeS9xdWVyeVwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW1wbGVtZW50YXRpb24gLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmltcG9ydCB0eXBlIHsgRGF0YXZpZXdBcGkgfSBmcm9tIFwiYXBpL3BsdWdpbi1hcGlcIjtcblxuaW1wb3J0IFwib2JzaWRpYW5cIjtcbmltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zLlxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgRGF0YXZpZXcgQVBJIGZyb20gdGhlIGFwcCBpZiBwcm92aWRlZDsgaWYgbm90LCBpdCBpcyBpbmZlcnJlZCBmcm9tIHRoZSBnbG9iYWwgQVBJIG9iamVjdCBpbnN0YWxsZWRcbiAqIG9uIHRoZSB3aW5kb3cuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBUEkgPSAoYXBwPzogQXBwKTogRGF0YXZpZXdBcGkgfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmIChhcHApIHJldHVybiBhcHAucGx1Z2lucy5wbHVnaW5zLmRhdGF2aWV3Py5hcGk7XG4gICAgZWxzZSByZXR1cm4gd2luZG93LkRhdGF2aWV3QVBJO1xufTtcblxuLyoqIERldGVybWluZSBpZiBEYXRhdmlldyBpcyBlbmFibGVkIGluIHRoZSBnaXZlbiBhcHBsaWNhdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBpc1BsdWdpbkVuYWJsZWQgPSAoYXBwOiBBcHApID0+IGFwcC5wbHVnaW5zLmVuYWJsZWRQbHVnaW5zLmhhcyhcImRhdGF2aWV3XCIpO1xuIiwgImltcG9ydCB7QXBwLCBFdmVudFJlZiwgTW9kYWwsIG5vcm1hbGl6ZVBhdGgsIE5vdGljZSwgUGx1Z2luLCBTZXR0aW5nLCBUQWJzdHJhY3RGaWxlfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7XHJcblx0RVhFUkNJU0VfQkFTRSxcclxuXHRFeGVyY2lzZUJhc2VcclxufSBmcm9tIFwiLi9FeGVyY2lzZUJhc2VcIjtcclxuaW1wb3J0IHtFeGNhbGlkcmF3RmlsZX0gZnJvbSBcIi4vRXhjYWxpZHJhd1wiO1xyXG5pbXBvcnQge0RhdGF2aWV3QXBpfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXcvbGliL2FwaS9wbHVnaW4tYXBpXCI7XHJcbmltcG9ydCB7Z2V0QVBJfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXdcIjtcclxuaW1wb3J0IHtEYXRhUHJvY2Vzc29yfSBmcm9tIFwiLi9EYXRhUHJvY2Vzc29yXCI7XHJcbmltcG9ydCB7cGFyc2VKU09OfSBmcm9tIFwiLi9zcmMvdXRpbGl0eS9wYXJzZXJcIjtcclxuaW1wb3J0IHtFWEVSQ0lTRV9TVEFUVVNFUywgRVhFUkNJU0VfU1RBVFVTRVNfU1dBUFBFRCwgRVhFUkNJU0VfU1VCSkVDVH0gZnJvbSBcIi4vc3JjL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQge1NCYXNlTWV0YWRhdGF9IGZyb20gXCIuL3NyYy9iYXNlX3ZlcnNpb25cIjtcclxuXHJcbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxyXG5cclxuaW50ZXJmYWNlIEhlbGxvV29ybGRQbHVnaW4ge1xyXG5cdG15U2V0dGluZzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNeVBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcblx0c2V0dGluZ3M6IEhlbGxvV29ybGRQbHVnaW47XHJcblxyXG5cdGNwdTogRGF0YVByb2Nlc3NvcjtcclxuXHJcblx0YmFzZU1vZGFsOiBCYXNlTW9kYWw7XHJcblxyXG5cdG9uRXhGaWxlQ2hhbmdlUmVmOiBFdmVudFJlZjtcclxuXHJcblx0ZGF0YXZpZXdBUEk6IERhdGF2aWV3QXBpIHwgdW5kZWZpbmVkID0gZ2V0QVBJKHRoaXMuYXBwKTtcclxuXHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpIHtcclxuXHRcdC8vIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblx0XHR0aGlzLmNwdSA9IGF3YWl0IERhdGFQcm9jZXNzb3IuaW5pdCh0aGlzLmFwcCk7XHJcblx0XHR0aGlzLmJhc2VNb2RhbCA9IG5ldyBCYXNlTW9kYWwodGhpcy5hcHAsdGhpcy5jcHUpXHJcblx0XHR0aGlzLm9uRXhGaWxlQ2hhbmdlUmVmID0gIHRoaXMuYXBwLnZhdWx0Lm9uKFwibW9kaWZ5XCIsIHRoaXMub25FeGNhbGlkcmF3RmlsZUNoYW5nZSwgdGhpcyk7XHJcblxyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcInN3aXRjaC1iYXNlXCIsXHJcblx0XHRcdG5hbWU6IFwiU3dpdGNoIEJhc2VcIixcclxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLmJhc2VNb2RhbC5vcGVuKCk7XHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwiY2xvc2UtYmFzZVwiLFxyXG5cdFx0XHRuYW1lOiBcIkNsb3NlIEJhc2VcIixcclxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLmNwdS5hY3RpdmVCYXNlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cclxuXHRcdC8vICBcdThGRDlcdTRFMkFyZWxvYWQgYWxsIGJhc2VzXHU3Njg0XHU3NkVFXHU3Njg0XHU2NjJGXHU0RTNBXHU0RTg2XHU1NzI4XHU3NkY0XHU2M0E1XHU0RkVFXHU2NTM5XHU0RTg2XHU1RTkzXHU2NTg3XHU0RUY2XHU1NDBFXHVGRjBDXHU0RkREXHU4QkMxXHU1RTkzXHU2NTg3XHU0RUY2XHU3Njg0XHU0RkVFXHU2NTM5XHU1M0VGXHU0RUU1XHU1M0NBXHU2NUY2XHJcblx0XHQvLyBcdTUzQ0RcdTk5ODhcdTUyMzBSdW50aW1lIEJhc2VcdTkxQ0NcdTk3NjJcdUZGMENcdTRGNDZcdThGRDlcdTRFMkFcdTY3MDlcdTVGQzVcdTg5ODFcdTU0MTdcdUZGMUYgXHU1NkUwXHU0RTNBXHVGRjBDXHU2MjExXHU1MUIzXHU1QjlBXHU0RUU1XHU1NDBFXHU1M0VBXHU4MEZEXHU5MDFBXHU4RkM3XHU0RkVFXHU2NTM5UnVudGltZSBCYXNlXHVGRjBDXHJcblx0XHQvLyB0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0Ly8gXHRpZDogXCJyZWxvYWQtYWxsLWJhc2VzXCIsXHJcblx0XHQvLyBcdG5hbWU6IFwiUmVsb2FkIEFsbCBCYXNlc1wiLFxyXG5cdFx0Ly8gXHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cdFx0Ly8gXHRcdGZvciAobGV0IHN1YmplY3Qgb2YgT2JqZWN0LmtleXMoRVhFUkNJU0VfQkFTRSkpIHtcclxuXHRcdC8vIFx0XHRcdGNvbnN0IHBhdGggPSBFWEVSQ0lTRV9CQVNFW3N1YmplY3RdLnBhdGg7XHJcblx0XHQvLyBcdFx0XHRsZXQgYmFzZUpTT046IFNCYXNlTWV0YWRhdGEgPSBwYXJzZUpTT04oYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKG5vcm1hbGl6ZVBhdGgocGF0aCkpKVxyXG5cdFx0Ly8gXHRcdFx0dGhpcy5jcHUuYmFzZXNbc3ViamVjdF0gPSBhd2FpdCBFeGVyY2lzZUJhc2UuZnJvbUpTT04odGhpcy5hcHAsYmFzZUpTT04pO1xyXG5cdFx0Ly8gXHRcdH1cclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfSlcclxuXHJcblx0XHQvLyBJZiB0aGUgcGx1Z2luIGhvb2tzIHVwIGFueSBnbG9iYWwgRE9NIGV2ZW50cyAob24gcGFydHMgb2YgdGhlIGFwcF8gdGhhdCBkb2Vzbid0IGJlbG9uZyB0byB0aGlzIHBsdWdpbilcclxuXHRcdC8vIFVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGlzIHBsdWdpbiBpcyBkaXNhYmxlZC5cclxuXHRcdHRoaXMucmVnaXN0ZXJEb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCAoZXYpID0+IHtcclxuXHRcdFx0aWYgKGV2LmN0cmxLZXkgJiYgZXYuc2hpZnRLZXkgJiYgZXYua2V5ID09IFwiQVwiKSB7XHJcblx0XHRcdFx0aWYoIXRoaXMuY3B1LmFjdGl2ZUJhc2UpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJObyBCYXNlIGlzIHNlbGVjdGVkIVwiKVxyXG5cdFx0XHRcdFx0dGhpcy5iYXNlTW9kYWwub3BlbigpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLmNwdS5hY3RpdmVFeGVyY2lzZSkge1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiQW4gYWN0aXZlIGV4ZXJjaXNlIGlzIHJ1bm5pbmchXCIpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jcHUucnVuKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZWdpc3RlckRvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicsIChldikgPT4ge1xyXG5cdFx0XHRpZiAoZXYuY3RybEtleSAmJiBldi5zaGlmdEtleSAmJiBldi5rZXkgPT0gXCJTXCIpIHtcclxuXHRcdFx0XHRpZighdGhpcy5jcHUuYWN0aXZlRXhlcmNpc2UpIG5ldyBOb3RpY2UoXCJDdXJyZW50bHksIE5vIEV4ZXJjaXNlIGlzIGFjdGl2ZSFcIilcclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdG5ldyBBc3Nlc3NNb2RhbCh0aGlzLmFwcCx0aGlzLmNwdSkub3BlbigpXHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiU3VjY2Vzc2Z1bGx5IGNsb3NlZCB0aGUgYWN0aXZlIGV4ZXJjaXNlXCIpXHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHQvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cclxuXHRcdC8vIHRoaXMucmVnaXN0ZXJJbnRlcnZhbCh3aW5kb3cuc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge2NvbnNvbGUubG9nKHRoaXMuY3B1LmJhc2VzKX0sIDMgKiAxMDAwKSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIG9uRXhjYWxpZHJhd0ZpbGVDaGFuZ2UoZmlsZTogVEFic3RyYWN0RmlsZSk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Ly8gY29uc29sZS5sb2coYCR7ZmlsZS5uYW1lfSBDaGFuZ2VkIWApO1xyXG5cdFx0Y29uc3QgdEZpbGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGZpbGUucGF0aCxmaWxlLnBhdGgpO1xyXG5cdFx0Y29uc3QgZmlsZU5hbWUgPSB0RmlsZT8uYmFzZW5hbWUgPyB0RmlsZT8uYmFzZW5hbWUgOiBcIlwiO1xyXG5cdFx0bmV3IE5vdGljZShcInBpY2tpbmcgb3V0IGNoYW5nZWQgZXhjYWxpZHJhdyBmaWxlXCIsMzAwMCk7XHJcblx0XHRjb25zdCBleGNhbGlkcmF3RmlsZTogRXhjYWxpZHJhd0ZpbGUgfCB1bmRlZmluZWQgPSB0aGlzLmNwdS5iYXNlc1tFWEVSQ0lTRV9TVUJKRUNULk1BVEhdXHJcblx0XHRcdC5leGNhbGlkcmF3c19bZmlsZU5hbWVdIHx8IHRoaXMuY3B1LmJhc2VzW0VYRVJDSVNFX1NVQkpFQ1QuRFNQXVxyXG5cdFx0XHQuZXhjYWxpZHJhd3NfW2ZpbGVOYW1lXSB8fCB0aGlzLmNwdS5iYXNlc1tFWEVSQ0lTRV9TVUJKRUNULlBPTElUSUNTXVxyXG5cdFx0XHQuZXhjYWxpZHJhd3NfW2ZpbGVOYW1lXTtcclxuXHRcdG5ldyBOb3RpY2UoYCR7ZmlsZS5uYW1lfSBDaGFuZ2VkIWAsIDMwMDApO1xyXG5cdFx0aWYgKGV4Y2FsaWRyYXdGaWxlKSB7XHJcblx0XHRcdGNvbnN0IHN1YmplY3QgPSBleGNhbGlkcmF3RmlsZS5zdWJqZWN0O1xyXG5cdFx0XHRleGNhbGlkcmF3RmlsZS5lbGVtZW50cyA9IGF3YWl0IEV4Y2FsaWRyYXdGaWxlLnJlYWQodGhpcy5hcHAsIGV4Y2FsaWRyYXdGaWxlLnBhdGgpO1xyXG5cdFx0XHRuZXcgTm90aWNlKGBQcmV2aW91cyBudW1iZXIgb2YgZXhlcmNpc2VzIGluIGV4Y2FsaWRyYXdGaWxlIGZpbGU6ICR7ZXhjYWxpZHJhd0ZpbGUucHJldmllb3VzRXhlcmNpc2VBcnJheS5zaXplfVxcblxcbkN1cnJlbnQgbnVtYmVyIG9mIGV4ZXJjaXNlcyBpbiBleGNhbGlkcmF3RmlsZSBmaWxlOiAke2V4Y2FsaWRyYXdGaWxlLmV4ZXJjaXNlQXJyYXkuc2l6ZX1gLCAyMDAwKTtcclxuXHJcblx0XHRcdGNvbnN0IG5ld0xUQXJyYXkgPSBleGNhbGlkcmF3RmlsZS5maWx0ZXJGb3JOZXdFeGVyY2lzZSgpO1xyXG5cdFx0XHRjb25zdCBkZWxldGVkTFRBcnJheSA9IGV4Y2FsaWRyYXdGaWxlLmZpbHRlckZvckRlbGV0ZWRFeGVyY2lzZSgpO1xyXG5cdFx0XHRpZiAobmV3TFRBcnJheS5sZW5ndGggPiAwIHx8IGRlbGV0ZWRMVEFycmF5Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR0aGlzLmNwdS5iYXNlc1tzdWJqZWN0XS51cGRhdGVSdW50aW1lQmFzZShcImRlbGV0ZVwiLCBkZWxldGVkTFRBcnJheSk7XHJcblx0XHRcdFx0dGhpcy5jcHUuYmFzZXNbc3ViamVjdF0udXBkYXRlUnVudGltZUJhc2UoXCJjcmVhdGVcIixuZXdMVEFycmF5KTtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmNwdS5iYXNlc1tzdWJqZWN0XS5zYXZlKCk7XHJcblx0XHRcdFx0ZXhjYWxpZHJhd0ZpbGUucHJldmllb3VzRXhlcmNpc2VBcnJheSA9IG5ldyBTZXQoZXhjYWxpZHJhd0ZpbGUuZXhlcmNpc2VBcnJheSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9udW5sb2FkKCkge1xyXG5cdFx0dGhpcy5hcHAudmF1bHQub2ZmcmVmKHRoaXMub25FeEZpbGVDaGFuZ2VSZWYpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgdXBkYXRlKCl7XHJcblx0XHRmb3IgKGxldCBzdWJqZWN0IG9mIE9iamVjdC5rZXlzKEVYRVJDSVNFX0JBU0UpKSB7XHJcblx0XHRcdGxldCBuID0gMDtcclxuXHRcdFx0Y29uc3QgbmIgPSBhd2FpdCBFeGVyY2lzZUJhc2UubWlncmF0ZUZyb21PQnRvTkIodGhpcy5hcHAsIEVYRVJDSVNFX0JBU0Vbc3ViamVjdF0pO1xyXG5cdFx0XHRuYi5zaXplID0gbmIuZXhlcmNpc2VzLmxlbmd0aDtcclxuXHRcdFx0bmIuZXhlcmNpc2VzLmZvckVhY2goKGV4KT0+e2V4LnN0YXRlID09PSBFWEVSQ0lTRV9TVEFUVVNFUy5MYXNlcj8gbisrIDogLTF9KVxyXG5cdFx0XHRuYi5pdGVtc19jb21wbGV0ZWQgPSBuO1xyXG5cdFx0XHRhd2FpdCBuYi5zYXZlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblx0Ly8gXHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHQvLyB9XHJcblx0Ly9cclxuXHQvLyBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0Ly8gXHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdC8vIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBc3Nlc3NNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuXHRzdGF0dXM6IEVYRVJDSVNFX1NUQVRVU0VTO1xyXG5cdGNwdTogRGF0YVByb2Nlc3NvclxyXG5cdHJlbWFyazogc3RyaW5nO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6QXBwLGNwdTogRGF0YVByb2Nlc3Nvcikge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHRcdHRoaXMuY3B1ID0gY3B1O1xyXG5cdH1cclxuXHJcblx0b25PcGVuKCkge1xyXG5cclxuXHRcdHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIix7dGV4dDpcIkFzc2Vzc1wifSlcclxuXHJcblx0XHQvLyBTZXQgU3RhdHVzXHJcblx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcclxuXHRcdFx0LmFkZERyb3Bkb3duKGRwID0+IHtcclxuXHRcdFx0XHRkcC5hZGRPcHRpb25zKEVYRVJDSVNFX1NUQVRVU0VTX1NXQVBQRUQpO1xyXG5cdFx0XHRcdHRoaXMuc3RhdHVzID0gZHAuZ2V0VmFsdWUoKSBhcyBFWEVSQ0lTRV9TVEFUVVNFUztcclxuXHRcdFx0XHRkcFxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHYgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0dXMgPSB2IGFzIEVYRVJDSVNFX1NUQVRVU0VTO1xyXG5cdFx0XHRcdH0pXHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQvLyBTZXQgUmVtYXJrXHJcblx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcclxuXHRcdFx0LnNldE5hbWUoXCJFeGVyY2lzZSBTdW1tYXJ5XCIpXHJcblx0XHRcdC5zZXREZXNjKFwiWW91IGNhbiB3cml0ZSBkb3duIHlvdXIgYnJpbGxpYW50IGlkZWFzIGFib3V0IHRoaXMgZXhlcmNpc2VcIilcclxuXHRcdFx0LmFkZFRleHRBcmVhKHRhID0+IHtcclxuXHRcdFx0XHR0YVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHYgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlbWFyayA9IHZcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0Ly8gQ2xvc2UgQnV0dG9uXHJcblx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcclxuXHRcdFx0LmFkZEJ1dHRvbihidCA9PiB7XHJcblx0XHRcdFx0YnRcclxuXHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQ29uZmlybVwiKVxyXG5cdFx0XHRcdFx0LnNldEN0YSgpXHJcblx0XHRcdFx0XHQub25DbGljaygoKT0+e1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jcHUuYWN0aXZlRXhlcmNpc2Upe1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY3B1LmFjdGl2ZUV4ZXJjaXNlPy5zZXRTdGF0dXModGhpcy5zdGF0dXMpO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY3B1LmFjdGl2ZUV4ZXJjaXNlPy5zZXRSZW1hcmsodGhpcy5yZW1hcmspO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY3B1LmNsb3NlVXBDdXJyZW50RXhlcmNpc2UoKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0bmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXHJcblx0XHRcdC5hZGRCdXR0b24oYnQgPT4ge1xyXG5cdFx0XHRcdGJ0XHJcblx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIlF1aXQgRXhlcmNpc2UgV2l0aG91dCBTYXZpbmdcIilcclxuXHRcdFx0XHRcdC5zZXRDdGEoKVxyXG5cdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNwdS5jbG9zZVVwQ3VycmVudEV4ZXJjaXNlKHRydWUpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHR9KVxyXG5cclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgQmFzZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cdGNwdTogRGF0YVByb2Nlc3NvcjtcclxuXHRjdjpzdHJpbmc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjcHU6RGF0YVByb2Nlc3Nvcil7XHJcblx0XHRzdXBlcihhcHApO1xyXG5cdFx0dGhpcy5jcHUgPSBjcHU7XHJcblx0fVxyXG5cclxuXHRvbk9wZW4oKSB7XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5jcmVhdGVFbChcImgxXCIse3RleHQ6XCJFeGVyY2lzZSBCYXNlIFNlbGVjdGlvblwifSlcclxuXHJcblx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcclxuXHRcdFx0LmFkZERyb3Bkb3duKChkcCA9PiB7XHJcblx0XHRcdFx0dGhpcy5jdiA9IGRwXHJcblx0XHRcdFx0XHQuYWRkT3B0aW9ucyhPYmplY3QudmFsdWVzKEVYRVJDSVNFX1NVQkpFQ1QpLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PihcclxuXHRcdFx0XHRcdFx0KGFjYyxpdGVtKT0+e1xyXG5cdFx0XHRcdFx0XHRhY2NbaXRlbV0gPSBpdGVtO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gYWNjO1xyXG5cdFx0XHRcdFx0fSwge30pKS5nZXRWYWx1ZSgpO1xyXG5cclxuXHRcdFx0XHRkcFxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHYgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmN2XHQgPSB2XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHR9KSlcclxuXHJcblx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcclxuXHRcdFx0LmFkZEJ1dHRvbihidCA9PiB7XHJcblx0XHRcdFx0YnRcclxuXHRcdFx0XHRcdC5zZXRDdGEoKVxyXG5cdFx0XHRcdFx0LnNldEJ1dHRvblRleHQoXCJDb25maXJtXCIpXHJcblx0XHRcdFx0XHQub25DbGljaygoKT0+e1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNwdS5hY3RpdmVCYXNlID0gdGhpcy5jcHUuYmFzZXNbdGhpcy5jdl07XHJcblx0XHRcdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdH0pXHJcblx0fVxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4vLyBcdHBsdWdpbjogTXlQbHVnaW47XHJcbi8vXHJcbi8vIFx0Y29uc3RydWN0b3IoYXBwXzogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcbi8vIFx0XHRzdXBlcihhcHBfLCBwbHVnaW4pO1xyXG4vLyBcdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbi8vIFx0fVxyXG4vL1xyXG4vLyBcdGRpc3BsYXkoKTogdm9pZCB7XHJcbi8vIFx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcclxuLy9cclxuLy8gXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcbi8vXHJcbi8vIFx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuLy8gXHRcdFx0LnNldE5hbWUoJ1NldHRpbmcgIzEnKVxyXG4vLyBcdFx0XHQuc2V0RGVzYygnSXRcXCdzIGEgc2VjcmV0JylcclxuLy8gXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbi8vIFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXHJcbi8vIFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZylcclxuLy8gXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbi8vIFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcclxuLy8gXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4vLyBcdFx0XHRcdH0pKTtcclxuLy8gXHR9XHJcbi8vIH1cclxuIiwgImltcG9ydCB7XHJcblx0QXBwLFxyXG5cdG1vbWVudCwgbm9ybWFsaXplUGF0aCxcclxufSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7RXhlcmNpc2VIaXN0b3J5LCBFeGVyY2lzZU1ldGFkYXRhX1YxfSBmcm9tIFwiLi9zcmMvZXhlcmNpc2VfdmVyc2lvblwiO1xyXG5pbXBvcnQge0VYRVJDSVNFX1NUQVRVU0VTfSBmcm9tIFwiLi9zcmMvY29uc3RhbnRzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBFeGVyY2lzZUxpbmtUZXh0ID0gc3RyaW5nO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBFeGVyY2lzZSBpbXBsZW1lbnRzIEV4ZXJjaXNlTWV0YWRhdGFfVjF7XHJcblx0YXBwXzpBcHA7XHJcblxyXG5cdC8vIHNvdXJjZTogRXhlcmNpc2VMaW5rVGV4dDtcclxuXHRzb3VyY2U6IEV4ZXJjaXNlTGlua1RleHQ7XHJcblxyXG5cdGhpc3Rvcnk6IEV4ZXJjaXNlSGlzdG9yeVtdO1xyXG5cclxuXHRpZDogc3RyaW5nO1xyXG5cclxuXHRzdWJqZWN0OiBzdHJpbmc7XHJcblxyXG5cdHN0YXRlOiBFWEVSQ0lTRV9TVEFUVVNFUztcclxuXHJcblx0cmVtYXJrOiBzdHJpbmcgPSBcIlwiO1xyXG5cclxuXHRpbmRleDogbnVtYmVyO1xyXG5cclxuXHRzdGFydF90aW1lOiBudW1iZXI7XHJcblxyXG5cdGVuZF90aW1lOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDpBcHAsIGV4ZXJjaXNlSW5mbzogRXhlcmNpc2VNZXRhZGF0YV9WMSkge1xyXG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLGV4ZXJjaXNlSW5mbylcclxuXHRcdHRoaXMuYXBwXyA9IGFwcFxyXG5cdFx0dGhpcy5oaXN0b3J5ID0gZXhlcmNpc2VJbmZvPy5oaXN0b3J5IHx8IFtdO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGV4dHJhY3RJZEZyb21MaW5rKGVsOiBFeGVyY2lzZUxpbmtUZXh0KSB7XHJcblx0XHRjb25zdCBtYXRjaCA9IGVsLm1hdGNoKC9cXF5cXHMqKFxcUyopLyk7XHJcblx0XHRyZXR1cm4gbWF0Y2g/LlsxXSB8fCBcIlwiO1xyXG5cdH1cclxuXHJcblx0c3RhcnQoKSB7XHJcblx0XHR0aGlzLnN0YXJ0X3RpbWUgPSBtb21lbnQoKS52YWx1ZU9mKCk7XHJcblx0XHR0aGlzLmFwcF8ud29ya3NwYWNlLm9wZW5MaW5rVGV4dCh0aGlzLnNvdXJjZSwgdGhpcy5zb3VyY2UsdHJ1ZSk7XHJcblx0fVxyXG5cclxuXHRjbG9zZSgpIHtcclxuXHRcdHRoaXMuZW5kX3RpbWUgPSBtb21lbnQoKS52YWx1ZU9mKCk7XHJcblxyXG5cdFx0dGhpcy5oaXN0b3J5LnB1c2goe1xyXG5cdFx0XHRzdGFydFRpbWVTdGFtcDogdGhpcy5zdGFydF90aW1lLFxyXG5cdFx0XHRlbmRUaW1lU3RhbXA6IHRoaXMuZW5kX3RpbWUsXHJcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0ZSxcclxuXHRcdFx0cmVtYXJrOiB0aGlzLnJlbWFya1xyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U3RhcnRUaW1lKCk6IG1vbWVudC5Nb21lbnQge1xyXG5cdFx0cmV0dXJuIG1vbWVudCh0aGlzLnN0YXJ0X3RpbWUpO1xyXG5cdH1cclxuXHJcblx0Z2V0RW5kVGltZSgpOiBtb21lbnQuTW9tZW50IHtcclxuXHRcdHJldHVybiBtb21lbnQodGhpcy5lbmRfdGltZSk7XHJcblx0fVxyXG5cclxuXHRnZXREdXJhdGlvbkFzU3RyaW5nKCkge1xyXG5cdFx0Y29uc3QgZHVyID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuZ2V0RW5kVGltZSgpLmRpZmYodGhpcy5nZXRTdGFydFRpbWUoKSkpXHJcblx0XHRjb25zdCBob3VycyA9IE1hdGguZmxvb3IoZHVyLmFzSG91cnMoKSk7XHJcblx0XHRjb25zdCBtaW51dGVzID0gZHVyLm1pbnV0ZXMoKTtcclxuXHRcdGNvbnN0IHNlY29uZHMgPSBkdXIuc2Vjb25kcygpO1xyXG5cclxuXHRcdHJldHVybiBgXFxuXFx0LSAke2hvdXJzfSBob3Vyc1xcblxcdC0gJHttaW51dGVzfSBtaW5zXFxuXFx0LSAke3NlY29uZHN9IHNlY29uZHNgO1xyXG5cdH1cclxuXHJcblx0Z2V0RHVyYXRpb25JblNlY29uZHMoKXtcclxuXHRcdGNvbnN0IGR1ciA9IG1vbWVudC5kdXJhdGlvbih0aGlzLmdldEVuZFRpbWUoKS5kaWZmKHRoaXMuZ2V0U3RhcnRUaW1lKCkpKVxyXG5cdFx0cmV0dXJuIGR1ci5hc1NlY29uZHMoKTtcclxuXHR9XHJcblxyXG5cdHNldFN0YXR1cyhzdGF0dXM6RVhFUkNJU0VfU1RBVFVTRVMpIHtcclxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0dXM7XHJcblx0fVxyXG5cclxuXHRzZXRSZW1hcmsocmVtYXJrOiBzdHJpbmcpIHtcclxuXHRcdHRoaXMucmVtYXJrID0gcmVtYXJrXHJcblx0fVxyXG5cclxuXHRnZXRXaWtpTGluaygpOnN0cmluZ3tcclxuXHRcdHJldHVybiBgW1ske3RoaXMuc291cmNlfV1dYFxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21KU09OKGFwcDpBcHAsIGRhdGE6IEV4ZXJjaXNlTWV0YWRhdGFfVjEpOiBFeGVyY2lzZSB7XHJcblx0XHRyZXR1cm4gbmV3IEV4ZXJjaXNlKGFwcCwgZGF0YSlcclxuXHR9XHJcblxyXG5cdHRvSlNPTigpe1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c291cmNlOiB0aGlzLnNvdXJjZSxcclxuXHRcdFx0aWQ6dGhpcy5pZCxcclxuXHRcdFx0c3ViamVjdDogdGhpcy5zdWJqZWN0LFxyXG5cdFx0XHRpbmRleDp0aGlzLmluZGV4LFxyXG5cdFx0XHRzdGF0ZTogdGhpcy5zdGF0ZSxcclxuXHRcdFx0c3RhcnRfdGltZTogdGhpcy5zdGFydF90aW1lLFxyXG5cdFx0XHRlbmRfdGltZTogdGhpcy5lbmRfdGltZSxcclxuXHRcdFx0cmVtYXJrOiB0aGlzLnJlbWFyayxcclxuXHRcdFx0aGlzdG9yeTogdGhpcy5oaXN0b3J5XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuIiwgImltcG9ydCB7RXhlcmNpc2UsIEV4ZXJjaXNlTGlua1RleHR9IGZyb20gXCIuL0V4ZXJjaXNlXCI7XHJcbmltcG9ydCB7RGF0YUFycmF5LCBnZXRBUEksIExpdGVyYWx9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiO1xyXG5pbXBvcnQge0FwcCwgQ29tcG9uZW50LCBGaWxlU3lzdGVtQWRhcHRlciwgbm9ybWFsaXplUGF0aCwgTm90aWNlLCBURmlsZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7RXhjYWxpZHJhd0VsZW1lbnQsIEV4Y2FsaWRyYXdGaWxlLCBFeGNhbGlkcmF3SlNPTn0gZnJvbSBcIi4vRXhjYWxpZHJhd1wiO1xyXG5pbXBvcnQge0RhdGF2aWV3QXBpfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXcvbGliL2FwaS9wbHVnaW4tYXBpXCI7XHJcbmltcG9ydCB7R2VuZXJpY0ZpbGV9IGZyb20gXCIuL0dlbmVyaWNGaWxlXCI7XHJcbmltcG9ydCB7Z2V0RXhlcmNpc2VMaW5rVGV4dCwgcGFyc2VKU09OfSBmcm9tIFwiLi9zcmMvdXRpbGl0eS9wYXJzZXJcIjtcclxuaW1wb3J0IHttaWdyYXRlX21hcHBpbmd9IGZyb20gXCIuL3NyYy9leGVyY2lzZV92ZXJzaW9uXCI7XHJcbmltcG9ydCB7QmFzZUNvbnRlbnQsIEV4ZXJjaXNlSW5pdERhdGEsIEJhc2VNZXRhZGF0YV9WMCwgU0Jhc2VNZXRhZGF0YX0gZnJvbSBcIi4vc3JjL2Jhc2VfdmVyc2lvblwiO1xyXG5pbXBvcnQge0VYRVJDSVNFX1NUQVRVU0VTLCBFWEVSQ0lTRV9TVUJKRUNULCBRVUVSWV9TVFJBVEVHWX0gZnJvbSBcIi4vc3JjL2NvbnN0YW50c1wiO1xyXG5cclxuXHJcblxyXG5cclxuLy8gc3ViamVjdCBTd2FwS2V5VmFsdWU8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4+ID0ge1xyXG4vLyBcdFtLIGluIGtleW9mIFQgYXMgVFtLXV06IEtcclxuLy8gfVxyXG5cclxuXHJcblxyXG5leHBvcnQgY29uc3QgRVhFUkNJU0VfQkFTRTogUmVjb3JkPHN0cmluZywgRXhlcmNpc2VJbml0RGF0YT4gPSB7XHJcblx0W0VYRVJDSVNFX1NVQkpFQ1QuTUFUSF06IHtcclxuXHRcdHBhdGg6IG5vcm1hbGl6ZVBhdGgoXCJFeGVyY2lzZSBCYXNlIC0gTWF0aC5tZFwiKSxcclxuXHRcdHRhZzogXCIjZXhjYWxpZHJhdy9tYXRoXCIsXHJcblx0XHRzdWJqZWN0OiBcIk1hdGhcIixcclxuXHRcdHF1ZXJ5X3N0cmF0ZWd5OiBRVUVSWV9TVFJBVEVHWS5ORVdfRVhFUkNJU0VfRklSU1QsXHJcblx0fSxcclxuXHRbRVhFUkNJU0VfU1VCSkVDVC5EU1BdOiB7XHJcblx0XHRwYXRoOiBub3JtYWxpemVQYXRoKFwiRXhlcmNpc2UgQmFzZSAtIERTUC5tZFwiKSxcclxuXHRcdHRhZzpcIiNleGNhbGlkcmF3L3NpZ25hbHNfYW5kX3N5c3RlbXNcIixcclxuXHRcdHN1YmplY3Q6IFwiRFNQXCIsXHJcblx0XHRxdWVyeV9zdHJhdGVneTogUVVFUllfU1RSQVRFR1kuTkVXX0VYRVJDSVNFX0ZJUlNULFxyXG5cdH0sXHJcblx0W0VYRVJDSVNFX1NVQkpFQ1QuUE9MSVRJQ1NdOiB7XHJcblx0XHRwYXRoOiBub3JtYWxpemVQYXRoKFwiRXhlcmNpc2UgQmFzZSAtIFBvbGl0aWNzLm1kXCIpLFxyXG5cdFx0dGFnOlwiI2V4Y2FsaWRyYXcvXHU2NTNGXHU2Q0JCXCIsXHJcblx0XHRzdWJqZWN0OiBcIlBvbGl0aWNzXCIsXHJcblx0XHRxdWVyeV9zdHJhdGVneTogUVVFUllfU1RSQVRFR1kuTkVXX0VYRVJDSVNFX0ZJUlNULFxyXG5cdH1cclxufVxyXG4vLyBleHBvcnQgY29uc3QgRVhFUkNJU0VfU1VCSkVDVDogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhFWEVSQ0lTRV9CQVNFKTtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEV4ZXJjaXNlQmFzZSBleHRlbmRzIEdlbmVyaWNGaWxlIGltcGxlbWVudHMgU0Jhc2VNZXRhZGF0YXtcclxuXHRhcHBfOkFwcDtcclxuXHJcblx0ZGF0YVZpZXdBUElfOiBEYXRhdmlld0FwaSA9IGdldEFQSSgpIGFzIERhdGF2aWV3QXBpO1xyXG5cclxuXHRzaXplOiBudW1iZXI7XHJcblxyXG5cdGl0ZW1zX2NvbXBsZXRlZDogbnVtYmVyO1xyXG5cclxuXHRxdWVyeV9zdHJhdGVneTogUVVFUllfU1RSQVRFR1kgPSBRVUVSWV9TVFJBVEVHWS5ORVdfRVhFUkNJU0VfRklSU1Q7XHJcblxyXG5cdHN1YmplY3Q6IHN0cmluZztcclxuXHJcblx0dGFnOiBzdHJpbmc7XHJcblxyXG5cdHBhdGg6IHN0cmluZztcclxuXHJcblx0ZXhjYWxpZHJhd3NfOiB7W2VGTmFtZTogc3RyaW5nXTogRXhjYWxpZHJhd0ZpbGV9ID0ge307XHJcblxyXG5cdGV4ZXJjaXNlczogRXhlcmNpc2VbXSA9IFtdO1xyXG5cclxuXHQvLyBleGlzdHM6IGJvb2xlYW47XHJcblxyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgYmFzZU1ldGFkYXRhOiBFeGVyY2lzZUluaXREYXRhIHwgU0Jhc2VNZXRhZGF0YSkge1xyXG5cdFx0c3VwZXIoYXBwLGJhc2VNZXRhZGF0YS5wYXRoKTtcclxuXHRcdHRoaXMuZGF0YVZpZXdBUElfID0gZ2V0QVBJKCkgYXMgRGF0YXZpZXdBcGk7XHJcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIGJhc2VNZXRhZGF0YSk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBpbmRleEV4Y2FsaWRyYXcoKXtcclxuXHRcdGNvbnN0IHRhcmdldEV4Y2FsaWRyYXdQYWdlczogRGF0YUFycmF5PFJlY29yZDxzdHJpbmcsIExpdGVyYWw+PiA9IHRoaXMuZGF0YVZpZXdBUElfPy5wYWdlcyh0aGlzLnRhZykgYXMgRGF0YUFycmF5PFJlY29yZDxzdHJpbmcsIExpdGVyYWw+PjtcclxuXHRcdGZvciAobGV0IHBhZ2Ugb2YgdGFyZ2V0RXhjYWxpZHJhd1BhZ2VzKXtcclxuXHJcblx0XHRcdHRoaXMuZXhjYWxpZHJhd3NfW3BhZ2UuZmlsZS5uYW1lXSA9IG5ldyBFeGNhbGlkcmF3RmlsZSh0aGlzLmFwcF8scGFnZS5maWxlLm5hbWUse1xyXG5cdFx0XHRcdHN1YmplY3Q6IHRoaXMuc3ViamVjdCxcclxuXHRcdFx0XHRwYXRoOiBwYWdlLmZpbGUucGF0aCxcclxuXHRcdFx0XHRlbGVtZW50czogYXdhaXQgRXhjYWxpZHJhd0ZpbGUucmVhZCh0aGlzLmFwcF8scGFnZS5maWxlLnBhdGgpXHJcblx0XHRcdH0pXHJcblx0XHRcdHRoaXMuZXhjYWxpZHJhd3NfW3BhZ2UuZmlsZS5uYW1lXS5wcmV2aWVvdXNFeGVyY2lzZUFycmF5ID0gdGhpcy5leGNhbGlkcmF3c19bcGFnZS5maWxlLm5hbWVdLmV4ZXJjaXNlQXJyYXk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRhc3luYyBpbml0SW5kZXgoKXtcclxuXHRcdC8vIEluZGV4IEV4Y2FsaWRyYXcgRmlsZXNcclxuXHRcdGF3YWl0IHRoaXMuaW5kZXhFeGNhbGlkcmF3KCk7XHJcblxyXG5cdFx0Ly8gSW5kZXggRXhlcmNpc2VzXHJcblx0XHRjb25zdCBleGVyY2lzZUxpbmtBcnJheSA9IE9iamVjdC52YWx1ZXModGhpcy5leGNhbGlkcmF3c18pLmZsYXRNYXAoKGV4Y2FsKSA9PiBnZXRFeGVyY2lzZUxpbmtUZXh0KGV4Y2FsKSk7XHJcblxyXG5cdFx0dGhpcy5leGVyY2lzZXMucHVzaCguLi5leGVyY2lzZUxpbmtBcnJheS5tYXAoKGVsLGluZGV4KSA9PiBFeGVyY2lzZS5mcm9tSlNPTih0aGlzLmFwcF8sIHtcclxuXHRcdFx0c291cmNlOiBlbCxcclxuXHRcdFx0c3ViamVjdDogdGhpcy5zdWJqZWN0LFxyXG5cdFx0XHRzdGF0ZTogRVhFUkNJU0VfU1RBVFVTRVMuTmV3LFxyXG5cdFx0XHRyZW1hcms6IFwiXCIsXHJcblx0XHRcdGluZGV4OiBpbmRleCxcclxuXHRcdFx0aGlzdG9yeTogW10sXHJcblx0XHRcdGlkOiBFeGVyY2lzZS5leHRyYWN0SWRGcm9tTGluayhlbCksXHJcblx0XHRcdHN0YXJ0X3RpbWU6IDAsXHJcblx0XHRcdGVuZF90aW1lOiAwXHJcblx0XHR9KSkpXHJcblxyXG5cdFx0dGhpcy5zaXplID0gdGhpcy5leGVyY2lzZXMubGVuZ3RoO1xyXG5cdFx0dGhpcy5pdGVtc19jb21wbGV0ZWQgPSAwO1xyXG5cdH1cclxuXHJcblx0anNvbmlmeSgpOiBCYXNlQ29udGVudCB7XHJcblx0XHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuXHRcdC8vIGNvbnNvbGUubG9nKHRoaXMuc2l6ZSk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLml0ZW1zX2NvbXBsZXRlZCk7XHJcblx0XHRyZXR1cm4gYFxcYFxcYFxcYGpzb25cXG4ke0pTT04uc3RyaW5naWZ5KHRoaXMsIChrLHYpID0+IHtcclxuXHRcdFx0aWYgKGsuZW5kc1dpdGgoXCJfXCIpKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRyZXR1cm4gdjtcclxuXHRcdH0sIDQpfVxcblxcYFxcYFxcYGBcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmUoKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5qc29uaWZ5KCk7XHJcblx0XHRhd2FpdCB0aGlzLmFwcF8udmF1bHQuYWRhcHRlci53cml0ZSh0aGlzLnBhdGgsIGRhdGEpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGFzeW5jIHJlYWQoYXBwOkFwcCwgcGF0aDpzdHJpbmcpOiBQcm9taXNlPEV4ZXJjaXNlQmFzZT57XHJcblx0XHRsZXQgYmFzZUpTT046IFNCYXNlTWV0YWRhdGEgPSBwYXJzZUpTT04oYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChub3JtYWxpemVQYXRoKHBhdGgpKSlcclxuXHRcdHJldHVybiBhd2FpdCBFeGVyY2lzZUJhc2UuZnJvbUpTT04oYXBwLCBiYXNlSlNPTik7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgYXN5bmMgY3JlYXRlKGFwcDpBcHAsIHN1YmplY3Q6IHN0cmluZyk6IFByb21pc2U8RXhlcmNpc2VCYXNlPntcclxuXHRcdGNvbnN0IGJhc2UgPSBuZXcgRXhlcmNpc2VCYXNlKGFwcCwgRVhFUkNJU0VfQkFTRVtzdWJqZWN0XSlcclxuXHRcdGF3YWl0IGJhc2UuaW5pdEluZGV4KCk7XHJcblx0XHRhd2FpdCBiYXNlLnNhdmUoKTtcclxuXHRcdHJldHVybiBiYXNlO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGFzeW5jIGZyb21KU09OKGFwcDpBcHAsIG9iajogU0Jhc2VNZXRhZGF0YSk6IFByb21pc2U8RXhlcmNpc2VCYXNlPiB7XHJcblx0XHRvYmouZXhlcmNpc2VzID0gb2JqLmV4ZXJjaXNlcy5tYXAoZXggPT4gbmV3IEV4ZXJjaXNlKGFwcCxleCkpXHJcblx0XHRsZXQgYmFzZTogRXhlcmNpc2VCYXNlID0gbmV3IEV4ZXJjaXNlQmFzZShhcHAsIG9iaik7XHJcblx0XHRhd2FpdCBiYXNlLmluZGV4RXhjYWxpZHJhdygpO1xyXG5cdFx0cmV0dXJuIGJhc2U7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVSdW50aW1lQmFzZShhY3Rpb25UeXBlOiBcImNyZWF0ZVwiIHwgXCJtb2RpZnlcIiB8IFwiZGVsZXRlXCIsIGN0OiBFeGVyY2lzZUxpbmtUZXh0W10gfCBFeGVyY2lzZSkge1xyXG5cclxuXHRcdC8vIEluc2VydCBuZXcgRXhlcmNpc2VzIGludG8gcnVudGltZSBiYXNlLmV4ZXJjaXNlc1xyXG5cdFx0c3dpdGNoIChhY3Rpb25UeXBlKSB7XHJcblx0XHRcdGNhc2UgXCJtb2RpZnlcIjpcclxuXHRcdFx0XHRpZiAoY3QgaW5zdGFuY2VvZiBFeGVyY2lzZSl7XHJcblx0XHRcdFx0XHR0aGlzLmV4ZXJjaXNlcy5zcGxpY2UoY3QuaW5kZXgsMCxjdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrXHJcblx0XHRcdGNhc2UgXCJjcmVhdGVcIjpcclxuXHRcdFx0XHRpZiAoIShjdCBpbnN0YW5jZW9mIEV4ZXJjaXNlKSkgdGhpcy5leGVyY2lzZXMucHVzaCguLi50aGlzLmNyZWF0ZU5ld0V4ZXJjaXNlKGN0KSk7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2codGhpcy5leGVyY2lzZXMpO1xyXG5cdFx0XHRcdGJyZWFrXHJcblx0XHRcdGNhc2UgXCJkZWxldGVcIjpcclxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjdCkpe1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgZWx0IG9mIGN0KSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZXhlcmNpc2VzLmZvckVhY2goKGV4LCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChleC5zb3VyY2UgPT0gZWx0KSB0aGlzLmV4ZXJjaXNlcy5zcGxpY2UoaW5kZXgsMSk7XHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuc2l6ZSA9IHRoaXMuZXhlcmNpc2VzLmxlbmd0aDtcclxuXHRcdHRoaXMuaXRlbXNfY29tcGxldGVkID0gdGhpcy5jYWxjdWxhdGVJdGVtQ29tcGxldGVkKCk7XHJcblx0fVxyXG5cclxuXHRjYWxjdWxhdGVJdGVtQ29tcGxldGVkKCk6IG51bWJlcntcclxuXHRcdGxldCBudW0gPSAwO1xyXG5cdFx0dGhpcy5leGVyY2lzZXMuZm9yRWFjaCgoZXgpPT4gKGV4LnN0YXRlID09IEVYRVJDSVNFX1NUQVRVU0VTLkxhc2VyID8gbnVtKysgOiAtMSkpXHJcblx0XHRyZXR1cm4gIG51bTtcclxuXHR9XHJcblxyXG5cdG5leHQoKTogRXhlcmNpc2UgfCB1bmRlZmluZWQge1xyXG5cdFx0bGV0IHJhbmRvbUV4ZXJjaXNlSW5kZXg6IG51bWJlciA9IC0xO1xyXG5cdFx0Ly8gY29uc29sZS5sb2codGhpcyk7XHJcblx0XHRpZiAodGhpcy5xdWVyeV9zdHJhdGVneSA9PSBRVUVSWV9TVFJBVEVHWS5ORVdfRVhFUkNJU0VfRklSU1QpIHtcclxuXHRcdFx0Y29uc3QgbmV3RXhlcmNpc2VzSW5kZXhlcyA9IHRoaXMuZXhlcmNpc2VzXHJcblx0XHRcdFx0Lm1hcCgoZXgpID0+IGV4LnN0YXRlID09IEVYRVJDSVNFX1NUQVRVU0VTLk5ldz8gZXguaW5kZXggOiAtMSlcclxuXHRcdFx0XHQuZmlsdGVyKChpbmRleCkgPT4gaW5kZXggIT09IC0xKTtcclxuXHJcblx0XHRcdC8vIElmIG5vIG5ldyBleGVyY2lzZXMgYXJlIGZvdW5kXHJcblx0XHRcdGlmIChuZXdFeGVyY2lzZXNJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJObyBtb3JlIG5ldyBFeGVyY2lzZXMhXCIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyYW5kb21FeGVyY2lzZUluZGV4ID0gbmV3RXhlcmNpc2VzSW5kZXhlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuZXdFeGVyY2lzZXNJbmRleGVzLmxlbmd0aCldO1xyXG5cdFx0XHRuZXcgTm90aWNlKGBFeGVyY2lzZSBhdCAke3JhbmRvbUV4ZXJjaXNlSW5kZXh9IGlzIGJlaW5nIHB1bGxlZCBvdXQuYCwzMDAwKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHJhbmRvbUV4ZXJjaXNlSW5kZXggIT0gLTEpe1xyXG5cdFx0XHRjb25zdCBuZXh0RXhlcmNpc2U6IEV4ZXJjaXNlID0gdGhpcy5leGVyY2lzZXMuc3BsaWNlKHJhbmRvbUV4ZXJjaXNlSW5kZXgsMSlbMF07XHJcblx0XHRcdHJldHVybiBuZXh0RXhlcmNpc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgYXN5bmMgbWlncmF0ZUZyb21PQnRvTkIoYXBwOkFwcCwgZGF0YTogRXhlcmNpc2VJbml0RGF0YSk6IFByb21pc2U8RXhlcmNpc2VCYXNlPntcclxuXHRcdGNvbnN0IG9iOiBCYXNlTWV0YWRhdGFfVjAgPSBwYXJzZUpTT04oYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChub3JtYWxpemVQYXRoKGRhdGEucGF0aCkpKTtcclxuXHRcdGNvbnN0IG5ld0V4ZXJjaXNlcyA9IG9iW1wiZXhlcmNpc2VzXCJdLm1hcCgobyxpbmRleCkgPT4gbWlncmF0ZV9tYXBwaW5nKG8sIGluZGV4KSk7XHJcblx0XHRyZXR1cm4gRXhlcmNpc2VCYXNlLmZyb21KU09OKGFwcCwge1xyXG5cdFx0XHRleGVyY2lzZXM6IG5ld0V4ZXJjaXNlcy5tYXAoZXggPT4gbmV3IEV4ZXJjaXNlKGFwcCxleCkpLFxyXG5cdFx0XHRpdGVtc19jb21wbGV0ZWQ6IDAsXHJcblx0XHRcdHF1ZXJ5X3N0cmF0ZWd5OiBRVUVSWV9TVFJBVEVHWS5ORVdfRVhFUkNJU0VfRklSU1QsXHJcblx0XHRcdHNpemU6MCxcclxuXHRcdFx0dGFnOiBkYXRhLnRhZyxcclxuXHRcdFx0c3ViamVjdDpkYXRhLnN1YmplY3QsXHJcblx0XHRcdHBhdGg6IGRhdGEucGF0aFxyXG5cdFx0fSlcclxuXHR9XHJcblxyXG5cdGNyZWF0ZU5ld0V4ZXJjaXNlKGV4ZXJjaXNlc0xpbmtBcnJheTogc3RyaW5nW10pOiBFeGVyY2lzZVtdIHtcclxuXHRcdHJldHVybiBleGVyY2lzZXNMaW5rQXJyYXkubWFwKChsaW5rLCBpbmRleCkgPT4ge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBFeGVyY2lzZSh0aGlzLmFwcF8sIHtcclxuXHRcdFx0XHRzb3VyY2U6IGxpbmssXHJcblx0XHRcdFx0c3ViamVjdDogdGhpcy5zdWJqZWN0LFxyXG5cdFx0XHRcdGhpc3Rvcnk6W10sXHJcblx0XHRcdFx0aWQ6XCJcIixcclxuXHRcdFx0XHRzdGF0ZTpFWEVSQ0lTRV9TVEFUVVNFU1tcIk5ld1wiXSxcclxuXHRcdFx0XHRpbmRleDogdGhpcy5zaXplICsgaW5kZXgsXHJcblx0XHRcdFx0cmVtYXJrOiBcIlwiLFxyXG5cdFx0XHRcdHN0YXJ0X3RpbWU6MCxcclxuXHRcdFx0XHRlbmRfdGltZTowXHJcblx0XHRcdH0pXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cclxufVxyXG4iLCAiaW1wb3J0IHtBcHAsIEV2ZW50UmVmLCBub3JtYWxpemVQYXRoLCBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtHZW5lcmljRmlsZX0gZnJvbSBcIi4vR2VuZXJpY0ZpbGVcIjtcclxuaW1wb3J0IHtFeGVyY2lzZUJhc2V9IGZyb20gXCIuL0V4ZXJjaXNlQmFzZVwiO1xyXG5pbXBvcnQge0V4ZXJjaXNlLCBFeGVyY2lzZUxpbmtUZXh0fSBmcm9tIFwiLi9FeGVyY2lzZVwiO1xyXG5pbXBvcnQge2dldEV4ZXJjaXNlTGlua1RleHQsIHBhcnNlSlNPTn0gZnJvbSBcIi4vc3JjL3V0aWxpdHkvcGFyc2VyXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEV4Y2FsaWRyYXdKU09OIHtcclxuXHRlbGVtZW50czogRXhjYWxpZHJhd0VsZW1lbnRbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFeGNhbGlkcmF3RWxlbWVudCB7XHJcblx0c3Ryb2tlQ29sb3I6c3RyaW5nO1xyXG5cdHR5cGU6IHN0cmluZztcclxuXHRpZD86IHN0cmluZztcclxuXHRpc0RlbGV0ZWQ/OiBib29sZWFuXHJcbn1cclxuZXhwb3J0IGNvbnN0IEVYRVJDSVNFX0JPWDpFeGNhbGlkcmF3RWxlbWVudCA9IHtcclxuXHRzdHJva2VDb2xvcjogXCIjODQ2MzU4XCIsXHJcblx0dHlwZTogXCJyZWN0YW5nbGVcIlxyXG59XHJcblxyXG5pbnRlcmZhY2UgRXhjYWxpZHJhd01ldGFkYXRhIHtcclxuXHRzdWJqZWN0OiBzdHJpbmc7XHJcblx0Y3VycmVudENvbnRlbnQ/OiBzdHJpbmc7XHJcblx0ZWxlbWVudHM/OiBFeGNhbGlkcmF3RWxlbWVudFtdO1xyXG5cdHBhdGg6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEV4Y2FsaWRyYXdGaWxlIGV4dGVuZHMgR2VuZXJpY0ZpbGUgaW1wbGVtZW50cyBFeGNhbGlkcmF3TWV0YWRhdGEge1xyXG5cdGFwcF86QXBwO1xyXG5cclxuXHRzdWJqZWN0OiBzdHJpbmc7XHJcblxyXG5cdG5hbWU6c3RyaW5nXHJcblxyXG5cdGVsZW1lbnRzOiBFeGNhbGlkcmF3RWxlbWVudFtdO1xyXG5cclxuXHRwYXRoOiBzdHJpbmc7XHJcblxyXG5cdHByZXZpZW91c0V4ZXJjaXNlQXJyYXk6IFNldDxFeGVyY2lzZUxpbmtUZXh0PjtcclxuXHJcblx0Ly8gXHU3M0IwXHU1NzI4XHU4QkZCXHU1M0Q2RXhjYWxpZHJhd1x1NjU4N1x1NEVGNlx1NzY4NFx1NzZFRVx1NzY4NFx1NTNFQVx1NjYyRlx1OEJGQlx1NTNENlx1NTE3Nlx1NTE4NVx1OTBFOFx1NzY4NEV4Y2FsaWRyYXcgRWxlbWVudHNcclxuXHRzdGF0aWMgYXN5bmMgcmVhZChhcHA6QXBwLCBwYXRoOnN0cmluZyk6IFByb21pc2U8RXhjYWxpZHJhd0VsZW1lbnRbXT4ge1xyXG5cdFx0Ly8gR2V0IEV4Y2FsaWRyYXcgQ29udGVudFxyXG5cdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLnJlYWQobm9ybWFsaXplUGF0aChwYXRoKSk7XHJcblx0XHQvLyBQYXJzZSB0aGUgY29udGVudCBmb3IgZWxlbWVudHNcclxuXHRcdGNvbnN0IHBhcnNlZEpTT05CbG9jayA9IHBhcnNlSlNPTihjb250ZW50KSBhcyBFeGNhbGlkcmF3SlNPTjtcclxuXHRcdHJldHVybiBwYXJzZWRKU09OQmxvY2suZWxlbWVudHM7XHJcblx0fVxyXG5cclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOkFwcCwgbmFtZTpzdHJpbmcsIGV4Y2FsaWRyYXdGaWxlSW5mbzogRXhjYWxpZHJhd01ldGFkYXRhKSB7XHJcblx0XHRzdXBlcihhcHAsIGV4Y2FsaWRyYXdGaWxlSW5mby5wYXRoKVxyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHRcdE9iamVjdC5hc3NpZ24odGhpcyxleGNhbGlkcmF3RmlsZUluZm8pO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHJcblx0ZmlsdGVyRm9yTmV3RXhlcmNpc2UoKTogRXhlcmNpc2VMaW5rVGV4dFtdIHtcclxuXHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXhlcmNpc2VBcnJheSkuZmlsdGVyKGV4ID0+ICF0aGlzLnByZXZpZW91c0V4ZXJjaXNlQXJyYXkuaGFzKGV4KSk7XHJcblx0fVxyXG5cdGZpbHRlckZvckRlbGV0ZWRFeGVyY2lzZSgpOiBFeGVyY2lzZUxpbmtUZXh0W10ge1xyXG5cdFx0cmV0dXJuIEFycmF5LmZyb20odGhpcy5wcmV2aWVvdXNFeGVyY2lzZUFycmF5KS5maWx0ZXIoZXggPT4gIXRoaXMuZXhlcmNpc2VBcnJheS5oYXMoZXgpKTtcclxuXHR9XHJcblx0Z2V0IGV4ZXJjaXNlQXJyYXkoKXtcclxuXHRcdHJldHVybiBuZXcgU2V0KGdldEV4ZXJjaXNlTGlua1RleHQodGhpcykpXHJcblx0fVxyXG59XHJcblxyXG5cclxuIiwgImltcG9ydCB7QXBwLCBub3JtYWxpemVQYXRoLCBUQWJzdHJhY3RGaWxlLCBURmlsZX0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cblxuZXhwb3J0IGNsYXNzIEdlbmVyaWNGaWxlIHtcblx0YXBwXzogQXBwO1xuXHRuYW1lOiBzdHJpbmc7XG5cdHBhdGg6IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGF0aDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hcHBfID0gYXBwO1xuXHRcdHRoaXMucGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG5cdH1cblxuXHRhc3luYyByZWFkKGZpbGU/OlRBYnN0cmFjdEZpbGUgfCBudWxsKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0XHRjb25zdCBwYXRoID0gZmlsZT8gZmlsZS5wYXRoIDogdGhpcy5wYXRoXG5cblx0XHRpZiAocGF0aCkge1xuXHRcdFx0Y29uc3QgZmlsZTpURmlsZSB8IG51bGwgPSB0aGlzLmFwcF8ubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLHBhdGgpXG5cdFx0XHRpZiAoZmlsZSkgcmV0dXJuIGF3YWl0IHRoaXMuYXBwXy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG59XG4iLCAiXG4vKiEganMteWFtbCA0LjEuMCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL2pzLXlhbWwgQGxpY2Vuc2UgTUlUICovXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKHN1YmplY3QgPT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChzdWJqZWN0ICE9PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO1xuICBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsIGN5Y2xlO1xuXG4gIGZvciAoY3ljbGUgPSAwOyBjeWNsZSA8IGNvdW50OyBjeWNsZSArPSAxKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyID09PSAwKSAmJiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyKTtcbn1cblxuXG52YXIgaXNOb3RoaW5nXzEgICAgICA9IGlzTm90aGluZztcbnZhciBpc09iamVjdF8xICAgICAgID0gaXNPYmplY3Q7XG52YXIgdG9BcnJheV8xICAgICAgICA9IHRvQXJyYXk7XG52YXIgcmVwZWF0XzEgICAgICAgICA9IHJlcGVhdDtcbnZhciBpc05lZ2F0aXZlWmVyb18xID0gaXNOZWdhdGl2ZVplcm87XG52YXIgZXh0ZW5kXzEgICAgICAgICA9IGV4dGVuZDtcblxudmFyIGNvbW1vbiA9IHtcblx0aXNOb3RoaW5nOiBpc05vdGhpbmdfMSxcblx0aXNPYmplY3Q6IGlzT2JqZWN0XzEsXG5cdHRvQXJyYXk6IHRvQXJyYXlfMSxcblx0cmVwZWF0OiByZXBlYXRfMSxcblx0aXNOZWdhdGl2ZVplcm86IGlzTmVnYXRpdmVaZXJvXzEsXG5cdGV4dGVuZDogZXh0ZW5kXzFcbn07XG5cbi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGV4Y2VwdGlvbiwgY29tcGFjdCkge1xuICB2YXIgd2hlcmUgPSAnJywgbWVzc2FnZSA9IGV4Y2VwdGlvbi5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknO1xuXG4gIGlmICghZXhjZXB0aW9uLm1hcmspIHJldHVybiBtZXNzYWdlO1xuXG4gIGlmIChleGNlcHRpb24ubWFyay5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIGV4Y2VwdGlvbi5tYXJrLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICcoJyArIChleGNlcHRpb24ubWFyay5saW5lICsgMSkgKyAnOicgKyAoZXhjZXB0aW9uLm1hcmsuY29sdW1uICsgMSkgKyAnKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQpIHtcbiAgICB3aGVyZSArPSAnXFxuXFxuJyArIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQ7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZSArICcgJyArIHdoZXJlO1xufVxuXG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24kMShyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXRFcnJvcih0aGlzLCBmYWxzZSk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24kMS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBZQU1MRXhjZXB0aW9uJDE7XG5cblxuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyBmb3JtYXRFcnJvcih0aGlzLCBjb21wYWN0KTtcbn07XG5cblxudmFyIGV4Y2VwdGlvbiA9IFlBTUxFeGNlcHRpb24kMTtcblxuLy8gZ2V0IHNuaXBwZXQgZm9yIGEgc2luZ2xlIGxpbmUsIHJlc3BlY3RpbmcgbWF4TGVuZ3RoXG5mdW5jdGlvbiBnZXRMaW5lKGJ1ZmZlciwgbGluZVN0YXJ0LCBsaW5lRW5kLCBwb3NpdGlvbiwgbWF4TGluZUxlbmd0aCkge1xuICB2YXIgaGVhZCA9ICcnO1xuICB2YXIgdGFpbCA9ICcnO1xuICB2YXIgbWF4SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IobWF4TGluZUxlbmd0aCAvIDIpIC0gMTtcblxuICBpZiAocG9zaXRpb24gLSBsaW5lU3RhcnQgPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgaGVhZCA9ICcgLi4uICc7XG4gICAgbGluZVN0YXJ0ID0gcG9zaXRpb24gLSBtYXhIYWxmTGVuZ3RoICsgaGVhZC5sZW5ndGg7XG4gIH1cblxuICBpZiAobGluZUVuZCAtIHBvc2l0aW9uID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIHRhaWwgPSAnIC4uLic7XG4gICAgbGluZUVuZCA9IHBvc2l0aW9uICsgbWF4SGFsZkxlbmd0aCAtIHRhaWwubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdHI6IGhlYWQgKyBidWZmZXIuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kKS5yZXBsYWNlKC9cXHQvZywgJ1x1MjE5MicpICsgdGFpbCxcbiAgICBwb3M6IHBvc2l0aW9uIC0gbGluZVN0YXJ0ICsgaGVhZC5sZW5ndGggLy8gcmVsYXRpdmUgcG9zaXRpb25cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIG1heCkge1xuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIG1heCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VTbmlwcGV0KG1hcmssIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBudWxsKTtcblxuICBpZiAoIW1hcmsuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpZiAoIW9wdGlvbnMubWF4TGVuZ3RoKSBvcHRpb25zLm1heExlbmd0aCA9IDc5O1xuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ICAgICAgIT09ICdudW1iZXInKSBvcHRpb25zLmluZGVudCAgICAgID0gMTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQmVmb3JlICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0JlZm9yZSA9IDM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0FmdGVyICAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNBZnRlciAgPSAyO1xuXG4gIHZhciByZSA9IC9cXHI/XFxufFxccnxcXDAvZztcbiAgdmFyIGxpbmVTdGFydHMgPSBbIDAgXTtcbiAgdmFyIGxpbmVFbmRzID0gW107XG4gIHZhciBtYXRjaDtcbiAgdmFyIGZvdW5kTGluZU5vID0gLTE7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobWFyay5idWZmZXIpKSkge1xuICAgIGxpbmVFbmRzLnB1c2gobWF0Y2guaW5kZXgpO1xuICAgIGxpbmVTdGFydHMucHVzaChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICBpZiAobWFyay5wb3NpdGlvbiA8PSBtYXRjaC5pbmRleCAmJiBmb3VuZExpbmVObyA8IDApIHtcbiAgICAgIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZExpbmVObyA8IDApIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAxO1xuXG4gIHZhciByZXN1bHQgPSAnJywgaSwgbGluZTtcbiAgdmFyIGxpbmVOb0xlbmd0aCA9IE1hdGgubWluKG1hcmsubGluZSArIG9wdGlvbnMubGluZXNBZnRlciwgbGluZUVuZHMubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIG1heExpbmVMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCAtIChvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMpO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0JlZm9yZTsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vIC0gaSA8IDApIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSAtIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJyArIHJlc3VsdDtcbiAgfVxuXG4gIGxpbmUgPSBnZXRMaW5lKG1hcmsuYnVmZmVyLCBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSwgbGluZUVuZHNbZm91bmRMaW5lTm9dLCBtYXJrLnBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKTtcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnLScsIG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyArIGxpbmUucG9zKSArICdeJyArICdcXG4nO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0FmdGVyOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gKyBpID49IGxpbmVFbmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbn1cblxuXG52YXIgc25pcHBldCA9IG1ha2VTbmlwcGV0O1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdtdWx0aScsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAncmVwcmVzZW50TmFtZScsXG4gICdkZWZhdWx0U3R5bGUnLFxuICAnc3R5bGVBbGlhc2VzJ1xuXTtcblxudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFtcbiAgJ3NjYWxhcicsXG4gICdzZXF1ZW5jZScsXG4gICdtYXBwaW5nJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlJDEodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy5vcHRpb25zICAgICAgID0gb3B0aW9uczsgLy8ga2VlcCBvcmlnaW5hbCBvcHRpb25zIGluIGNhc2UgdXNlciB3YW50cyB0byBleHRlbmQgdGhpcyB0eXBlIGxhdGVyXG4gIHRoaXMudGFnICAgICAgICAgICA9IHRhZztcbiAgdGhpcy5raW5kICAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICAgfHwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH07XG4gIHRoaXMuaW5zdGFuY2VPZiAgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICAgPSBvcHRpb25zWydwcmVkaWNhdGUnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50TmFtZSA9IG9wdGlvbnNbJ3JlcHJlc2VudE5hbWUnXSB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSAgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSAgfHwgbnVsbDtcbiAgdGhpcy5tdWx0aSAgICAgICAgID0gb3B0aW9uc1snbXVsdGknXSAgICAgICAgIHx8IGZhbHNlO1xuICB0aGlzLnN0eWxlQWxpYXNlcyAgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbnZhciB0eXBlID0gVHlwZSQxO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5tdWx0aSA9PT0gY3VycmVudFR5cGUubXVsdGkpIHtcblxuICAgICAgICBuZXdJbmRleCA9IHByZXZpb3VzSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHRbbmV3SW5kZXhdID0gY3VycmVudFR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge30sXG4gICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgc2NhbGFyOiBbXSxcbiAgICAgICAgICBzZXF1ZW5jZTogW10sXG4gICAgICAgICAgbWFwcGluZzogW10sXG4gICAgICAgICAgZmFsbGJhY2s6IFtdXG4gICAgICAgIH1cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlLm11bHRpKSB7XG4gICAgICByZXN1bHQubXVsdGlbdHlwZS5raW5kXS5wdXNoKHR5cGUpO1xuICAgICAgcmVzdWx0Lm11bHRpWydmYWxsYmFjayddLnB1c2godHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEkMShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZChkZWZpbml0aW9uKTtcbn1cblxuXG5TY2hlbWEkMS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGRlZmluaXRpb24pIHtcbiAgdmFyIGltcGxpY2l0ID0gW107XG4gIHZhciBleHBsaWNpdCA9IFtdO1xuXG4gIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgdHlwZSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQodHlwZSlcbiAgICBleHBsaWNpdC5wdXNoKGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoWyB0eXBlMSwgdHlwZTIsIC4uLiBdKVxuICAgIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoZGVmaW5pdGlvbiAmJiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLmltcGxpY2l0KSB8fCBBcnJheS5pc0FycmF5KGRlZmluaXRpb24uZXhwbGljaXQpKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoeyBleHBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdLCBpbXBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdIH0pXG4gICAgaWYgKGRlZmluaXRpb24uaW1wbGljaXQpIGltcGxpY2l0ID0gaW1wbGljaXQuY29uY2F0KGRlZmluaXRpb24uaW1wbGljaXQpO1xuICAgIGlmIChkZWZpbml0aW9uLmV4cGxpY2l0KSBleHBsaWNpdCA9IGV4cGxpY2l0LmNvbmNhdChkZWZpbml0aW9uLmV4cGxpY2l0KTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NjaGVtYS5leHRlbmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgVHlwZSwgWyBUeXBlIF0sICcgK1xuICAgICAgJ29yIGEgc2NoZW1hIGRlZmluaXRpb24gKHsgaW1wbGljaXQ6IFsuLi5dLCBleHBsaWNpdDogWy4uLl0gfSknKTtcbiAgfVxuXG4gIGltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUkMSkge1xuICAgIGlmICghKHR5cGUkMSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUkMS5sb2FkS2luZCAmJiB0eXBlJDEubG9hZEtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSQxLm11bHRpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdUaGVyZSBpcyBhIG11bHRpIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIE11bHRpIHRhZ3MgY2FuIG9ubHkgYmUgbGlzdGVkIGFzIGV4cGxpY2l0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgaWYgKCEodHlwZSQxIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKFNjaGVtYSQxLnByb3RvdHlwZSk7XG5cbiAgcmVzdWx0LmltcGxpY2l0ID0gKHRoaXMuaW1wbGljaXQgfHwgW10pLmNvbmNhdChpbXBsaWNpdCk7XG4gIHJlc3VsdC5leHBsaWNpdCA9ICh0aGlzLmV4cGxpY2l0IHx8IFtdKS5jb25jYXQoZXhwbGljaXQpO1xuXG4gIHJlc3VsdC5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnaW1wbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdleHBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAocmVzdWx0LmNvbXBpbGVkSW1wbGljaXQsIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG52YXIgc2NoZW1hID0gU2NoZW1hJDE7XG5cbnZhciBzdHIgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG5cbnZhciBzZXEgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcblxudmFyIG1hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG5cbnZhciBmYWlsc2FmZSA9IG5ldyBzY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHN0cixcbiAgICBzZXEsXG4gICAgbWFwXG4gIF1cbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG52YXIgX251bGwgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9LFxuICAgIGVtcHR5OiAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7ICAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxudmFyIGJvb2wgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ28nKSB7XG4gICAgICAvLyBiYXNlIDhcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApXG5cbiAgLy8gdmFsdWUgc2hvdWxkIG5vdCBzdGFydCB3aXRoIGBfYDtcbiAgaWYgKGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnbycpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDgpO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxudmFyIGludCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEludGVnZXIsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEludGVnZXIsXG4gIHByZWRpY2F0ZTogaXNJbnRlZ2VyLFxuICByZXByZXNlbnQ6IHtcbiAgICBiaW5hcnk6ICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMGInICsgb2JqLnRvU3RyaW5nKDIpIDogJy0wYicgKyBvYmoudG9TdHJpbmcoMikuc2xpY2UoMSk7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBvJyAgKyBvYmoudG9TdHJpbmcoOCkgOiAnLTBvJyAgKyBvYmoudG9TdHJpbmcoOCkuc2xpY2UoMSk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai50b1N0cmluZygxMCk7IH0sXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAgJy0weCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkuc2xpY2UoMSk7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXG4gIHN0eWxlQWxpYXNlczoge1xuICAgIGJpbmFyeTogICAgICBbIDIsICAnYmluJyBdLFxuICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxuICAgIGRlY2ltYWw6ICAgICBbIDEwLCAnZGVjJyBdLFxuICAgIGhleGFkZWNpbWFsOiBbIDE2LCAnaGV4JyBdXG4gIH1cbn0pO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OlswLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG52YXIgZmxvYXQgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbnZhciBqc29uID0gZmFpbHNhZmUuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICBfbnVsbCxcbiAgICBib29sLFxuICAgIGludCxcbiAgICBmbG9hdFxuICBdXG59KTtcblxudmFyIGNvcmUgPSBqc29uO1xuXG52YXIgWUFNTF9EQVRFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0pJCcpOyAgICAgICAgICAgICAgICAgICAvLyBbM10gZGF5XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8kJyk7ICAgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICBpZiAoWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcblxuICAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gKyhtYXRjaFsxXSk7XG4gIG1vbnRoID0gKyhtYXRjaFsyXSkgLSAxOyAvLyBKUyBtb250aCBzdGFydHMgd2l0aCAwXG4gIGRheSA9ICsobWF0Y2hbM10pO1xuXG4gIGlmICghbWF0Y2hbNF0pIHsgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH1cblxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxuXG4gIGhvdXIgPSArKG1hdGNoWzRdKTtcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XG4gIHNlY29uZCA9ICsobWF0Y2hbNl0pO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICsobWF0Y2hbMTBdKTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuICAgIGlmIChtYXRjaFs5XSA9PT0gJy0nKSBkZWx0YSA9IC1kZWx0YTtcbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG52YXIgdGltZXN0YW1wID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG52YXIgbWVyZ2UgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG5cblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgY29kZSA9IG1hcC5pbmRleE9mKGRhdGEuY2hhckF0KGlkeCkpO1xuXG4gICAgLy8gU2tpcCBDUi9MRlxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAgJ1tvYmplY3QgVWludDhBcnJheV0nO1xufVxuXG52YXIgYmluYXJ5ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkkMyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nJDIgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKF90b1N0cmluZyQyLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQzLmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbnZhciBvbWFwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG5cbnZhciBfdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZyQxLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwYWlycyA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG52YXIgX2hhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxudmFyIHNldCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG5cbnZhciBfZGVmYXVsdCA9IGNvcmUuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVyZ2VcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICBiaW5hcnksXG4gICAgb21hcCxcbiAgICBwYWlycyxcbiAgICBzZXRcbiAgXVxufSk7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbixuby11c2UtYmVmb3JlLWRlZmluZSovXG5cblxuXG5cblxuXG5cbnZhciBfaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBfZGVmYXVsdDtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICAvLyAoSGlkZGVuKSBSZW1vdmU/IG1ha2VzIHRoZSBsb2FkZXIgdG8gZXhwZWN0IFlBTUwgMS4xIGRvY3VtZW50c1xuICAvLyBpZiBzdWNoIGRvY3VtZW50cyBoYXZlIG5vIGV4cGxpY2l0ICVZQU1MIGRpcmVjdGl2ZVxuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuXG4gIHRoaXMuanNvbiAgICAgID0gb3B0aW9uc1snanNvbiddICAgICAgfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgID0gb3B0aW9uc1snbGlzdGVuZXInXSAgfHwgbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIC8vIHBvc2l0aW9uIG9mIGZpcnN0IGxlYWRpbmcgdGFiIGluIHRoZSBjdXJyZW50IGxpbmUsXG4gIC8vIHVzZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGFyZSBubyB0YWJzIGluIHRoZSBpbmRlbnRhdGlvblxuICB0aGlzLmZpcnN0VGFiSW5MaW5lID0gLTE7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB2YXIgbWFyayA9IHtcbiAgICBuYW1lOiAgICAgc3RhdGUuZmlsZW5hbWUsXG4gICAgYnVmZmVyOiAgIHN0YXRlLmlucHV0LnNsaWNlKDAsIC0xKSwgLy8gb21pdCB0cmFpbGluZyBcXDBcbiAgICBwb3NpdGlvbjogc3RhdGUucG9zaXRpb24sXG4gICAgbGluZTogICAgIHN0YXRlLmxpbmUsXG4gICAgY29sdW1uOiAgIHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0XG4gIH07XG5cbiAgbWFyay5zbmlwcGV0ID0gc25pcHBldChtYXJrKTtcblxuICByZXR1cm4gbmV3IGV4Y2VwdGlvbihtZXNzYWdlLCBtYXJrKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcmVmaXggPSBkZWNvZGVVUklDb21wb25lbnQocHJlZml4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgcHJlZml4IGlzIG1hbGZvcm1lZDogJyArIHByZWZpeCk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5JDEuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLFxuICBzdGFydExpbmUsIHN0YXJ0TGluZVN0YXJ0LCBzdGFydFBvcykge1xuXG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkkMS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5JDEuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUubGluZVN0YXJ0ID0gc3RhcnRMaW5lU3RhcnQgfHwgc3RhdGUubGluZVN0YXJ0O1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgLy8gdXNlZCBmb3IgdGhpcyBzcGVjaWZpYyBrZXkgb25seSBiZWNhdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBzbG93XG4gICAgaWYgKGtleU5vZGUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3Jlc3VsdCwga2V5Tm9kZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVOb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICB9XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkvKiBUYWIgKi8gJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg1RDsvKiBdICovXG4gICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgX3Jlc3VsdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDdCLyogeyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDdEOy8qIH0gKi9cbiAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gdGVybWluYXRvcikge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgc3RhdGUua2luZCA9IGlzTWFwcGluZyA/ICdtYXBwaW5nJyA6ICdzZXF1ZW5jZSc7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghcmVhZE5leHQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllcycpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAvLyBcImZsb3cgY29sbGVjdGlvbiBlbnRyaWVzIGNhbiBuZXZlciBiZSBjb21wbGV0ZWx5IGVtcHR5XCIsIGFzIHBlciBZQU1MIDEuMiwgc2VjdGlvbiA3LjRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsIFwiZXhwZWN0ZWQgdGhlIG5vZGUgY29udGVudCwgYnV0IGZvdW5kICcsJ1wiKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChpc0V4cGxpY2l0UGFpciB8fCBzdGF0ZS5saW5lID09PSBfbGluZSkgJiYgY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFwcGluZykge1xuICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfa2V5TGluZSxcbiAgICAgIF9rZXlMaW5lU3RhcnQsXG4gICAgICBfa2V5UG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoIWF0RXhwbGljaXRLZXkgJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYgKCFjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIC8vIE5laXRoZXIgaW1wbGljaXQgbm9yIGV4cGxpY2l0IG5vdGF0aW9uLlxuICAgICAgICAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGFnTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0YWdOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGlzIG1hbGZvcm1lZDogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchJykge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjYvKiAmICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDJBLyogKiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlTGlzdCxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAvL1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgLy9cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9va2luZyBmb3IgbXVsdGkgdHlwZVxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB0eXBlTGlzdCA9IHN0YXRlLnR5cGVNYXAubXVsdGlbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXTtcblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSB0eXBlTGlzdC5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRhZy5zbGljZSgwLCB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZy5sZW5ndGgpID09PSB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZykge1xuICAgICAgICAgIHR5cGUgPSB0eXBlTGlzdFt0eXBlSW5kZXhdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZykpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKTtcbiAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RhdGUuYW5jaG9yTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsJDEoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IGV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG52YXIgbG9hZEFsbF8xID0gbG9hZEFsbCQxO1xudmFyIGxvYWRfMSAgICA9IGxvYWQkMTtcblxudmFyIGxvYWRlciA9IHtcblx0bG9hZEFsbDogbG9hZEFsbF8xLFxuXHRsb2FkOiBsb2FkXzFcbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cblxuXG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX0JPTSAgICAgICAgICAgICAgICAgID0gMHhGRUZGO1xudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxudmFyIERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCA9IC9eWy0rXT9bMC05X10rKD86OlswLTlfXSspKyg/OlxcLlswLTlfXSopPyQvO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbnZhciBRVU9USU5HX1RZUEVfU0lOR0xFID0gMSxcbiAgICBRVU9USU5HX1RZUEVfRE9VQkxFID0gMjtcblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBfZGVmYXVsdDtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG4gIHRoaXMucXVvdGluZ1R5cGUgICA9IG9wdGlvbnNbJ3F1b3RpbmdUeXBlJ10gPT09ICdcIicgPyBRVU9USU5HX1RZUEVfRE9VQkxFIDogUVVPVElOR19UWVBFX1NJTkdMRTtcbiAgdGhpcy5mb3JjZVF1b3RlcyAgID0gb3B0aW9uc1snZm9yY2VRdW90ZXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5yZXBsYWNlciAgICAgID0gdHlwZW9mIG9wdGlvbnNbJ3JlcGxhY2VyJ10gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zWydyZXBsYWNlciddIDogbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzblx1MjAxOXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IENIQVJfQk9NKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBJbmNsdWRpbmcgcy13aGl0ZSAoZm9yIHNvbWUgcmVhc29uLCBleGFtcGxlcyBkb2Vzbid0IG1hdGNoIHNwZWNzIGluIHRoaXMgYXNwZWN0KVxuLy8gbnMtY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWxpbmUtZmVlZCAtIGItY2FycmlhZ2UtcmV0dXJuIC0gYy1ieXRlLW9yZGVyLW1hcmtcbmZ1bmN0aW9uIGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpXG4gICAgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAvLyAtIGItY2hhclxuICAgICYmIGMgIT09IENIQVJfQ0FSUklBR0VfUkVUVVJOXG4gICAgJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59XG5cbi8vIFsxMjddICBucy1wbGFpbi1zYWZlKGMpIDo6PSBjID0gZmxvdy1vdXQgIFx1MjFEMiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWluICAgXHUyMUQyIG5zLXBsYWluLXNhZmUtaW5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gYmxvY2sta2V5IFx1MjFEMiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWtleSAgXHUyMUQyIG5zLXBsYWluLXNhZmUtaW5cbi8vIFsxMjhdIG5zLXBsYWluLXNhZmUtb3V0IDo6PSBucy1jaGFyXG4vLyBbMTI5XSAgbnMtcGxhaW4tc2FmZS1pbiA6Oj0gbnMtY2hhciAtIGMtZmxvdy1pbmRpY2F0b3Jcbi8vIFsxMzBdICBucy1wbGFpbi1jaGFyKGMpIDo6PSAgKCBucy1wbGFpbi1zYWZlKGMpIC0gXHUyMDFDOlx1MjAxRCAtIFx1MjAxQyNcdTIwMUQgKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIFx1MjAxQyNcdTIwMUQgKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIFx1MjAxQzpcdTIwMUQgLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSAqLyApXG5mdW5jdGlvbiBpc1BsYWluU2FmZShjLCBwcmV2LCBpbmJsb2NrKSB7XG4gIHZhciBjSXNOc0NoYXJPcldoaXRlc3BhY2UgPSBpc05zQ2hhck9yV2hpdGVzcGFjZShjKTtcbiAgdmFyIGNJc05zQ2hhciA9IGNJc05zQ2hhck9yV2hpdGVzcGFjZSAmJiAhaXNXaGl0ZXNwYWNlKGMpO1xuICByZXR1cm4gKFxuICAgIC8vIG5zLXBsYWluLXNhZmVcbiAgICBpbmJsb2NrID8gLy8gYyA9IGZsb3ctaW5cbiAgICAgIGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgOiBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gIClcbiAgICAvLyBucy1wbGFpbi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAvLyBmYWxzZSBvbiAnIydcbiAgICAmJiAhKHByZXYgPT09IENIQVJfQ09MT04gJiYgIWNJc05zQ2hhcikgLy8gZmFsc2Ugb24gJzogJ1xuICAgIHx8IChpc05zQ2hhck9yV2hpdGVzcGFjZShwcmV2KSAmJiAhaXNXaGl0ZXNwYWNlKHByZXYpICYmIGMgPT09IENIQVJfU0hBUlApIC8vIGNoYW5nZSB0byB0cnVlIG9uICdbXiBdIydcbiAgICB8fCAocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiBjSXNOc0NoYXIpOyAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnOlteIF0nXG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlRmlyc3QoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5zLWNoYXIgLSBjLWluZGljYXRvclxuICAvLyB3aGVyZSBucy1jaGFyID0gbmItY2hhciAtIHMtd2hpdGUuXG4gIC8vIE5vIHN1cHBvcnQgb2YgKCAoIFx1MjAxQz9cdTIwMUQgfCBcdTIwMUM6XHUyMDFEIHwgXHUyMDFDLVx1MjAxRCApIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykpICovICkgcGFydFxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAgIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAgIC8vIFx1MjAxQy1cdTIwMUQgfCBcdTIwMUM/XHUyMDFEIHwgXHUyMDFDOlx1MjAxRCB8IFx1MjAxQyxcdTIwMUQgfCBcdTIwMUNbXHUyMDFEIHwgXHUyMDFDXVx1MjAxRCB8IFx1MjAxQ3tcdTIwMUQgfCBcdTIwMUN9XHUyMDFEXG4gICAgJiYgYyAhPT0gQ0hBUl9NSU5VU1xuICAgICYmIGMgIT09IENIQVJfUVVFU1RJT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIHwgXHUyMDFDI1x1MjAxRCB8IFx1MjAxQyZcdTIwMUQgfCBcdTIwMUMqXHUyMDFEIHwgXHUyMDFDIVx1MjAxRCB8IFx1MjAxQ3xcdTIwMUQgfCBcdTIwMUM9XHUyMDFEIHwgXHUyMDFDPlx1MjAxRCB8IFx1MjAxQydcdTIwMUQgfCBcdTIwMUNcIlx1MjAxRFxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9FUVVBTFNcbiAgICAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTlxuICAgICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFXG4gICAgJiYgYyAhPT0gQ0hBUl9ET1VCTEVfUVVPVEVcbiAgICAvLyB8IFx1MjAxQyVcdTIwMUQgfCBcdTIwMUNAXHUyMDFEIHwgXHUyMDFDYFx1MjAxRClcbiAgICAmJiBjICE9PSBDSEFSX1BFUkNFTlRcbiAgICAmJiBjICE9PSBDSEFSX0NPTU1FUkNJQUxfQVRcbiAgICAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUxhc3QoYykge1xuICAvLyBqdXN0IG5vdCB3aGl0ZXNwYWNlIG9yIGNvbG9uLCBpdCB3aWxsIGJlIGNoZWNrZWQgdG8gYmUgcGxhaW4gY2hhcmFjdGVyIGxhdGVyXG4gIHJldHVybiAhaXNXaGl0ZXNwYWNlKGMpICYmIGMgIT09IENIQVJfQ09MT047XG59XG5cbi8vIFNhbWUgYXMgJ3N0cmluZycuY29kZVBvaW50QXQocG9zKSwgYnV0IHdvcmtzIGluIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyaW5nLCBwb3MpIHtcbiAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zKSwgc2Vjb25kO1xuICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBwb3MgKyAxIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgcmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLFxuICB0ZXN0QW1iaWd1b3VzVHlwZSwgcXVvdGluZ1R5cGUsIGZvcmNlUXVvdGVzLCBpbmJsb2NrKSB7XG5cbiAgdmFyIGk7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIHByZXZDaGFyID0gbnVsbDtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KGNvZGVQb2ludEF0KHN0cmluZywgMCkpXG4gICAgICAgICAgJiYgaXNQbGFpblNhZmVMYXN0KGNvZGVQb2ludEF0KHN0cmluZywgc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkgfHwgZm9yY2VRdW90ZXMpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHxcbiAgICAgICAgICAgIC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICBpZiAocGxhaW4gJiYgIWZvcmNlUXVvdGVzICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gU1RZTEVfUExBSU47XG4gICAgfVxuICAgIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbiAgfVxuICAvLyBFZGdlIGNhc2U6IGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBjYW4gb25seSBoYXZlIG9uZSBkaWdpdC5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICBpZiAoIWZvcmNlUXVvdGVzKSB7XG4gICAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG4gIH1cbiAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xufVxuXG4vLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIFx1MjAyMiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAgXHUyMDIyIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKSB7XG4gIHN0YXRlLmR1bXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAnXCJcIicgOiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlKSB7XG4gICAgICBpZiAoREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSB8fCBERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVgudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICgnXCInICsgc3RyaW5nICsgJ1wiJykgOiAoXCInXCIgKyBzdHJpbmcgKyBcIidcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIFx1MjI2NCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsXG4gICAgICB0ZXN0QW1iaWd1aXR5LCBzdGF0ZS5xdW90aW5nVHlwZSwgc3RhdGUuZm9yY2VRdW90ZXMgJiYgIWlza2V5LCBpbmJsb2NrKSkge1xuXG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpID8gU3RyaW5nKGluZGVudFBlckxldmVsKSA6ICcnO1xuXG4gIC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cbiAgdmFyIGNsaXAgPSAgICAgICAgICBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJztcbiAgdmFyIGtlZXAgPSBjbGlwICYmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDJdID09PSAnXFxuJyB8fCBzdHJpbmcgPT09ICdcXG4nKTtcbiAgdmFyIGNob21wID0ga2VlcCA/ICcrJyA6IChjbGlwID8gJycgOiAnLScpO1xuXG4gIHJldHVybiBpbmRlbnRJbmRpY2F0b3IgKyBjaG9tcCArICdcXG4nO1xufVxuXG4vLyAoU2VlIHRoZSBub3RlIGZvciB3cml0ZVNjYWxhci4pXG5mdW5jdGlvbiBkcm9wRW5kaW5nTmV3bGluZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cblxuLy8gTm90ZTogYSBsb25nIGxpbmUgd2l0aG91dCBhIHN1aXRhYmxlIGJyZWFrIHBvaW50IHdpbGwgZXhjZWVkIHRoZSB3aWR0aCBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBldmVyeSBjaGFyIGluIHN0ciBpc1ByaW50YWJsZSwgc3RyLmxlbmd0aCA+IDAsIHdpZHRoID4gMC5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXNcdTIwMTRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7XG5cbiAgLy8gZmlyc3QgbGluZSAocG9zc2libHkgYW4gZW1wdHkgbGluZSlcbiAgdmFyIHJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRMRiA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICBuZXh0TEYgPSBuZXh0TEYgIT09IC0xID8gbmV4dExGIDogc3RyaW5nLmxlbmd0aDtcbiAgICBsaW5lUmUubGFzdEluZGV4ID0gbmV4dExGO1xuICAgIHJldHVybiBmb2xkTGluZShzdHJpbmcuc2xpY2UoMCwgbmV4dExGKSwgd2lkdGgpO1xuICB9KCkpO1xuICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSB5ZXQsIGRvbid0IGFkZCBhbiBleHRyYSBcXG4uXG4gIHZhciBwcmV2TW9yZUluZGVudGVkID0gc3RyaW5nWzBdID09PSAnXFxuJyB8fCBzdHJpbmdbMF0gPT09ICcgJztcbiAgdmFyIG1vcmVJbmRlbnRlZDtcblxuICAvLyByZXN0IG9mIHRoZSBsaW5lc1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSkge1xuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXSwgbGluZSA9IG1hdGNoWzJdO1xuICAgIG1vcmVJbmRlbnRlZCA9IChsaW5lWzBdID09PSAnICcpO1xuICAgIHJlc3VsdCArPSBwcmVmaXhcbiAgICAgICsgKCFwcmV2TW9yZUluZGVudGVkICYmICFtb3JlSW5kZW50ZWQgJiYgbGluZSAhPT0gJydcbiAgICAgICAgPyAnXFxuJyA6ICcnKVxuICAgICAgKyBmb2xkTGluZShsaW5lLCB3aWR0aCk7XG4gICAgcHJldk1vcmVJbmRlbnRlZCA9IG1vcmVJbmRlbnRlZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdyZWVkeSBsaW5lIGJyZWFraW5nLlxuLy8gUGlja3MgdGhlIGxvbmdlc3QgbGluZSB1bmRlciB0aGUgbGltaXQgZWFjaCB0aW1lLFxuLy8gb3RoZXJ3aXNlIHNldHRsZXMgZm9yIHRoZSBzaG9ydGVzdCBsaW5lIG92ZXIgdGhlIGxpbWl0LlxuLy8gTkIuIE1vcmUtaW5kZW50ZWQgbGluZXMgKmNhbm5vdCogYmUgZm9sZGVkLCBhcyB0aGF0IHdvdWxkIGFkZCBhbiBleHRyYSBcXG4uXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCB3aWR0aCkge1xuICBpZiAobGluZSA9PT0gJycgfHwgbGluZVswXSA9PT0gJyAnKSByZXR1cm4gbGluZTtcblxuICAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cbiAgdmFyIGJyZWFrUmUgPSAvIFteIF0vZzsgLy8gbm90ZTogdGhlIG1hdGNoIGluZGV4IHdpbGwgYWx3YXlzIGJlIDw9IGxlbmd0aC0yLlxuICB2YXIgbWF0Y2g7XG4gIC8vIHN0YXJ0IGlzIGFuIGluY2x1c2l2ZSBpbmRleC4gZW5kLCBjdXJyLCBhbmQgbmV4dCBhcmUgZXhjbHVzaXZlLlxuICB2YXIgc3RhcnQgPSAwLCBlbmQsIGN1cnIgPSAwLCBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIC8vIEludmFyaWFudHM6IDAgPD0gc3RhcnQgPD0gbGVuZ3RoLTEuXG4gIC8vICAgMCA8PSBjdXJyIDw9IG5leHQgPD0gbWF4KDAsIGxlbmd0aC0yKS4gY3VyciAtIHN0YXJ0IDw9IHdpZHRoLlxuICAvLyBJbnNpZGUgdGhlIGxvb3A6XG4gIC8vICAgQSBtYXRjaCBpbXBsaWVzIGxlbmd0aCA+PSAyLCBzbyBjdXJyIGFuZCBuZXh0IGFyZSA8PSBsZW5ndGgtMi5cbiAgd2hpbGUgKChtYXRjaCA9IGJyZWFrUmUuZXhlYyhsaW5lKSkpIHtcbiAgICBuZXh0ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gbWFpbnRhaW4gaW52YXJpYW50OiBjdXJyIC0gc3RhcnQgPD0gd2lkdGhcbiAgICBpZiAobmV4dCAtIHN0YXJ0ID4gd2lkdGgpIHtcbiAgICAgIGVuZCA9IChjdXJyID4gc3RhcnQpID8gY3VyciA6IG5leHQ7IC8vIGRlcml2ZSBlbmQgPD0gbGVuZ3RoLTJcbiAgICAgIHJlc3VsdCArPSAnXFxuJyArIGxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG4gICAgICBzdGFydCA9IGVuZCArIDE7ICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgc3RhcnQgPD0gbGVuZ3RoLTFcbiAgICB9XG4gICAgY3VyciA9IG5leHQ7XG4gIH1cblxuICAvLyBCeSB0aGUgaW52YXJpYW50cywgc3RhcnQgPD0gbGVuZ3RoLTEsIHNvIHRoZXJlIGlzIHNvbWV0aGluZyBsZWZ0IG92ZXIuXG4gIC8vIEl0IGlzIGVpdGhlciB0aGUgd2hvbGUgc3RyaW5nIG9yIGEgcGFydCBzdGFydGluZyBmcm9tIG5vbi13aGl0ZXNwYWNlLlxuICByZXN1bHQgKz0gJ1xcbic7XG4gIC8vIEluc2VydCBhIGJyZWFrIGlmIHRoZSByZW1haW5kZXIgaXMgdG9vIGxvbmcgYW5kIHRoZXJlIGlzIGEgYnJlYWsgYXZhaWxhYmxlLlxuICBpZiAobGluZS5sZW5ndGggLSBzdGFydCA+IHdpZHRoICYmIGN1cnIgPiBzdGFydCkge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0LCBjdXJyKSArICdcXG4nICsgbGluZS5zbGljZShjdXJyICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTsgLy8gZHJvcCBleHRyYSBcXG4gam9pbmVyXG59XG5cbi8vIEVzY2FwZXMgYSBkb3VibGUtcXVvdGVkIHN0cmluZy5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBlc2NhcGVTZXE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuXG4gICAgaWYgKCFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV07XG4gICAgICBpZiAoY2hhciA+PSAweDEwMDAwKSByZXN1bHQgKz0gc3RyaW5nW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGVzY2FwZVNlcSB8fCBlbmNvZGVIZXgoY2hhcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgdmFsdWUsIGZhbHNlLCBmYWxzZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG51bGwsIGZhbHNlLCBmYWxzZSkpKSB7XG5cbiAgICAgIGlmIChfcmVzdWx0ICE9PSAnJykgX3Jlc3VsdCArPSAnLCcgKyAoIXN0YXRlLmNvbmRlbnNlRmxvdyA/ICcgJyA6ICcnKTtcbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ1snICsgX3Jlc3VsdCArICddJztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgbnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpKSkge1xuXG4gICAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgICAgX3Jlc3VsdCArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0ICs9ICctICc7XG4gICAgICB9XG5cbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAnW10nOyAvLyBFbXB0eSBzZXF1ZW5jZSBpZiBubyB2YWxpZCB2YWx1ZXMuXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgIHBhaXJCdWZmZXIgPSAnJztcbiAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBpZiAoZXhwbGljaXQpIHtcbiAgICAgICAgaWYgKHR5cGUubXVsdGkgJiYgdHlwZS5yZXByZXNlbnROYW1lKSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS5yZXByZXNlbnROYW1lKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXksIGlzYmxvY2tzZXEpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG4gIHZhciBpbmJsb2NrID0gYmxvY2s7XG4gIHZhciB0YWdTdHI7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ub0FycmF5SW5kZW50ICYmICFpc2Jsb2Nrc2VxICYmIGxldmVsID4gMCkge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwgLSAxLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVuZGVmaW5lZF0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIC8vIE5lZWQgdG8gZW5jb2RlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCB0aG9zZSBhbGxvd2VkIGJ5IHRoZSBzcGVjOlxuICAgICAgLy9cbiAgICAgIC8vIFszNV0gbnMtZGVjLWRpZ2l0ICAgIDo6PSAgWyN4MzAtI3gzOV0gLyogMC05ICovXG4gICAgICAvLyBbMzZdIG5zLWhleC1kaWdpdCAgICA6Oj0gIG5zLWRlYy1kaWdpdFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCBbI3g0MS0jeDQ2XSAvKiBBLUYgKi8gfCBbI3g2MS0jeDY2XSAvKiBhLWYgKi9cbiAgICAgIC8vIFszN10gbnMtYXNjaWktbGV0dGVyIDo6PSAgWyN4NDEtI3g1QV0gLyogQS1aICovIHwgWyN4NjEtI3g3QV0gLyogYS16ICovXG4gICAgICAvLyBbMzhdIG5zLXdvcmQtY2hhciAgICA6Oj0gIG5zLWRlYy1kaWdpdCB8IG5zLWFzY2lpLWxldHRlciB8IFx1MjAxQy1cdTIwMURcbiAgICAgIC8vIFszOV0gbnMtdXJpLWNoYXIgICAgIDo6PSAgXHUyMDFDJVx1MjAxRCBucy1oZXgtZGlnaXQgbnMtaGV4LWRpZ2l0IHwgbnMtd29yZC1jaGFyIHwgXHUyMDFDI1x1MjAxRFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCBcdTIwMUM7XHUyMDFEIHwgXHUyMDFDL1x1MjAxRCB8IFx1MjAxQz9cdTIwMUQgfCBcdTIwMUM6XHUyMDFEIHwgXHUyMDFDQFx1MjAxRCB8IFx1MjAxQyZcdTIwMUQgfCBcdTIwMUM9XHUyMDFEIHwgXHUyMDFDK1x1MjAxRCB8IFx1MjAxQyRcdTIwMUQgfCBcdTIwMUMsXHUyMDFEXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IFx1MjAxQ19cdTIwMUQgfCBcdTIwMUMuXHUyMDFEIHwgXHUyMDFDIVx1MjAxRCB8IFx1MjAxQ35cdTIwMUQgfCBcdTIwMUMqXHUyMDFEIHwgXHUyMDFDJ1x1MjAxRCB8IFx1MjAxQyhcdTIwMUQgfCBcdTIwMUMpXHUyMDFEIHwgXHUyMDFDW1x1MjAxRCB8IFx1MjAxQ11cdTIwMURcbiAgICAgIC8vXG4gICAgICAvLyBBbHNvIG5lZWQgdG8gZW5jb2RlICchJyBiZWNhdXNlIGl0IGhhcyBzcGVjaWFsIG1lYW5pbmcgKGVuZCBvZiB0YWcgcHJlZml4KS5cbiAgICAgIC8vXG4gICAgICB0YWdTdHIgPSBlbmNvZGVVUkkoXG4gICAgICAgIHN0YXRlLnRhZ1swXSA9PT0gJyEnID8gc3RhdGUudGFnLnNsaWNlKDEpIDogc3RhdGUudGFnXG4gICAgICApLnJlcGxhY2UoLyEvZywgJyUyMScpO1xuXG4gICAgICBpZiAoc3RhdGUudGFnWzBdID09PSAnIScpIHtcbiAgICAgICAgdGFnU3RyID0gJyEnICsgdGFnU3RyO1xuICAgICAgfSBlbHNlIGlmICh0YWdTdHIuc2xpY2UoMCwgMTgpID09PSAndGFnOnlhbWwub3JnLDIwMDI6Jykge1xuICAgICAgICB0YWdTdHIgPSAnISEnICsgdGFnU3RyLnNsaWNlKDE4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ1N0ciA9ICchPCcgKyB0YWdTdHIgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmR1bXAgPSB0YWdTdHIgKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIHZhciB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgdmFsdWUsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGR1bXBfMSA9IGR1bXAkMTtcblxudmFyIGR1bXBlciA9IHtcblx0ZHVtcDogZHVtcF8xXG59O1xuXG5mdW5jdGlvbiByZW5hbWVkKGZyb20sIHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiB5YW1sLicgKyBmcm9tICsgJyBpcyByZW1vdmVkIGluIGpzLXlhbWwgNC4gJyArXG4gICAgICAnVXNlIHlhbWwuJyArIHRvICsgJyBpbnN0ZWFkLCB3aGljaCBpcyBub3cgc2FmZSBieSBkZWZhdWx0LicpO1xuICB9O1xufVxuXG5cbnZhciBUeXBlICAgICAgICAgICAgICAgID0gdHlwZTtcbnZhciBTY2hlbWEgICAgICAgICAgICAgID0gc2NoZW1hO1xudmFyIEZBSUxTQUZFX1NDSEVNQSAgICAgPSBmYWlsc2FmZTtcbnZhciBKU09OX1NDSEVNQSAgICAgICAgID0ganNvbjtcbnZhciBDT1JFX1NDSEVNQSAgICAgICAgID0gY29yZTtcbnZhciBERUZBVUxUX1NDSEVNQSAgICAgID0gX2RlZmF1bHQ7XG52YXIgbG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xudmFyIGxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbnZhciBkdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IGV4Y2VwdGlvbjtcblxuLy8gUmUtZXhwb3J0IGFsbCB0eXBlcyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGN1c3RvbSBzY2hlbWFcbnZhciB0eXBlcyA9IHtcbiAgYmluYXJ5OiAgICBiaW5hcnksXG4gIGZsb2F0OiAgICAgZmxvYXQsXG4gIG1hcDogICAgICAgbWFwLFxuICBudWxsOiAgICAgIF9udWxsLFxuICBwYWlyczogICAgIHBhaXJzLFxuICBzZXQ6ICAgICAgIHNldCxcbiAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gIGJvb2w6ICAgICAgYm9vbCxcbiAgaW50OiAgICAgICBpbnQsXG4gIG1lcmdlOiAgICAgbWVyZ2UsXG4gIG9tYXA6ICAgICAgb21hcCxcbiAgc2VxOiAgICAgICBzZXEsXG4gIHN0cjogICAgICAgc3RyXG59O1xuXG4vLyBSZW1vdmVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMy4wLnhcbnZhciBzYWZlTG9hZCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUxvYWQnLCAnbG9hZCcpO1xudmFyIHNhZmVMb2FkQWxsICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZEFsbCcsICdsb2FkQWxsJyk7XG52YXIgc2FmZUR1bXAgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVEdW1wJywgJ2R1bXAnKTtcblxudmFyIGpzWWFtbCA9IHtcblx0VHlwZTogVHlwZSxcblx0U2NoZW1hOiBTY2hlbWEsXG5cdEZBSUxTQUZFX1NDSEVNQTogRkFJTFNBRkVfU0NIRU1BLFxuXHRKU09OX1NDSEVNQTogSlNPTl9TQ0hFTUEsXG5cdENPUkVfU0NIRU1BOiBDT1JFX1NDSEVNQSxcblx0REVGQVVMVF9TQ0hFTUE6IERFRkFVTFRfU0NIRU1BLFxuXHRsb2FkOiBsb2FkLFxuXHRsb2FkQWxsOiBsb2FkQWxsLFxuXHRkdW1wOiBkdW1wLFxuXHRZQU1MRXhjZXB0aW9uOiBZQU1MRXhjZXB0aW9uLFxuXHR0eXBlczogdHlwZXMsXG5cdHNhZmVMb2FkOiBzYWZlTG9hZCxcblx0c2FmZUxvYWRBbGw6IHNhZmVMb2FkQWxsLFxuXHRzYWZlRHVtcDogc2FmZUR1bXBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGpzWWFtbDtcbmV4cG9ydCB7IENPUkVfU0NIRU1BLCBERUZBVUxUX1NDSEVNQSwgRkFJTFNBRkVfU0NIRU1BLCBKU09OX1NDSEVNQSwgU2NoZW1hLCBUeXBlLCBZQU1MRXhjZXB0aW9uLCBkdW1wLCBsb2FkLCBsb2FkQWxsLCBzYWZlRHVtcCwgc2FmZUxvYWQsIHNhZmVMb2FkQWxsLCB0eXBlcyB9O1xuIiwgImltcG9ydCB7RXhjYWxpZHJhd0VsZW1lbnQsIEV4Y2FsaWRyYXdGaWxlLCBFWEVSQ0lTRV9CT1h9IGZyb20gXCIuLi8uLi9FeGNhbGlkcmF3XCI7XHJcbmltcG9ydCB7RXhlcmNpc2VMaW5rVGV4dH0gZnJvbSBcIi4uLy4uL0V4ZXJjaXNlXCI7XHJcbmltcG9ydCAqIGFzIHlhbWwgZnJvbSAnanMteWFtbCc7XHJcbmltcG9ydCB7RGF5RnJvbnRtYXR0ZXIsIERheU1ldGFkYXRhfSBmcm9tIFwiLi4vLi4vU3RhdEZpbGVcIjtcclxuaW1wb3J0IHtWYXVsdH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVhZEZyb20ocGF0aDpzdHJpbmcpOnN0cmluZyA9IFZhdWx0LlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSlNPTihjb250ZW50OnN0cmluZyk6IGFueSB7XHJcblx0Y29uc3QganNvblBhdHRlcm4gPSAvYGBganNvblxcbihbXFxzXFxTXSo/KVxcbmBgYC9nO1xyXG5cdGNvbnN0IG1hdGNoID0ganNvblBhdHRlcm4uZXhlYyhjb250ZW50KTtcclxuXHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gPyBKU09OLnBhcnNlKG1hdGNoWzFdKSA6IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFeGVyY2lzZUxpbmtUZXh0KGV4Y2FsaWRyYXc6IEV4Y2FsaWRyYXdGaWxlKTogRXhlcmNpc2VMaW5rVGV4dFtdIHtcclxuXHRsZXQgZWxlbWVudHM6IEV4Y2FsaWRyYXdFbGVtZW50W10gPSBleGNhbGlkcmF3LmVsZW1lbnRzO1xyXG5cdHJldHVybiBlbGVtZW50c1xyXG5cdFx0LmZpbHRlcihlbCA9PiBlbC5zdHJva2VDb2xvciA9PT0gRVhFUkNJU0VfQk9YLnN0cm9rZUNvbG9yXHJcblx0XHRcdCYmIGVsLnR5cGUgPT09IEVYRVJDSVNFX0JPWC50eXBlICYmICFlbC5pc0RlbGV0ZWQpXHJcblx0XHQubWFwKGVsID0+IGAke2V4Y2FsaWRyYXcubmFtZX0jXiR7ZWwuaWR9YClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvWWFtbChvYmo6IE9iamVjdCwgZXhjbHVkZWRfa2V5ID0gXCJfXCIpOiBzdHJpbmcge1xyXG5cdC8vIENyZWF0aW5nIGEgbmV3IG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhlIHByb3BlcnRpZXMgdGhhdCBkb24ndCBzdGFydCB3aXRoIFwiX1wiXHJcblx0Y29uc3Qgc2FuaXRpemVkT2JqZWN0ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxyXG5cdFx0T2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtrZXldKSA9PiAha2V5LmVuZHNXaXRoKGV4Y2x1ZGVkX2tleSkpXHJcblx0KTtcclxuXHJcblx0Ly8gQ29udmVydGluZyB0aGUgc2FuaXRpemVkIG9iamVjdCB0byBhIFlBTUwgc3RyaW5nIHVzaW5nIGpzLXlhbWxcclxuXHRyZXR1cm4gYC0tLVxcbiR7eWFtbC5kdW1wKHNhbml0aXplZE9iamVjdCl9LS0tYDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbnRtYXR0ZXIoY29udGVudDogc3RyaW5nKTogRGF5RnJvbnRtYXR0ZXIgfCB1bmRlZmluZWQge1xyXG5cdGNvbnN0IHBhdHRlcm4gPSAvLS0tXFxzKihbXFxzXFxTXSo/KVxccyotLS0vO1xyXG5cdGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMoY29udGVudCk7XHJcblx0aWYgKG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0cmV0dXJuIHlhbWwubG9hZChtYXRjaGVzWzFdKSBhcyBEYXlNZXRhZGF0YTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBZQU1MOicsIGUpO1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbiIsICJpbXBvcnQge0VYRVJDSVNFX1NUQVRVU0VTfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBFeGVyY2lzZU1ldGFkYXRhX1YwIHtcblx0bGFzdFJlbWFyazogc3RyaW5nO1xuXHRsaW5rOnN0cmluZztcblx0dHlwZTpzdHJpbmc7XG5cdGxpZmVsaW5lOmFueVtdO1xuXHRpZDpzdHJpbmc7XG5cdGxhc3RTdGF0dXM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeGVyY2lzZU1ldGFkYXRhX1YxIHtcblx0c291cmNlOiBzdHJpbmc7IC8vIExpbmsgaXMgaW4gdGhlIGZvcm1hdCBvZiBPYnNpZGlhbiBMaW5rVGV4dFxuXG5cdGlkOnN0cmluZztcblxuXHRpbmRleDogbnVtYmVyO1xuXG5cdHN1YmplY3Q6IHN0cmluZztcblxuXHRzdGF0ZTogRVhFUkNJU0VfU1RBVFVTRVMgLy8gVGhlIHN0YXRlIHJlZmVycyB0byB0aGUgbGF0ZXN0IHN0YXRlIG9mIHRoZSBleGVyY2lzZSAoc3RhdGUgb2YgdGhlIGxhc3QgRXhlcmNpc2VIaXN0b3J5KVxuXG5cdHN0YXJ0X3RpbWU6IG51bWJlcjtcblxuXHRlbmRfdGltZTogbnVtYmVyO1xuXG5cdHJlbWFyazogc3RyaW5nO1xuXG5cdGhpc3Rvcnk6IEV4ZXJjaXNlSGlzdG9yeVtdO1xuXG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBFeGVyY2lzZU1ldGFkYXRhX1YyIHtcblx0Ly9UT0RPIFx1OTcwMFx1ODk4MVx1N0VEOVx1NkJDRlx1NEUyQUV4ZXJjaXNlXHU1ODlFXHU1MkEwXHU0RTAwXHU0RTJBa2V5d29yZFx1NzY4NFByb3BlcnR5LFx1NUUyRVx1NTJBOVx1NjZGNFx1NTk3RFx1NzY4NFx1NTIwNlx1N0M3Qlx1OEZEOVx1NEUyQVx1OTg5OFx1NzZFRVxuXHQvLyBrZXl3b3Jkczogc3RyaW5nW11cblxuXHQvL1RPRE8gXHU5NzAwXHU4OTgxXHU1ODlFXHU1MkEwXHU0RTAwXHU0RTJBXHU4QkIwXHU1RjU1XHU2QkNGXHU0RTJBXHU5ODk4XHU3NkVFXHU2QkNGXHU2QjIxXHU2MjQwXHU4MkIxXHU4RDM5XHU3Njg0XHU1RTczXHU1NzQ3XHU2NUY2XHU5NUY0XHU3Njg0UHJvcGVydHlcblx0Ly8gdGltZUNvc3k6IG51bWJlcltdXG5cblx0c291cmNlOiBzdHJpbmc7IC8vIExpbmsgaXMgaW4gdGhlIGZvcm1hdCBvZiBPYnNpZGlhbiBMaW5rVGV4dFxuXG5cdGlkOnN0cmluZztcblxuXHRpbmRleDogbnVtYmVyO1xuXG5cdHN1YmplY3Q6IHN0cmluZztcblxuXHRzdGF0ZTogRVhFUkNJU0VfU1RBVFVTRVMgLy8gVGhlIHN0YXRlIHJlZmVycyB0byB0aGUgbGF0ZXN0IHN0YXRlIG9mIHRoZSBleGVyY2lzZSAoc3RhdGUgb2YgdGhlIGxhc3QgRXhlcmNpc2VIaXN0b3J5KVxuXG5cdHN0YXJ0X3RpbWU6IG51bWJlcjtcblxuXHRlbmRfdGltZTogbnVtYmVyO1xuXG5cdHJlbWFyazogc3RyaW5nO1xuXG5cdGhpc3Rvcnk6IEV4ZXJjaXNlSGlzdG9yeVtdO1xuXG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeGVyY2lzZUhpc3Rvcnkge1xuXHRzdGFydFRpbWVTdGFtcDogbnVtYmVyO1xuXHRlbmRUaW1lU3RhbXA6IG51bWJlcjtcblx0cmVtYXJrPzogc3RyaW5nO1xuXHRzdGF0dXM6IHN0cmluZztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWlncmF0ZV9tYXBwaW5nKG9qOiBFeGVyY2lzZU1ldGFkYXRhX1YwLCBpbmRleDogbnVtYmVyKTogRXhlcmNpc2VNZXRhZGF0YV9WMXtcblx0cmV0dXJuIHtcblx0XHRzb3VyY2U6IG9qW1wibGlua1wiXSxcblx0XHRzdWJqZWN0OiBvaltcInR5cGVcIl0sXG5cdFx0c3RhdGU6IG9qW1wibGFzdFN0YXR1c1wiXSBhcyBFWEVSQ0lTRV9TVEFUVVNFUyxcblx0XHRyZW1hcms6b2pbXCJsYXN0UmVtYXJrXCJdLFxuXHRcdGluZGV4OiBpbmRleCxcblx0XHRoaXN0b3J5OiBvaltcImxpZmVsaW5lXCJdLFxuXHRcdGlkOiBvaltcImlkXCJdLFxuXHRcdHN0YXJ0X3RpbWU6IDAsXG5cdFx0ZW5kX3RpbWU6MFxuXHR9XG59XG4iLCAiXHJcblxyXG5leHBvcnQgZW51bSBFWEVSQ0lTRV9TVUJKRUNUIHtcclxuXHRNQVRIID0gXCJNYXRoXCIsXHJcblx0RFNQID0gXCJEU1BcIixcclxuXHRQT0xJVElDUyA9IFwiUG9saXRpY3NcIlxyXG59XHJcblxyXG5leHBvcnQgZW51bSBRVUVSWV9TVFJBVEVHWSB7XHJcblx0XCJORVdfRVhFUkNJU0VfRklSU1RcIlxyXG59XHJcblxyXG5leHBvcnQgZW51bSBFWEVSQ0lTRV9TVEFUVVNFUyB7XHJcblx0TmV3ID0gXCJuZXdcIixcclxuXHRJbnNwaXJpbmcgPSBcImluc3BpcmluZ1wiLFxyXG5cdExhc2VyID0gXCJsYXNlclwiLFxyXG5cdFN0dW1ibGUgPSBcInN0dW1ibGVcIixcclxuXHREcmlmdGVyID0gXCJkcmlmdGVyXCJcclxufVxyXG5cclxuZXhwb3J0IGVudW0gRVhFUkNJU0VfU1RBVFVTRVNfU1dBUFBFRCB7XHJcblx0bmV3ID0gXCJOZXdcIixcclxuXHRpbnNwaXJpbmcgPSBcIkluc3BpcmluZ1wiLFxyXG5cdGxhc2VyID0gXCJMYXNlclwiLFxyXG5cdHN0dW1ibGUgPSBcIlN0dW1ibGVcIixcclxuXHRkcmlmdGVyID0gXCJEcmlmdGVyXCJcclxufVxyXG4iLCAiaW1wb3J0IHtBcHAsIHN0cmluZ2lmeVlhbWwsIFRGaWxlLCBtb21lbnQsIE5vdGljZSwgbm9ybWFsaXplUGF0aCwgcGFyc2VZYW1sLCBhZGRJY29ufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtcclxuXHRFWEVSQ0lTRV9CQVNFLCBFeGVyY2lzZUJhc2UsXHJcbn0gZnJvbSBcIi4vRXhlcmNpc2VCYXNlXCI7XHJcbmltcG9ydCB7RGF0YXZpZXdBcGl9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlldy9saWIvYXBpL3BsdWdpbi1hcGlcIjtcclxuaW1wb3J0IHtEYXRhQXJyYXksIGdldEFQSSwgTGl0ZXJhbCwgcGFyc2VGaWVsZH0gZnJvbSBcIm9ic2lkaWFuLWRhdGF2aWV3XCI7XHJcbmltcG9ydCB7RXhlcmNpc2UsIEV4ZXJjaXNlTGlua1RleHR9IGZyb20gXCIuL0V4ZXJjaXNlXCI7XHJcbmltcG9ydCB7RXhjYWxpZHJhd0VsZW1lbnQsIEV4Y2FsaWRyYXdGaWxlLCBFeGNhbGlkcmF3SlNPTn0gZnJvbSBcIi4vRXhjYWxpZHJhd1wiO1xyXG5pbXBvcnQge2dldEV4ZXJjaXNlTGlua1RleHQsIHBhcnNlRnJvbnRtYXR0ZXIsIHBhcnNlSlNPTn0gZnJvbSBcIi4vc3JjL3V0aWxpdHkvcGFyc2VyXCI7XHJcbmltcG9ydCB7c3RyaW5naWZ5VE9KU09OfSBmcm9tIFwiLi9zcmMvdXRpbGl0eS9pb1wiO1xyXG5pbXBvcnQge0RheUZyb250bWF0dGVyLCBTdGF0RmlsZX0gZnJvbSBcIi4vU3RhdEZpbGVcIjtcclxuaW1wb3J0IHtTQmFzZU1ldGFkYXRhfSBmcm9tIFwiLi9zcmMvYmFzZV92ZXJzaW9uXCI7XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGdldERhaWx5RGZOYW1lVGVtcGxhdGUgPSAoKTpzdHJpbmcgPT4ge1xyXG5cdGNvbnN0IGRhdGVfc3RyaW5nID0gbW9tZW50KCkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XHJcblx0cmV0dXJuIGBcdUQ4M0RcdURERDNcdUZFMEZEYWlseSBub3Rlcy9ERiR7ZGF0ZV9zdHJpbmd9Lm1kYFxyXG59XHJcblxyXG5jb25zdCBBVkVSQUdFX1RJTUVfS0VZID0gJ19hdmVyYWdlVGltZSc7XHJcbmNvbnN0IEVYRVJDSVNFU19LRVkgPSAnX2V4ZXJjaXNlcyc7XHJcbmNvbnN0IFRPVEFMX1RJTUVfS0VZID0gJ190b3RhbF90aW1lJztcclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgRGF0YVByb2Nlc3NvcntcclxuXHRhcHBfOiBBcHA7XHJcblx0Ly8gVGhlIHN0YXRmaWxlIHNob3VsZCBiZSB0aGUgcnVudGltZSBPYmplY3Qgb2YgdGhlIGFjdHVhbCBPYnNpZGlhbiBub3RlIHRoYXQgc3RvcmUgdGhlIGRhdGEuXHJcblx0c3RhdGZpbGU6IFN0YXRGaWxlO1xyXG5cclxuXHRiYXNlczoge1tLOiBzdHJpbmddOiBFeGVyY2lzZUJhc2V9ID0ge307XHJcblxyXG5cdGFjdGl2ZUJhc2U6IEV4ZXJjaXNlQmFzZSB8IHVuZGVmaW5lZDtcclxuXHJcblx0YWN0aXZlRXhlcmNpc2U6IEV4ZXJjaXNlIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRwcml2YXRlIGNvbnN0cnVjdG9yKGFwcDpBcHAsIGJhc2VzOiB7W0s6IHN0cmluZ106IEV4ZXJjaXNlQmFzZX0sIHN0YXRGaWxlOiBTdGF0RmlsZSkge1xyXG5cdFx0dGhpcy5hcHBfID0gYXBwO1xyXG5cdFx0dGhpcy5iYXNlcyA9IGJhc2VzO1xyXG5cdFx0dGhpcy5zdGF0ZmlsZSA9IHN0YXRGaWxlXHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGFzeW5jIGluaXQoYXBwOkFwcCl7XHJcblx0XHQvL1xyXG5cdFx0Y29uc3QgZHZBUEkgPSBnZXRBUEkoKTtcclxuXHJcblx0XHQvLyBjb25zdCBzdGF0RmlsZTogU3RhdEZpbGUgPSBhd2FpdCBTdGF0RmlsZS5pbml0KGFwcCk7XHJcblxyXG5cdFx0Ly8gSW5pdCBFeGVyY2lzZSBCYXNlXHJcblx0XHRsZXQgYmFzZXM6IHtbSzogc3RyaW5nXTogRXhlcmNpc2VCYXNlfSA9IHt9O1xyXG5cdFx0Zm9yIChsZXQgc3ViamVjdCBvZiBPYmplY3Qua2V5cyhFWEVSQ0lTRV9CQVNFKSkge1xyXG5cdFx0XHRjb25zdCBleGlzdHMgPSBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci5leGlzdHMoRVhFUkNJU0VfQkFTRVtzdWJqZWN0XS5wYXRoKTtcclxuXHRcdFx0YmFzZXNbc3ViamVjdF0gPSBleGlzdHMgP1xyXG5cdFx0XHRcdGF3YWl0IEV4ZXJjaXNlQmFzZS5yZWFkKGFwcCxFWEVSQ0lTRV9CQVNFW3N1YmplY3RdLnBhdGgpIDpcclxuXHRcdFx0XHRhd2FpdCBFeGVyY2lzZUJhc2UuY3JlYXRlKGFwcCxzdWJqZWN0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0IFN0YXRGaWxlXHJcblx0XHRjb25zdCBzdGF0RmlsZVBhdGggPSBTdGF0RmlsZS5wYXRoO1xyXG5cdFx0Y29uc3QgZXhpc3RzID0gYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKHN0YXRGaWxlUGF0aCk7XHJcblx0XHRsZXQgc3RhdEZpbGU6U3RhdEZpbGU7XHJcblx0XHRpZiAoZXhpc3RzKSB7XHJcblx0XHRcdGNvbnN0IGRheUZyb250bWF0dGVyOiBEYXlGcm9udG1hdHRlciA9IHBhcnNlRnJvbnRtYXR0ZXIoYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChub3JtYWxpemVQYXRoKHN0YXRGaWxlUGF0aCkpKSBhcyBEYXlGcm9udG1hdHRlclxyXG5cdFx0XHRzdGF0RmlsZSA9IFN0YXRGaWxlLmZyb21Gcm9udG1hdHRlcihhcHAsZGF5RnJvbnRtYXR0ZXIpXHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0c3RhdEZpbGUgPSBuZXcgU3RhdEZpbGUoYXBwKVxyXG5cdFx0XHRhd2FpdCBzdGF0RmlsZS5zYXZlKClcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IERhdGFQcm9jZXNzb3IoYXBwLGJhc2VzLHN0YXRGaWxlKTtcclxuXHR9XHJcblxyXG5cdGdldEZpZWxkVmFsdWUoa2V5U3VmZml4OnN0cmluZyl7XHJcblx0XHRyZXR1cm4gKHRoaXMuc3RhdGZpbGUgYXMgYW55KVtgJHt0aGlzLmFjdGl2ZUJhc2U/LltcInN1YmplY3RcIl0udG9Mb3dlckNhc2UoKX0ke2tleVN1ZmZpeH1gXVxyXG5cdH1cclxuXHJcblx0YXN5bmMgdXBkYXRlRmllbGQoa2V5U3VmZml4OnN0cmluZywgdmFsdWU6IG51bWJlcil7XHJcblx0XHQvLyBjb25zb2xlLmxvZyhgTW9kaWZpbmcgJHt0aGlzLmJhc2VUeXBlLnRvTG93ZXJDYXNlKCl9JHtrZXlTdWZmaXh9XFxuIGl0cyBjdXVyZW50IHZhbHVlIGlzICR7dGhpcy5nZXRGaWVsZFZhbHVlKGtleVN1ZmZpeCl9YCk7XHJcblx0XHQodGhpcy5zdGF0ZmlsZSBhcyBhbnkpW2Ake3RoaXMuYWN0aXZlQmFzZT8uW1wic3ViamVjdFwiXS50b0xvd2VyQ2FzZSgpfSR7a2V5U3VmZml4fWBdID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRhc3luYyBpbmNyZWFzZUV4ZXJjaXNlQ291bnQoKXtcclxuXHRcdC8vICh0aGlzLnN0YXRmaWxlIGFzIGFueSlbYCR7dGhpcy5iYXNlVHlwZS50b0xvd2VyQ2FzZSgpfV9leGVyY2lzZXNgXSArKztcclxuXHRcdGxldCBub2U6IG51bWJlciA9IHRoaXMuZ2V0RmllbGRWYWx1ZShFWEVSQ0lTRVNfS0VZKTtcclxuXHRcdHRoaXMudXBkYXRlRmllbGQoRVhFUkNJU0VTX0tFWSwgKysgbm9lKTtcclxuXHR9XHJcblxyXG5cdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IG9uIGVhY2ggZXhlcmNpc2VcclxuXHRhc3luYyBjYWxjdWxhdGVBdmVyYWdlVGltZVBlckV4ZXJjaXNlKHNlY29uZHM6IG51bWJlcil7XHJcblx0XHRjb25zdCBub2U6IG51bWJlciA9IHRoaXMuZ2V0RmllbGRWYWx1ZShFWEVSQ0lTRVNfS0VZKTtcclxuXHRcdGxldCBmdiA9IHRoaXMuZ2V0RmllbGRWYWx1ZShBVkVSQUdFX1RJTUVfS0VZKVxyXG5cdFx0dGhpcy51cGRhdGVGaWVsZChBVkVSQUdFX1RJTUVfS0VZLCAoZnYqbm9lK3NlY29uZHMpLyhub2UrMSkpO1xyXG5cclxuXHRcdHRoaXMuY2FsY3VsYXRlVGltZVNwZW50T25TdWJqZWN0Rm9yVGhlRGF5KCk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVGhpcyBmdW5jdGlvbnMgYWNjdW11bGF0ZXMgdGhlIG51bWJlciBvZiBleGVyY2lzZXMgdGhhdCBoYXMgZG9uZSBzbyBmYXJcclxuXHRhY2N1bXVsYXRlRXhlcmNpc2VDb3VudEZvclN1YmplY3QoKXt9XHJcblxyXG5cdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgdGltZSBzcGVudCBvbiBhIHBhcnRpY3VsYXIgcGFydGljdWxhciBzdWJqZWN0XHJcblx0YXN5bmMgY2FsY3VsYXRlVGltZVNwZW50T25TdWJqZWN0Rm9yVGhlRGF5KCl7XHJcblx0XHRjb25zdCBub2U6IG51bWJlciA9IHRoaXMuZ2V0RmllbGRWYWx1ZShFWEVSQ0lTRVNfS0VZKTtcclxuXHRcdGNvbnN0IGF2Z1RpbWU6IG51bWJlciA9IHRoaXMuZ2V0RmllbGRWYWx1ZShBVkVSQUdFX1RJTUVfS0VZKTtcclxuXHRcdHRoaXMudXBkYXRlRmllbGQoVE9UQUxfVElNRV9LRVksIG5vZSphdmdUaW1lKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHJ1bigpe1xyXG5cdFx0dGhpcy5hY3RpdmVFeGVyY2lzZSA9IHRoaXMuYWN0aXZlQmFzZT8ubmV4dCgpXHJcblx0XHR0aGlzLmFjdGl2ZUV4ZXJjaXNlPy5zdGFydCgpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgY2xvc2VVcEN1cnJlbnRFeGVyY2lzZShlYXJseTogYm9vbGVhbiA9IGZhbHNlKXtcclxuXHRcdGlmICh0aGlzLmFjdGl2ZUV4ZXJjaXNlKSB7XHJcblx0XHRcdGlmIChlYXJseSkge1xyXG5cdFx0XHRcdHRoaXMuYWN0aXZlRXhlcmNpc2Uuc3RhcnRfdGltZSA9IDA7XHJcblx0XHRcdFx0dGhpcy5hY3RpdmVCYXNlPy51cGRhdGVSdW50aW1lQmFzZShcIm1vZGlmeVwiLCB0aGlzLmFjdGl2ZUV4ZXJjaXNlKTsgLy8gU2F2ZSBFeGVyY2lzZXNcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFjdGl2ZUJhc2U/LnNhdmUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBSdW50aW1lIEV4ZXJjaXNlIE9iamVjdFxyXG5cdFx0XHRcdHRoaXMuYWN0aXZlRXhlcmNpc2UuY2xvc2UoKTtcclxuXHJcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBSdW50aW1lIFN0YXRGaWxlIE9iamVjdFxyXG5cdFx0XHRcdGF3YWl0IHRoaXMuY2FsY3VsYXRlQXZlcmFnZVRpbWVQZXJFeGVyY2lzZSh0aGlzLmFjdGl2ZUV4ZXJjaXNlLmdldER1cmF0aW9uSW5TZWNvbmRzKCkpXHJcblx0XHRcdFx0YXdhaXQgdGhpcy5pbmNyZWFzZUV4ZXJjaXNlQ291bnQoKTtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmNhbGN1bGF0ZVRpbWVTcGVudE9uU3ViamVjdEZvclRoZURheSgpO1xyXG5cclxuXHRcdFx0XHQvLyBTYXZlIHRoZXNlIHVwZGF0ZXMgdG8gT2JzaWRpYW4gTm90ZXNcclxuXHRcdFx0XHR0aGlzLmFjdGl2ZUJhc2U/LnVwZGF0ZVJ1bnRpbWVCYXNlKFwibW9kaWZ5XCIsIHRoaXMuYWN0aXZlRXhlcmNpc2UpOyAvLyBTYXZlIEV4ZXJjaXNlc1xyXG5cclxuXHJcblx0XHRcdFx0YXdhaXQgdGhpcy5hY3RpdmVCYXNlPy5zYXZlKCk7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5zdGF0ZmlsZS5zYXZlKCk7IC8vIFNhdmUgU3RhdEZpbGVcclxuXHJcblx0XHRcdFx0bmV3IE5vdGljZShgU3RhcnQgVGltZTogJHt0aGlzLmFjdGl2ZUV4ZXJjaXNlLmdldFN0YXJ0VGltZSgpLmZvcm1hdChcImRkZCBNTU0gRCBISDptbTpzc1wiKX1cXG5cXG5FbmQgVGltZTogJHt0aGlzLmFjdGl2ZUV4ZXJjaXNlLmdldEVuZFRpbWUoKS5mb3JtYXQoXCJkZGQgTU1NIEQgSEg6bW06c3NcIil9XFxuXFxuRHVyYXRpb246ICR7dGhpcy5hY3RpdmVFeGVyY2lzZS5nZXREdXJhdGlvbkFzU3RyaW5nKCl9YCwgMTAwMDApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5hY3RpdmVFeGVyY2lzZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbiIsICJpbXBvcnQge0FwcCwgbW9tZW50LCBub3JtYWxpemVQYXRoLCBURmlsZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7RGF0YXZpZXdBcGl9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlldy9saWIvYXBpL3BsdWdpbi1hcGlcIjtcclxuaW1wb3J0IHtnZXRBUEl9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiO1xyXG5pbXBvcnQge3RvWWFtbH0gZnJvbSBcIi4vc3JjL3V0aWxpdHkvcGFyc2VyXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERheU1ldGFkYXRhIHtcclxuXHRtYXRoX2V4ZXJjaXNlczogbnVtYmVyO1xyXG5cdG1hdGhfYXZlcmFnZVRpbWU6IG51bWJlcjtcclxuXHRtYXRoX3RvdGFsX3RpbWU6IG51bWJlcjtcclxuXHJcblx0ZHNwX2V4ZXJjaXNlczogbnVtYmVyO1xyXG5cdGRzcF9hdmVyYWdlVGltZTogbnVtYmVyO1xyXG5cdGRzcF90b3RhbF90aW1lOm51bWJlcjtcclxuXHJcblx0cG9saXRpY3NfZXhlcmNpc2VzOiBudW1iZXI7XHJcblx0cG9saXRpY3NfYXZlcmFnZVRpbWU6IG51bWJlcjtcclxuXHRwb2xpdGljc190b3RhbF90aW1lOiBudW1iZXI7XHJcblxyXG5cdHRvdG9hbF9mb2N1c190aW1lOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIERheUZyb250bWF0dGVyID0gRGF5TWV0YWRhdGE7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFN0YXRGaWxlIGltcGxlbWVudHMgRGF5TWV0YWRhdGF7XHJcblx0ZHNwX2F2ZXJhZ2VUaW1lOiBudW1iZXIgPSAwO1xyXG5cdGRzcF9leGVyY2lzZXM6IG51bWJlciA9IDA7XHJcblx0ZHNwX3RvdGFsX3RpbWU6IG51bWJlciA9IDA7XHJcblxyXG5cdG1hdGhfYXZlcmFnZVRpbWU6IG51bWJlciA9IDA7XHJcblx0bWF0aF9leGVyY2lzZXM6IG51bWJlciA9IDA7XHJcblx0bWF0aF90b3RhbF90aW1lOiBudW1iZXIgPSAwO1xyXG5cclxuXHRwb2xpdGljc19hdmVyYWdlVGltZTogbnVtYmVyID0gMDtcclxuXHRwb2xpdGljc19leGVyY2lzZXM6IG51bWJlciA9IDA7XHJcblx0cG9saXRpY3NfdG90YWxfdGltZTogbnVtYmVyID0gMDtcclxuXHJcblx0dG90b2FsX2ZvY3VzX3RpbWU6IG51bWJlciA9IDA7XHJcblxyXG5cclxuXHRmaWxlXzogVEZpbGUgfCBudWxsO1xyXG5cdGZpbGVQYXRoXzpzdHJpbmc7XHJcblx0ZXhpc3RzXzogYm9vbGVhbjtcclxuXHRhcHBfOiBBcHA7XHJcblx0ZHZfOiBEYXRhdmlld0FwaSB8IHVuZGVmaW5lZDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOkFwcCwgZGFpbHlkYXRhPzogRGF5TWV0YWRhdGEpIHtcclxuXHRcdHRoaXMuYXBwXyA9IGFwcDtcclxuXHRcdC8vIHRoaXMuZmlsZVBhdGhfID0gZmlsZVBhdGg7XHJcblx0XHR0aGlzLmR2XyA9IGdldEFQSSgpO1xyXG5cdFx0Ly8gdGhpcy5maWxlXyA9IHRoaXMuYXBwXy5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHRoaXMucGF0aCx0aGlzLnBhdGgpO1xyXG5cdFx0Ly8gdGhpcy5leGlzdHNfID0gdGhpcy5maWxlXyAhPSBudWxsIDtcclxuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgZGFpbHlkYXRhKTtcclxuXHR9XHJcblxyXG5cdC8vIHN0cmluZ2lmeSgpOiBzdHJpbmdcclxuXHJcblx0c3RhdGljIGdldCBwYXRoKCl7XHJcblx0XHRjb25zdCBkYXRlX3N0cmluZyA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZVBhdGgoYFx1RDgzRFx1REREM1x1RkUwRkRhaWx5IG5vdGVzL0RGJHtkYXRlX3N0cmluZ30ubWRgKTtcclxuXHR9XHJcblxyXG5cdGdldCBwYXRoKCl7XHJcblx0XHRjb25zdCBkYXRlX3N0cmluZyA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZVBhdGgoYFx1RDgzRFx1REREM1x1RkUwRkRhaWx5IG5vdGVzL0RGJHtkYXRlX3N0cmluZ30ubWRgKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmUoKXtcclxuXHRcdGNvbnN0IGNvbnRlbnQgPSB0b1lhbWwodGhpcyxcIl9cIilcclxuXHRcdGF3YWl0IHRoaXMuYXBwXy52YXVsdC5hZGFwdGVyLndyaXRlKG5vcm1hbGl6ZVBhdGgodGhpcy5wYXRoKSwgY29udGVudCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUZyb250bWF0dGVyKGFwcDpBcHAsIGRhdGE6IERheUZyb250bWF0dGVyKTogU3RhdEZpbGUge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGF0RmlsZShhcHAsIGRhdGEpO1xyXG5cdH1cclxuXHJcblxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLFFBQU0sYUFBTixjQUF5QixNQUFNO0lBQUE7QUFLeEIsUUFBTSx1QkFBTixjQUFtQyxXQUFXO01BQ25ELFlBQVksUUFBUTtBQUNsQixjQUFNLHFCQUFxQixPQUFPLFVBQVMsR0FBSTtNQUNuRDtJQUNBO0FBS08sUUFBTSx1QkFBTixjQUFtQyxXQUFXO01BQ25ELFlBQVksUUFBUTtBQUNsQixjQUFNLHFCQUFxQixPQUFPLFVBQVMsR0FBSTtNQUNuRDtJQUNBO0FBS08sUUFBTSx1QkFBTixjQUFtQyxXQUFXO01BQ25ELFlBQVksUUFBUTtBQUNsQixjQUFNLHFCQUFxQixPQUFPLFVBQVMsR0FBSTtNQUNuRDtJQUNBO0FBS08sUUFBTSxnQ0FBTixjQUE0QyxXQUFXO0lBQUE7QUFLdkQsUUFBTSxtQkFBTixjQUErQixXQUFXO01BQy9DLFlBQVksTUFBTTtBQUNoQixjQUFNLGdCQUFnQixNQUFNO01BQ2hDO0lBQ0E7QUFLTyxRQUFNLHVCQUFOLGNBQW1DLFdBQVc7SUFBQTtBQUs5QyxRQUFNLHNCQUFOLGNBQWtDLFdBQVc7TUFDbEQsY0FBYztBQUNaLGNBQU0sMkJBQTJCO01BQ3JDO0lBQ0E7QUN4REEsUUFBTSxJQUFJO0FBQVYsUUFDRSxJQUFJO0FBRE4sUUFFRSxJQUFJO0FBRUMsUUFBTSxhQUFhO01BQ3hCLE1BQU07TUFDTixPQUFPO01BQ1AsS0FBSztJQUNQ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R0QsS0FBRSxLQUFHQSxLQUFFO0FBQUUsb0JBQU0sSUFBSSxNQUFNM0MsS0FBRSwyQ0FBMkM7QUFBRSxnQkFBSTRDO1VBQUM7QUFBQyxtQkFBUyxFQUFFNUMsSUFBRTtBQUFDLG1CQUFPLEVBQUUsVUFBU0EsRUFBQyxHQUFFLEVBQUUsWUFBVUEsS0FBRSxLQUFJQSxFQUFDLEVBQUUsSUFBSSxTQUFTMkMsSUFBRTtBQUFDLHFCQUFPQSxHQUFFLFdBQVcsR0FBRTNDLEVBQUM7WUFBQyxDQUFDO1VBQUM7QUFBQyxtQkFBUyxFQUFFQSxJQUFFO0FBQUMsbUJBQU8sRUFBRSxVQUFTQSxFQUFDLEdBQUUsRUFBRSxZQUFVQSxLQUFFLEtBQUlBLEVBQUMsRUFBRSxJQUFJLFNBQVMyQyxJQUFFO0FBQUMscUJBQU9BLEdBQUUsV0FBVyxHQUFFM0MsRUFBQztZQUFDLENBQUM7VUFBQztBQUFDLG1CQUFTLEVBQUVBLElBQUU7QUFBQyxtQkFBTyxFQUFFLFNBQVFBLEVBQUMsR0FBRSxFQUFFLFdBQVNBLEtBQUUsS0FBSUEsRUFBQyxFQUFFLElBQUksU0FBUzJDLElBQUU7QUFBQyxxQkFBT0EsR0FBRSxVQUFVLEdBQUUzQyxFQUFDO1lBQUMsQ0FBQztVQUFDO0FBQUMsbUJBQVMsRUFBRUEsSUFBRTtBQUFDLG1CQUFPLEVBQUUsU0FBUUEsRUFBQyxHQUFFLEVBQUUsV0FBU0EsS0FBRSxLQUFJQSxFQUFDLEVBQUUsSUFBSSxTQUFTMkMsSUFBRTtBQUFDLHFCQUFPQSxHQUFFLFVBQVUsR0FBRTNDLEVBQUM7WUFBQyxDQUFDO1VBQUM7QUFBQyxtQkFBUyxFQUFFQSxJQUFFO0FBQUMsbUJBQU9BLGNBQWE7VUFBQztBQUFDLG1CQUFTLEVBQUVBLElBQUU7QUFBQyxtQkFBTSxxQkFBbUIsQ0FBQSxFQUFHLFNBQVMsS0FBS0EsRUFBQztVQUFDO0FBQUMsbUJBQVMsRUFBRUEsSUFBRTtBQUFDLG1CQUFPLEVBQUMsS0FBSSxPQUFPLFNBQVNBLEVBQUM7VUFBQztBQUFDLG1CQUFTLEVBQUVBLElBQUUyQyxJQUFFO0FBQUMsbUJBQU0s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QUUsS0FBRyxFQUFFLElBQUksR0FBRSxLQUFHLEVBQUUsTUFBTSxHQUFFLEtBQUcsRUFBRSxJQUFHLElBQUcsRUFBRSxFQUFFLEtBQUssU0FBUyxHQUFFLEtBQUcsRUFBRSxJQUFHLEVBQUU7QUFBRSxZQUFFLE1BQUksSUFBRyxFQUFFLE1BQUksR0FBRSxFQUFFLE1BQUksSUFBRyxFQUFFLEtBQUcsSUFBRyxFQUFFLGlCQUFlLFNBQVMzQyxJQUFFO0FBQUMsZ0JBQUkyQyxLQUFFLENBQUE7QUFBRyxxQkFBUUMsTUFBSzVDO0FBQUUsZUFBQyxDQUFBLEdBQUksZUFBZSxLQUFLQSxJQUFFNEMsRUFBQyxLQUFHLFNBQVNBLElBQUU7QUFBQyxnQkFBQUQsR0FBRUMsRUFBQyxJQUFFLEdBQUcsV0FBVTtBQUFDLHlCQUFPNUMsR0FBRTRDLEVBQUMsRUFBRUQsRUFBQztnQkFBQyxDQUFDO2NBQUMsRUFBRUMsRUFBQztBQUFFLG1CQUFPRDtVQUFDLEdBQUUsRUFBRSxPQUFLLElBQUcsRUFBRSxTQUFPLFNBQVMzQyxJQUFFO0FBQUMsbUJBQU8sRUFBRUEsR0FBRSxHQUFFLENBQUMsQ0FBQztVQUFDLEdBQUUsRUFBRSxRQUFNLElBQUcsRUFBRSxTQUFPLElBQUcsRUFBRSxRQUFNLElBQUcsRUFBRSxNQUFJLElBQUcsRUFBRSxNQUFJLElBQUcsRUFBRSxPQUFLLEdBQUUsRUFBRSxjQUFZLEdBQUUsRUFBRSxRQUFNLElBQUcsRUFBRSxXQUFTLEdBQUUsRUFBRSxPQUFLLElBQUcsRUFBRSxTQUFPLElBQUcsRUFBRSxVQUFRLElBQUcsRUFBRSxLQUFHLElBQUcsRUFBRSxZQUFVLEdBQUUsRUFBRSxjQUFZLEdBQUUsRUFBRSxjQUFZLEdBQUUsRUFBRSxVQUFRLElBQUcsRUFBRSxTQUFPLFNBQVNBLElBQUU7QUFBQyxtQkFBTyxHQUFHLFNBQVMyQyxJQUFFO0FBQUMscUJBQU8zQyxHQUFFLFFBQVEyQyxFQUFDLElBQUU7WUFBQyxDQUFDLEVBQUUsS0FBSyxjQUFZM0MsS0FBRSxHQUFHO1VBQUMsR0FBRSxFQUFFLGdCQUFj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Q1osQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBRUg7QUFBQSxFQUVBLFVBQVU7QUFDVCxTQUFLLFVBQVUsTUFBTTtBQUFBLEVBQ3RCO0FBQ0Q7QUFDTyxJQUFNLFlBQU4sY0FBd0IsdUJBQU07QUFBQSxFQUlwQyxZQUFZLEtBQVUsS0FBa0I7QUFDdkMsVUFBTSxHQUFHO0FBQ1QsU0FBSyxNQUFNO0FBQUEsRUFDWjtBQUFBLEVBRUEsU0FBUztBQUNSLFNBQUssVUFBVSxTQUFTLE1BQUssRUFBQyxNQUFLLDBCQUF5QixDQUFDO0FBRTdELFFBQUkseUJBQVEsS0FBSyxTQUFTLEVBQ3hCLFlBQWEsUUFBTTtBQUNuQixXQUFLLEtBQUssR0FDUixXQUFXLE9BQU8sT0FBTyxnQkFBZ0IsRUFBRTtBQUFBLFFBQzNDLENBQUMsS0FBSSxTQUFPO0FBQ1osY0FBSSxJQUFJLElBQUk7QUFDWixpQkFBTztBQUFBLFFBQ1I7QUFBQSxRQUFHLENBQUM7QUFBQSxNQUFDLENBQUMsRUFBRSxTQUFTO0FBRWxCLFNBQ0UsU0FBUyxPQUFLO0FBQ2QsYUFBSyxLQUFNO0FBQUEsTUFDWixDQUFDO0FBQUEsSUFDSCxDQUFFO0FBRUgsUUFBSSx5QkFBUSxLQUFLLFNBQVMsRUFDeEIsVUFBVSxRQUFNO0FBQ2hCLFNBQ0UsT0FBTyxFQUNQLGNBQWMsU0FBUyxFQUN2QixRQUFRLE1BQUk7QUFDWixhQUFLLElBQUksYUFBYSxLQUFLLElBQUksTUFBTSxLQUFLLEVBQUU7QUFDNUMsYUFBSyxNQUFNO0FBQUEsTUFDWixDQUFDO0FBQUEsSUFDSCxDQUFDO0FBQUEsRUFDSDtBQUFBLEVBQ0EsVUFBVTtBQUNULFNBQUssVUFBVSxNQUFNO0FBQUEsRUFDdEI7QUFDRDsiLAogICJuYW1lcyI6IFsic2luZ2xldG9uIiwgInR5cGUiLCAicyIsICJwYWRTdGFydCIsICJFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSIsICJFbmdsaXNoLm1vbnRocyIsICJFbmdsaXNoLndlZWtkYXlzIiwgIkVuZ2xpc2gubWVyaWRpZW1zIiwgIkVuZ2xpc2guZXJhcyIsICJvZmZzZXQiLCAiZGVmYXVsdFpvbmUiLCAibiIsICJpc0ludGVnZXIiLCAiRm9ybWF0cy5EQVRFX1NIT1JUIiwgIkZvcm1hdHMuREFURV9NRUQiLCAiRm9ybWF0cy5EQVRFX0ZVTEwiLCAiRm9ybWF0cy5EQVRFX0hVR0UiLCAiRm9ybWF0cy5USU1FX1NJTVBMRSIsICJGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCIsICJGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCIsICJGb3JtYXRzLlRJTUVfMjRfU0lNUExFIiwgIkZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUIiwgIkZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUIiwgIkZvcm1hdHMuREFURVRJTUVfU0hPUlQiLCAiRm9ybWF0cy5EQVRFVElNRV9NRUQiLCAiRm9ybWF0cy5EQVRFVElNRV9GVUxMIiwgIkZvcm1hdHMuREFURVRJTUVfSFVHRSIsICJGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTIiwgImZvcm1hdE9mZnNldCIsICJFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC5tb250aEZvckRhdGVUaW1lIiwgIkVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lIiwgIkVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUiLCAibWF0Y2giLCAiaW50IiwgIkVuZ2xpc2gubW9udGhzU2hvcnQiLCAiRW5nbGlzaC53ZWVrZGF5c0xvbmciLCAiRW5nbGlzaC53ZWVrZGF5c1Nob3J0IiwgIklOVkFMSUQiLCAib3JkZXJlZFVuaXRzIiwgImNsb25lIiwgImwiLCAic3RyIiwgImUiLCAiRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwgIlJlc3VsdCIsICJtb2R1bGUiLCAidGhpcyIsICJ0IiwgInIiLCAidSIsICJvIiwgImkiLCAiYSIsICJmIiwgImMiLCAiaCIsICJwIiwgImQiLCAidiIsICJnIiwgIm0iLCAiUC5hbHQiLCAiUC5yZWdleCIsICJQLndoaXRlc3BhY2UiLCAiUC5hbnkiLCAiVmFsdWVzIiwgInRvU3RyaW5nIiwgImlzTnVsbCIsICJpc051bWJlciIsICJpc1N0cmluZyIsICJpc0Jvb2xlYW4iLCAiaXNEYXRlIiwgImlzT2JqZWN0IiwgIkdyb3VwaW5ncyIsICJXaWRnZXRzIiwgIkZpZWxkcyIsICJpbmRleCIsICJmdW5jIiwgIlNvdXJjZXMiLCAidGFnIiwgIlAuc2VxTWFwIiwgIlAuc2VxIiwgIlAub3B0V2hpdGVzcGFjZSIsICJQLmN1c3RvbSIsICJQLmNyZWF0ZUxhbmd1YWdlIiwgIlAucmVnZXhwIiwgIlAuc3RyaW5nIiwgIlAubm9uZU9mIiwgIl8iLCAiUC5zdWNjZWVkIiwgIlAuZmFpbCIsICJwYXJzZUZpZWxkIiwgIlF1ZXJ5RmllbGRzIiwgIlAuc2VwQnkiLCAiZ2V0QVBJIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJmaWxlIiwgImV4Y2VwdGlvbiIsICJtYXAiLCAic2NoZW1hIiwgInR5cGUiLCAiZXh0ZW5kIiwgInN0ciIsICJzdHJpbmciLCAiRXhjYWxpZHJhd0ZpbGUiLCAiRVhFUkNJU0VfU1VCSkVDVCIsICJFWEVSQ0lTRV9TVEFUVVNFU19TV0FQUEVEIiwgIkV4Y2FsaWRyYXdGaWxlIiwgImltcG9ydF9vYnNpZGlhbl9kYXRhdmlldyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuX2RhdGF2aWV3IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW5fZGF0YXZpZXciLCAiZXhpc3RzIiwgIkV4Y2FsaWRyYXdGaWxlIl0KfQo=
